[{"content":"JavaWeb 初始Web前端 Web标准也称网页标准\n三个组成部分\nHTML超文本标记语言: 负责网页的结构(页面元素和内容) CSS层叠样式表: 负责网页的表现(页面元素的外观，位置等) JavaScript: 负责网页的行为(交互效果)\n官方文档\nHTML HTML标签特点\n不区分大小写 标签属性值单双引号都可以 HTML语法松散 HTML标签\n\u0026lt;h1\u0026gt;到\u0026lt;h6\u0026gt;重要程度依次降低，都是提前预定义好的，不能自己随便定义 \u0026lt;hr\u0026gt;水平线标签 \u0026lt;img src=\u0026quot;...\u0026quot; width = \u0026quot;\u0026quot; height=\u0026quot;\u0026quot;\u0026gt;图片标签(./当前目录，../上级目录) \u0026lt;span\u0026gt;行标签，没有任何意义，就是赋予内容一个标签名字 \u0026lt;video\u0026gt;视频标签 src:规定视频的url controls:显示播放控件 width:宽 height:高 \u0026lt;audio\u0026gt;音频标签 src:规定音频的url controls:显示播放控件 \u0026lt;p\u0026gt;段落标签 \u0026lt;b\u0026gt;/\u0026lt;strong\u0026gt;文本加粗标签 CSS CSS引入方式\n行内样式: 写在标签的style属性中(不推荐) 内嵌样式: 写在style标签中(可以写在页面的任何位置，但通常约定写在head标签中) 外联样式: 写在一个单独的.css文件中(需要通过link标签在网页中引入) 颜色表示方式\n关键字:预定义的颜色吗\u0026mdash;red，green，blue\u0026hellip; rgb表示法:红绿蓝三原色，每项取值时0~255\u0026mdash;rgb(255，0，0)\u0026hellip; 十六进制表示法:#开头，将数字转换成十六进制表示\u0026mdash;#000000，#cccccc(简写#000，#ccc) CSS选择器:用来选取需要设置样式的元素(标签)\n元素选择器:根据标签类型来选择修改样式 id选择器:根据id名来选择修改样式(id是唯一的) 类选择器:根据class名来选择修改样式(类名可以重复) 优先级:id选择器\u0026gt;类选择器\u0026gt;元素选择器 CSS属性\ncolor:设置文本的颜色 font-size:设置字体大小 text-decoration:规定添加到文本的修饰，none表示定义标准的文本 line-height:设置行高 text-indent:定义第一行内容缩进 text-align:规定元素中的文本的水平对齐方式 超链接:\u0026lt;a href=\u0026quot;链接跳转地址\u0026quot; target=\u0026quot;定义是否在新页面打开\u0026quot;\u0026gt;\n注意:HTML中无论输入多少空格都只会显示一个，可以使用空格占位符\u0026amp;nbsp\n页面布局\n盒子:页面中所有的元素(标签)，都可以看做是一个盒子，由盒子将页面中的元素包含在一个矩形区域内，通过盒子的视角更方便的进行页面布局\n盒子模型的组成:内容区域(content)，内边距区域(padding)，边框区域(border)，外边框区域(margin)\n布局标签:实际开发中会大量使用div和span这俩个没有语义的布局标签\ndiv标签:一行只显示一个，宽度默认是夫元素的宽度，高度默认是内容撑开，可以设置宽高\nspan标签:一行可以显示多个，宽度高度默认有内容撑开，不可以自己设置宽高\n例 div {\nwidth: 200px;\nheight: 200px;\nbox-sizing: border-box;\u0026ndash;指定width和height为盒子的宽高\nbackground-color: red;\u0026ndash;背景色\npadding: 20px;\u0026ndash;内边距 上-\u0026gt;右-\u0026gt;下-\u0026gt;左\nborder: 10px solid red;\u0026ndash;边框 边框-\u0026gt;宽度-\u0026gt;线条类型-\u0026gt;颜色\nmargin: 30px;\u0026ndash;外边距 上-\u0026gt;右-\u0026gt;下-\u0026gt;左\n}\n注意:如果要设置某一个方位的属性只需要在属性名后加上方位就行 如:padding-top，padding-left\n表格标签\n表格中的数据会以行和列的形式展示出来\n\u0026lt;table\u0026gt;定义表格整体，可以包裹多个\u0026lt;tr\u0026gt; border边框宽 windth宽 cellspacing间隙\n\u0026lt;tr\u0026gt;表格的行可以包裹多个\u0026lt;tb\u0026gt;\u0026lt;br\u0026gt; \u0026lt;tb\u0026gt;表格单元格(普通)，可以包裹内容，如果是表头单元格可以替换成\n表单标签\n表单标签\u0026lt;form\u0026gt;\n场景: 在网页中主要负责数据采集功能如:注册，登录等\n表单项: 不同类型的input元素，下拉列表，文本域等\n\u0026lt;input\u0026gt;定义表单项，通过type属性控制输入形式\ninput的type属性:text，password，radio，checkbox，file，date，datetime-local，time，number，hidden，button，submit\n\u0026lt;select\u0026gt;定义下拉列表\n\u0026lt;textarea\u0026gt;定义文本域\n注意:表单项必须有name属性才可以提交 属性\n1：action:规定当提交表单时向何处发送表单数据，URL\n2：method:规定用于发送表单数据的方式 get，post\nget:url后面拼接表单数据，有长度限制，默认值 post:消息体中传递，参数无限制\nJavaScript\n是一门跨平台，面向对象的脚本语言\nJS引入方式\n内部脚本:JS代码定义在HTML页面中位于\u0026lt;script\u0026gt;\u0026lt;/script\u0026gt;之间\n外部脚本:定义在外部JS文件中，只包含JS代码，\n注意:\u0026lt;script\u0026gt;可以在任何位置，但是一般在body元素底部，改善显示速度，JS文件里面不含\u0026lt;script\u0026gt;标签，\u0026lt;script\u0026gt;不能自闭合\nJS基础语法\n书写语法\n区分大小写\n每行结尾的分号可有可无\n注释:单行注释\u0026mdash;-//\u0026hellip; 多行注释\u0026mdash;-/\u0026hellip;/\n大括号表示代码块\n输出语句\n使用window.alert()\u0026ndash;写入警告框\n使用document.write()\u0026ndash;写入HTML页面中\n使用console.log()\u0026ndash;写入浏览器控制台\n变量\nJS中用var关键字来声明变量(全局，可重复声明)\nJS是一门弱类型语言，变量可以存放不同类型的值\n规则:组成是字母，数字，下划线，或美元符号，数字不能开头\n新增的 let(代码块生效，不能重复声明) const(只读声明，一旦定义不能更改)\n数据类型\nJS中分为:原始类型和引用类型\nnumber数字，string字符串，boolean布尔，null空，undefined未初始化默认值\n使用typeof运算符可以获取数据类型\n运算符\n算术运算符:+，-，，/，%，++，\u0026ndash;\n赋值运算符:=，+=，-=，=，/=，%=\n比较运算符:\u0026gt;，\u0026lt;，\u0026gt;=，\u0026lt;=，!=，==，===\n逻辑运算符:\u0026amp;\u0026amp;，||，!\n三元运算符:\u0026hellip;? a:b\n==会进行类型转换 ===不会进行类型转换\n类型转换 1.字符串转换成数字，从第一个开始到第一个非数字，如果为空就是NaN\n2.转换成布尔型，0和空和NaN和undefined都会转换成False\n流程控制语句\n省略\u0026hellip;..\nJS函数\n函数是被设计为执行特点任务的代码块\nJS函数通过function关键字进行定义 语法为 function a(..){\u0026hellip;}\n形参不需要类型，返回值也不需要定义类型，直接return返回即可\n第二种定义方式:var a=function(..){\u0026hellip;}\nJS对象\nArray对象\n定义1: var 变量名 = new Array(\u0026hellip;)\n定义2: var 变量名 = [\u0026hellip;]\n访问: 变量名[索引] = 值\nJS种数组长度可越界会自动增加索引，里面数据类型也可以存储任意类型\n属性:length\u0026ndash;返回数组元素数量\n方法:forEach(..)=\u0026gt;{..}\u0026ndash;遍历有值的元素 push()\u0026ndash;添加 splice()\u0026ndash;删除\nString字符串\n定义1: var 变量名 = new String(\u0026quot;\u0026hellip;\u0026quot;)\n定义2: var 变量名 = \u0026ldquo;\u0026hellip;\u0026quot;\n属性:length\u0026ndash;长度\n方法:charAt()\u0026ndash;返回指定位置字符 indexOf()\u0026ndash;检索字符串 trim()\u0026ndash;去除两边空格 substring()\u0026ndash;截取(包头不包尾)\nJS自定义对象\n定义格式:\nvar 对象名 = {\n属性名1: 属性值1，\n属性名2: 属性值2，\n函数名称: function(形参列表){\u0026hellip;}};\n调用格式:对象名.属性名; 对象名.函数名();\nJSON\nJSON是通过JavaScript对象标记法书写的文本\nJSON就是key和value形式的键值对，只不过key需要用双引号引起来\n语法简单，层次鲜明，现多用于作为数据载体，在网络中进行数据传输\n定义:var 变量名 = \u0026lsquo;{\u0026ldquo;key1\u0026rdquo;:value1，\u0026ldquo;key2\u0026rdquo;:value2}\u0026rsquo;;\nvalue的数据类型 数字\u0026ndash;正常写，字符串\u0026ndash;双引号，逻辑值\u0026ndash;true/false，数组\u0026ndash;方括号，对象\u0026ndash;花括号\n例:var a = \u0026lsquo;{\u0026ldquo;name\u0026rdquo;:\u0026ldquo;Tom\u0026rdquo;，\u0026ldquo;age\u0026rdquo;:20，\u0026ldquo;add\u0026rdquo;:[\u0026ldquo;上\u0026rdquo;，\u0026ldquo;下\u0026rdquo;]}\u0026rsquo;; 方法: parse()\u0026ndash;将JSON变量转成JS对象 stringify()\u0026ndash;将JS对象转成JSON变量\nBOM\nBOM是浏览器对象模型，允许JS与浏览器对话，JS将浏览器的各个组成部分封装为对象\nWindow:浏览器窗口对象\n直接使用window，其中window可以省略\n属性:history:\u0026mdash;location:\u0026mdash;navigator: 获取对象的对象，详情参考官方文档\n方法:alert()警告弹窗 confirm()消息弹窗 setInterval()周期延迟运行 setTimeout()延迟运行\nNavigator:浏览器对象\nScreen:屏幕对象\nHistory:历史记录对象\nLocation:地址栏对象\n获取:window.location.属性/location.属性\n属性:href设置或返回完整的URL\nDOM\nDOM是文档对象模型\n将标记语言的各个组成部分封装为对应的对象\nJS通过DOM就能够对HTML进行操作\nDOM是W3C(万维网联盟)的标准，定义了HTML和XML的标准，有以下三种\n所有文档的标准模型\nDocument:整个文档对象\nElement:元素对象\nAttribute:属性对象\nText:文本对象\nComment:注释对象\nXML DOM-XML文档的标准模型\nHTML DOM-HTML文档的标准模型\nimage:\u0026lt;img\u0026gt;\nButton:\u0026lt;input type='button'\u0026gt;\nDocument对象提供了以下获取Element元素的函数\n根据id属性值获取，返回单个Element对象\nvar h1 = document.getElementById(\u0026rsquo;..\u0026rsquo;);\n根据标签名称获取，返回Element对象数组\nvar h2 = document.getElementByTagName(\u0026rsquo;..\u0026rsquo;);\n根据name属性值获取，返回Element对象数组\nvar h3 = document.getElementByName(\u0026rsquo;..\u0026rsquo;);\n根据class属性值获取，返回Element对象数组\nvar h4 = document.getElementByClassName(\u0026rsquo;..\u0026rsquo;);\n具体操作步骤:先获取元素对象赋值-\u0026gt;然后调用方法去改变内容-\u0026gt;刷新页面\n具体参考官方文档\n事件监听\n事件:发生在HTML元素上的事件\n绑定方式1:通过HTML标签中的事件进行绑定\n绑定方式2:通过DOM元素属性绑定\n常见事件\nonclick\u0026mdash;鼠标单击事件\nonblur\u0026mdash;元素失去焦点\nonfocus\u0026mdash;元素获得焦点\nonload\u0026mdash;某个页面或图像加载完毕\nonsubmit\u0026mdash;表单提交事件\nonkeydown\u0026mdash;键盘摁键事件\nonmouseover\u0026mdash;鼠标移动到元素上\nonmouseout\u0026mdash;鼠标从元素上移开\n插值表达式\n形式: {{表达式}}\n表达式内容可以是变量，三元运算符，函数调用，算术运算\nVue\nVue是一套前端框架，免除原生JavaScript中的DOM操作，简化书写.\n基于MVVM思想，实现数据的双向绑定\n官网:Vue.js - 渐进式 JavaScript 框架 | Vue.js (vuejs.org)\n框架:是一个半成品，是一套可重复的，通用的软件基础代码模型，基于框架开发，更加高效，更快捷\n补充: 在Vue中以v-打头的叫做指令\n常用指令\nv-bind:让HTML标签绑定属性值从静态变成动态，如设置href，css样式等\nv-model:为表单元素上创建双向数据绑定\nv-on:为HTML标签绑定事件(事件在methods:{..}中写)\nv-if/v-else-if/v-else:判断条件\nv-show:根据条件展示某元素，区别在于切换的是display属性的值\nv-for:列表渲染，遍历元素或对象的属性\ndisplay属性:表示元素是显示还是隐藏\n创建Vue里面的方法 el\u0026ndash;定义vue接管区域 data\u0026ndash;定义用到的数据模型 mounted\u0026ndash;挂载完成 methods\u0026ndash;定义用到的事件\n生命周期\n生命周期的八个阶段:每触发一个生命周期事件，会自动执行一个生命周期法子(钩子)\nbeforeCreate\u0026mdash;-创建前\ncreated\u0026mdash;-创建后\nbeforeMount\u0026mdash;-挂载前\nmounted\u0026mdash;-挂载完成\nbeforeUpdate\u0026mdash;-更新前\nupdated\u0026mdash;-更新后\nbeforeDestroy\u0026mdash;-销毁前\ndestroyed\u0026mdash;-销毁后\nAjax\nAjax是异步的JS和XML\n作用\n数据交换:通过Ajax可以给服务器发送请求，并获取服务器响应的数据\n异步交互:可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术\n原生Ajax\n1.创建XMLHttpRequest对象:用于和服务器交换数据\nvar xmlHttpRequest = new XMLHttpRequest();\n2.向服务器发送请求\nxmlHttpRequest.open(\u0026lsquo;get/post\u0026rsquo;，\u0026lsquo;url地址\u0026rsquo;);\nxmlHttpRequest.send();发送请求\n3.获取服务器响应数据\n先判断，如果响应成功就把数据赋值给一个变量\n因为比较繁琐，所有已经弃用了\nAxios\n介绍:Axios对原生的Ajax进行了封装，简化书写\n官网:Axios中文文档 | Axios中文网 (axios-http.cn)\n一般写在mounted(){\u0026hellip;}中，页面加载时完成函数回调，获取数据\n请求方式别名\u0026ndash;[表示可以省略]\naxios.get(URL[，config])\naxios.delete(URL[，config])\naxios.post(URL[，data[，config]])\naxios.put(URL[，data[，config]])\n.then(result =\u0026gt; {console.log(result.data);})回调函数\n回调函数里面也可以改成this.aaa=result.data，将数据直接返回给数据模型里面的数据\n前端开发\n前后端分离开发\n前端和后端分开开发，就需要遵守一个共同的规则，这个规则就是接口文档\n接口文档根据原型和需求来组成的\n步骤:需求分析-\u0026gt;接口定义(API接口文档)-\u0026gt;前后端并行开发-\u0026gt;测试-\u0026gt;前后端联调测试\nYApi\n介绍:YApi是高效，易用，功能强大的api管理平台，旨在为开发，产品，测试人员提高更优雅的接口管理服务\n地址: http://yapi.smart-xwork.cn/\n添加项目-\u0026gt;添加分类-\u0026gt;添加接口-\u0026gt;然后就可以去mock地址查看生成的简略数据\n前端开发工程化\n介绍:是指在企业级的前端项目开发中，把前端开发所需要的工具，技术，流程，经验等进行规范化，标准化\n环境准备 vue-cli\n介绍: vue-cli是Vue官方提高的一个脚手架，用于快速生成一个Vue的项目模板\nVue-cli提高了以下功能\n统一的目录结构\n本地调试\n热部署\n单元测试\n继承打包上线\n依赖环境: NodeJS\n下载好node后配置好npm下载地址，然后更换好下载源，然后用npm命令下载vue-cli脚手架就配置好环境了\nVue项目-创建\n第一种命令行: cmd里面输入vue create vue-project01\n第二种图形化界面: cnd里面输入vue ui\nVue项目-启动\n第一种:在目录栏最小面找npm脚本，然后在server那点按钮\n第二种:在cmd页面运行npm run serve\n然后就可以去浏览器查看vue界面了\n补充:如何修改端口号\n在vue.config.js中在最后面加上devServer: {port: 8080，}\nVue项目开发流程\nimport:引用模块 \u0026lt;==\u0026gt; export:导出为模块\nVue的组成文件以.vue结尾，每个组件由三个部分组成:，","date":"2024-09-21T12:15:23+08:00","image":"https://hugo-add.github.io/p/javaweb/a_hu13946685915875113817.jpg","permalink":"https://hugo-add.github.io/p/javaweb/","title":"JavaWeb"},{"content":"","date":"2024-09-19T23:04:01+08:00","image":"https://hugo-add.github.io/p/%E5%88%86%E4%BA%AB%E6%97%A5%E8%AE%B0/a_hu11040428914303517106.jpg","permalink":"https://hugo-add.github.io/p/%E5%88%86%E4%BA%AB%E6%97%A5%E8%AE%B0/","title":"分享日记"},{"content":"JavaSE 基础 基础讲解 cmd命令\n1：netstat -ano | findstr \u0026ldquo;端口号\u0026rdquo; -|- \u0026ldquo;软件\u0026rdquo; -version 查看软件安装情况\n2：服务-server 启动服务 -|- Ctrl+shift+R 打开替换面板\n3：盘符：(回车可以切换盘符) -|- dir 查看路径 cd 切换目录 cd.. 回到上级\n4：ipconfig:查看本机IP地址 -|- 环境变量：系统找文件的路径\n5：#include\u0026lt;stdio.h\u0026gt; #define 定义常量\n6：cmd里面 javac \u0026hellip;.java 编译Java文件 -|- Java \u0026hellip; 运行.class\n7：JDK:Java开发工具包；JRE:Java运行环境；JVM:Java运行的地方(虚拟机)\n8：JDK包含JRE:JRE包含JVM\n9：引用数据类型和基本数据类型 -|- 成员变量和局部变量\n关键字\n1：整数 小数 字符串 字符 布尔 空\n2：long:数据值后面加上L -|- float:数据值后面加上F\n3：class:后面跟随类名 -|- ＇t＇:制表符，补齐八个\n4：continue/break:跳过本次循环/结束循环 -|- int [ ]=new int[ ]:定义动态数组\n5：int ??[ ] []=new int[ ][?]定义二维动态数组 -|- int [ ][ ]={{}，{}}定义静态二维数组\n6：类名 ??[]=new 类名[?]:封装类定义数组\n7：this:成员变量[本质是调用者的地址]，在虚拟机中就是个局部变量\n8：equals和equalslgnoreCase:不忽略大小写/忽略 -|- 字符串比较用==是地址用equals比较内容\n9：?.charAt():字符串索引 -|- ?.substring (int ，int):截取字符串 -|- ?.replace(\u0026quot;\u0026quot;，\u0026quot;\u0026quot;):替换字符\n10：??.toCharArray():转换字符串为字符数组\n栈和堆\n1：栈:系统运行开辟的空间，代码的运行空间\n2：堆:关键字new开辟的空间类\n3：类可以看成是创建 Java 对象的模板。\n方法\n1：void无返回值调用:有返回值调用，有参数调用:无参数调用\n2：无参和有参都得写，put和get方法 [标准的Javabean]\n3：方法重载:方法名一样，参数不一样\nstringbuilder\n可以看成一个容器，内容是可变的，new创建.适应场景：字符串拼接/反转\n常见方法：public StringBuilder ~~\n1：append(任意类型):添加数据，并返回对象本身\n2：reverse:反转容器的内容\n3：public int length():返回长度\n4：public String toString():把SB转成string\nStringJoiner\n也是一个容器，创建后内容可变\n常见方法:public StringJoiner ~~\n(间隔符号):..\n(间隔符号，开始符号，结束符号):\u0026hellip;\nadd:添加数据\npublic int length():返回长度\npublic String toString():返回字符串\n集合\n可以自动扩容\n和数组区别:数组可以存基本数据类型和引用数据类型；集合存引用数据类型和包装类：数组长度固定；集合内存随时扩容或减小\n泛型:限定集合中的数据类型 \u0026lt;\u0026gt;\nlist.add(\u0026quot;\u0026quot;):添加元素\nlist.remove(\u0026quot; \u0026ldquo;)/( ):删除字符串内容/删除索引内容\nlist.set( ，\u0026rdquo;?\u0026quot;):修改索引的内容\nlist.get(?):查询索引内容\nlist.size( ):集合的长度\njavabean类 用来描述一下事物的类\n测试类 用来检查其他类是否书写正确，带有main方法的类，是程序入口\n工具类 不是描述，而是帮我们做事情的一些类\nstatic静态方法 静态方法没有this\n静态方法中只能调用静态\n非静态可以调用静态和非静态\n标号\nbreak 标号： 跳出标号循环\ncontinue;跳出本次循环，继续下次\nsystem.exit(0);停止虚拟机运行\n链式编程 调用方法是不用接受结果，继续调用其他方法\n网址\nURL url = new URL(\u0026quot;\u0026hellip;\u0026quot;)\u0026ndash;创建一个网址对象\nURLConnection conn = url.openConnection()\u0026ndash;链接网址\n封装/继承 public class a extendz b\na :子类(派生类)，b :父类(基类/超类)\n只支持单继承不能多继承 ， 但是能多层继承 ， 所有类继承与 Object(系统类)\n子类只能访问父类中非私有的成员\n父类的构造方法不管是不是私有的子类都无法继承；父类成员变量不管是否私有都会继承，但是私有的子类无法调用；父类的成员方法非私有可以继承私有无法继承\n就近原则：先在本类局部找→父类局部找逐级往上，重名的变量名就近原则\n1. this.:本类的成员，成员变量\n2. super.:父类的成员，成员变量\n方法的重写\n父类方法在子类中要实现出来\n@Override 重写注解\n建议重写方法与父类保持一致\n只有被添加到虚方法表中的才可以被重写\n构造方法\n父类构造方法不会被子类继承\n子类所有构造方法默认会先访问父类无参构造再执行自己\n要是想父类有参构造，必须得手动书写\n多态 前提：1.有继承/实现关系 2.有父类引用指向子类对象 3.有方法的重写\n好处：父类作为参数可以接受子类的所有对象，体型多态的扩展与便利(给父类赋值后，所有子类都可以适应)\n规则\n父类 ?? = new 子类\n调用成员变量：编译看左边，运行也看左边\n(成员变量定义是父类的，子类会继承，所以要看父类是否有)\n调用成员方法：编译看左边，运行看右边\n(方法子类会覆盖虚方法表，所以运行要看右边)\n优势\n右边(子类)可以实现解耦合，便于拓展和维护\n定义时适应父类做参数，便于接收所有子类对象，提现多态拓展与便利\n弊端\n不能调用子类的特有功能(解决方案: (子类)?? 强制转换成子类)\nif(a instanceof b){ } / if(a instanceof b d){ }: 判断a是否是b类型是否可以强制转换/新特性先判读是否是b属性，是就强制转换，变量为d(比第一个省一行强制转换代码)\n包 包名规则:公司域名反写+包的作用，需要全部英文小写，见名知意\n使用同一个包中的类不用导包，使用Java.lang包中的类时也不用导包，其他情况需要导包，如果要同时使用两个包的类，需要用全类名\nfinal (最终)\n关键字final表示最终的结果无法更改，无法继承\nfinal修饰变量内容是地址，地址无法修改，地址变量表示的内容可以修改\n权限修改符\nprivate\u0026lt;默认/空着\u0026lt;protected\u0026lt;public 同一个类\u0026lt;同一个类其他包\u0026lt;不同包下的子类\u0026lt;不同包下的无关类\n代码块\n局部代码块：用不到了.随用随释放内存\n构造代码块：用不到了.成员位置的代码块\n静态代码块：用static修饰，随着类加载而加载，只执行一次，可以在代码初始化是做些数据\n抽象类 不确定具体方法体，该方法可以定义为抽象方法如果一个类中存在抽象方法，那这个类必须声明为抽血类\n抽象修饰关键字：abstract 抽象类不用花括号\n注意点\n抽象类不能创建对象(不能实例化) 抽象类不一定有抽象方法，有抽象方法一定是抽象类 可以有构造方法\n抽象类子类要么重写抽象类的所以抽象方法，要么是抽象类\n接口 接口就是一种规则\n定义和使用\n修饰关键字：interface(public interface 接口{ })\n接口不能实例化\n接口和类是实现关系，通过implements表示(public class 类名 implements 接口名{})\n接口子类(实现类) 要么重写接口的所以抽象方法，要么是抽象类\n注意\n接口和类可以单实现也可以多实现\npublic class 类名 implements 接口名1，接口名2\n实现类可以在继承一个父类的同时实现多个接口\npublic class 类名 extends 父类 implements 接口名1，接口名2{}\n接口里面没有抽象对象表示当前接口是一个标记性接口\n成员特点\n变量：只能是常量，修饰符: public static final 构造方法：没有\n成员方法：只能是抽象方法(jdk7前的规则)， 修饰符 public abstract jdk8开始接口新增的方法\npublic default/static void ???(){}\n允许接口定义默认方法，需要用default修饰\n作用: 解决接口升级问题\n注意\n默认方法不是抽象类，所以不用被强制重写，如果要重写，重写时不要加default 如果实现多个接口，多个接口存在相同名字的默认方法，子类必须对该方法重写\n允许接口定义静态方法，需要用static修饰\n静态方法只能用接口名调用\njdk9开始接口新增的方法\n私有方法 private ， 只能接口中的方法调用\nprivate 返回值类型 ??( ){ }\n给接口中的静态方法调用\nprivate static 返回值类型 ??( ){ }\n应用\n想要什么对象类有什么规则就实现这个接口；一个方法参数是接口时可以传递接口所有实现类的对象称为接口多态\n设计模式\n适配器设计模式：解决接口与接口实现类之间的矛盾问题{用一个中间类把接口所有抽象类实现出来，然后接口实现类继承这个中间类，然后用哪个方法就重写哪个就行，不用实现全部的抽象类了}\n接口和类之间的关系\n类与类\n继承关系，只能单继承，可以多层继承\n类与接口\n实现关系，可以单实现也可多实现，还可以在继承一个类同时实现多个接口\n接口与接口\n继承关系，可单继承，也可多继承，实现类如果要实现子接口的话，需要把所有的父接口抽象类都实现\n内部类 在类的里面再定义一个类\n特点\n内部类可以直接访问外部类的成员，包括私有；外部类访问内部类的成员必须创建对象\n使用场景\n表示B是A类的一部分，且B是单独存在没有意义\n比如：汽车发动机，人的心脏\n分类\n成员内部类.静态内部类.局部内部类(了解) 匿名内部类(掌握)\n成员内部类\n可以被修饰权限符修饰\n创建内部类：外部类名.内部类名 ? = new 外部类.new 内部类\n注意：成员内部类jkd16之前不能定义静态变量\n内部类私有化后就无法直接实现内部类对象了，可以在外部类创建后，再去实现\n内部类调用重名的外部类 1.直接调用_2.用this调用_3.类名.thia.??调用\n静态内部类\n注意：静态内部类是成员内部类一种，只能访问外部类中的静态变量和静态方法，如果要访问非静态的需要创建对象\n创建静态内部类：外部类名.内部类名 ? = new 外部类.内部类\n调用静态内部类中的方法：\n非静态方法格式：先创建对象，用对象调用\n静态方法格式：外部类名.内部类名.方法名\n局部内部类\n注意：内部类定义在方法里面就是局部内部类，外界无法直接调用需要在方法内部创建对象并使用，该类可以直接访问外部类成员也可以直接访问方法内局部变量\n匿名内部类\n本质是隐藏了名字的内部类，可以写在成员位置，也可以写在局部位置\nnew 接口/抽象类 {\u0026hellip;}\n就是重写所以抽象对象创建的对象\n包含：继承或实现，方法重写，创建对象整体就是一个类的子类对象或者接口的实现类对象\n应用场景：当方法的参数是接口或者类时\n以接口为例，可以传递这个接口的实现类对象\n如果实现类只使用一次，可以使用匿名\u0026hellip;简化\n图形UI JFrame 界面对象\nJFrame a = new JFrame( );\na.setSize(高，宽) 界面大小 a.setTitle(\u0026quot; \u0026ldquo;) 界面标题 a.setAlwaysOnTop(true) 界面置顶 a.setLocationRelativeTo(null) 设置页面居中 a.setDefaultCloseOperation(3) 设置关闭方式 a.setLayout(null) 设置取消默认放置内容方式 a.setVisible(ture/false) 是否显示 setIconImage(Toolkit.getDefaultToolkit().getImage(\u0026hellip;.)); JMenuBar 菜单对象创建菜单\n创建菜单\nJMenuBar a = new JMenuBar();\n创建菜单内容\nJMenu b = new JMenuBar();\n创建菜单下的子菜单\nJMenuItem c = new JMenuBar();\n菜单和子菜单关联\nb.add(c); a.add(b);\n菜单添加到页面里\n界面变量.setJMenuBar(a);\nImageIcon 图片对象\n创建一个图片\nImageIcon a = new ImageIcon(\u0026rdquo;??/???/???.jpg\u0026quot;);\n创建一个管理容器\nJLabel b = new JLabel(a);\n指定图片位置大小\nb.setBounds(x ， y ， 高 ， 宽); 将这个容器添加到界面中\nJFrame a / this.getContenPane.add(b);\n刷新时会用到这俩个方法\n清除缓存图片\nthis.getContenPane.removeAll( );\n刷新图片\nthis.getContenPane.repaint();\n细节：先加载图片在上面，后加载图片在下面\nJLabel 容器\n容器特点: 可以添加照片文字等\n创建一个容器\nJLabel j = new JLabel( );\n设置容器大小位置\nb.setBounds(x ， y ， 高 ， 宽);\n设置容器位置\nb.setLocation\n设置容器大小\nb.setSize\n图片等只能添加到容器中然后再添加到界面\n设置字体样式和大小\n创建一个字体格式\nFont f =new Font(\u0026ldquo;宋体\u0026rdquo;， 字体样式 ， 20);\n应用font样式\nj.setFont(f);\n设置字体颜色\nj.setForeground(Color.red);\nJButton 按钮对象\n创建一个按钮\nJButton a = new Button(\u0026quot;??\u0026quot;);\n设置按钮大小\na.setBounds(x ， y ， 宽 ， 高); 添加按钮到界面\nthis.setContenPane(a);\n事件\n事件源：按钮，窗体，图片\u0026hellip;.\n某些操作如：鼠标点击，划入\u0026hellip;\n事件是抽象的想实现需要继承\n绑定监听：当事件源上发生某个事件则执行某段代码\nKeyListener - 键盘监听\nMouseListener - 鼠标监听\nActionListener - 动作监听\n先继承这些事件类然后重写抽象方法\n添加事件，当事件发生去找(this)本类中重写的方法\nthis.addKeyListener(this);\nthis.addMouseListener(this);\nthis.addActionListener(this);\nKeyListener-键盘监听 不用专门绑定事件\nActionListener-动作监听 需要去绑定某个东西实现\n弹窗\n创建一个弹窗对象\nJDialog j = new JDialog();\n把容器添加到弹窗中(容器步骤找容器那块说明)\nj.getContentPane( ).add( j );\n设置弹窗大小 - - j.setSize(344，344);\n让弹窗置顶 - - j.setAlwaysOnTop(true);\n让弹窗居中 - - j.setLocationRelativeTo(null);\n让弹窗不关闭就无法操作 - - j.setModal(true);\n让弹窗显示 - - j.setVisible(true);\n输入框\n创建一个输入框\nJTextField name = new JTextField( );\nJTextArea和JTextField基本一样JTexttArea更大还可以输入多行回车\n设置大小\nname.setBounds(x ， y ， 宽 ， 高);\n设置不可编辑\nname.setEditable(false);\n添加到界面\nthis.setContenPane.add(name);\n密码框\n同上(关键字是：JPasswordField)\n表格\n定义一个一维数组表示表格头\nObject[] tableTitle = {\u0026ldquo;aa\u0026rdquo;，\u0026ldquo;bb\u0026rdquo;，\u0026ldquo;cc\u0026rdquo;};\n定义一个二维数组表示表格内容\nObject[] tableData = {\u0026ldquo;11\u0026rdquo;，\u0026ldquo;22\u0026rdquo;，\u0026ldquo;33\u0026rdquo;}，{\u0026ldquo;44\u0026rdquo;，\u0026ldquo;55，\u0026ldquo;66\u0026rdquo;};\n创建一个表格组件\nJTable table = new JTable(tableTitle，tableData)\ntable.setBounds(x，y，width，heigh);\u0026ndash;设置大小\n创建一个滚轮框架，把表格组件添加到里面\nJScrollPane js =new JScrollPane(table)\n把滚轮框架添加到界面中\nthis.getContenPane().add(js)\n类 工具类\nScanner 类\u0026ndash;键盘录入\nScanner sc=new Scanner(System.in);\nint a=sc.nextint(); {nextdouble.next.nextLine}\nRandom 类\u0026ndash;随机数字\nRandom r=new Random();\nint a=r.nextint(随机数范围);\nMath 类\u0026ndash;包含基本执行数学运算的方法\n1：绝对值: abs 2：向上取整: ceil 3：向下取整: floor\n4：四舍五入: round 5：大值: max 小值: min\n6：a的b次幂: pow 7：随机数: random\n8：sqrt: 开平方 cbrt: 开立方\n9：int范围 (-2147483648~2147483647)\nSystem 类\n1：exit: 终止虚拟机 2：currentTimeMillis: 返回时间毫秒形式 3：arraycopy: 数组拷贝\nRuntime 类\ngetRuntime:当前系统运行的环境对象\nRuntime.getRuntime().~~~方法\n1：exit:停止虚拟机 2：availableProcesssors:获取CPU线程 3：maxMemory:JVM能从系统获取内存大小 4：titalMenory:JVM已经从系统获取内存大小 5：freeMenory:JVM剩余内存大小 6：exec:运行cmd命令\nObject 类\n如果一个类没有指定父类，默认就是继承Object类。\n所以类的父类 11和方法\ntoString:变成字符串 equals:比较 clone:克隆\ntoString:一般打印属性时重写\nequals:一般比较属性会重写\n使用clone需要重写，要javabean类实现Cloneable接口并且学要继承Cloneable标志性接口，表示可被克隆\n深克隆，浅克隆\nObjects 类\nObjects类是final修饰的类，不可继承，内部方法都是static方法，从jdk1.7开始才引入了Objects类\nequals:先非空判断 后比较对象\nisNull:判断对象是否为null，是返回true\nnonNull:和isNull结果相反\nBiginteger 大整数\n对象一旦创建，内部记录的值不能发生改变\nBiginteger(int num，Random r); 获取随机大整数\n获取指定的大整数 ， 字符串中得是整数\nBiginteger(String val); 获取指定进制大整数\nBiginteger(String val ， int 二进制/八进制/十进制/十六进制); 静态方法获取Biginteger的对象(缺点: 范围小是long的范围，内部优化把-16~16提前创建好多次获取不会创建新的)\nvalueOf(long val) 方法\n1：add 加法 2：subtract 减法\n3：multiply 乘法\n4：divide 除法 5：divideAndRemaimder 除法获取商和余数 6：equals 7：pow 次幂 8：max/min 9：intValie 转Int型\nBigDecima\n作用: 表示较大小数和解决小数运算失真的问题\n创建后内容不可变\n小数传递这种方式可能不精确，不建议使用\npublic BigDecima(double val)\n字符传递这种方式精确\npublic BigDecima(String val)\n静态对象\nvalueOf(double val)\n细节:操作数没超过double范围建议用静态操作，超过用字符构造方法\n内部优化提前创建好了0~10\n方法\n1：add 相加 2：subtract 减法 3：multiply 乘法 4：divide 除法(除法除不尽就要加上精确到几位)\n正则表达式\nstring a = \u0026ldquo;正则判读条件\u0026rdquo;\n方法\n\u0026quot; \u0026ldquo;.matches(string a); 判读是否符合\n\u0026quot; \u0026ldquo;.replaceAll(string a ， string b); 替换字符，字符串本身不发生改变\n\u0026ldquo;??\u0026quot;.split(string a); 切割字符串\n查看api文档方法是否有regex有表示可以识别正则\n注意: 一个大括号只能()匹配一个字符 两个\\表示一个表达式\n表达式\n1：[abc] 表示只能是abc 2：[^abc] 表示不能是abc 3：[a-zA-Z] 表示a到z和A到Z的范围 4：[a-z[A-Z]] 表示a-z或者A-Z 5：[a-z\u0026amp;\u0026amp;[def]] 表示交集\n6：[a-z\u0026amp;\u0026amp;[^def]] 表示a-z与非def的交集\n7：[a-z\u0026amp;\u0026amp;[^m-p]] 表示a-z和除了m到p的交集\n匹配字符\n1：. 任何字符\n2：\\d 一个数字\n3：\\D 非数字\n4：\\s 一个空白字符\n5：\\S 非空白字符\n6：\\w[a-zA-Z_0-9] 英文数字下划线 7：\\W[^\\w] 一个非单词字符\n数量词\n1：X? 一次或零次\n2：X? 零次或多次\n3：X+ 一次或多次\n4：X{n} 正好n次\n5：X{N， } 至少n次\n6：X{n，m} 至少n次但不超过m次\n符号\n1：[ ] 里内容出现一次\n2：( ) 分组\n3：^ 取反\n4：\u0026amp;\u0026amp; 交集\n5：| 或集 6：\\ 表示转义字符\n7：(?i) 忽略大小写 8：a((?i)b)c 忽略b的大小写\n爬虫\n字符的运用\nString reg = \u0026ldquo;(Java(?=8|11|17)\u0026rdquo; - - 找到匹配字符后只显示前面的不显示比较条件\n(Java(8|11|17))或(Java(?:8|11|17)) - - 显示比较条件\n(Java(?!8|11|17)) - - 找除了这些的数据\u0026rdquo;\n类\nPattern: 表示正则表达式类\nPattern p = Pattern.compile(reg)\nMatcher: 文本匹配器类，作业按照正则表达式去读取字符串\nMatcher m = p.matcher(str)\n贪婪爬取(默认) / 非贪婪爬取(在数量词后面加上问号)\n贪婪爬取\nString reg = \u0026ldquo;ab+\u0026quot;\nPattern p = Pattern.compile(reg)\nMatcher m = p.matcher(str)\n非贪婪爬取\nString reg = \u0026ldquo;ab+?\u0026quot;\nPattern p = Pattern.compile(reg)\nMatcher m = p.matcher(str)\n时间\nJDK7以前时间相关类\nDate 类\n计算机时间原点:1970年1月1号0时0分0秒\n空参构造创建对象默认表示系统当前时间\n有参构造创建对象表示指定时间\nDate d = date(); 当前时间\nDate d = date(0); 从时间原点开始过了0毫秒的时间\nd.setTime(1000L); 修改时间 1000毫秒=1秒\nd.getTime(); 获取当前时间的毫秒值\nSimpleDateFormat 类\n作用:格式化时间 解析\n构造方法: 无参/有参 (参数是日期格式)\n方法\n1：format(Date date) 格式化(日期对象-\u0026gt;字符串)\n2：parse(String source) 解析(字符串-\u0026gt;日期对象)\nCalendar 类\n代表系统当前时间的日历对象可以单独修改，获取时间中的年，月，日\n注意\n1：Calender是一个抽象类，不能直接创建\n2：用静态方法获取当前日历对象\n3：该类获取对象值是存在数组中的\npublic static Calender getInstance( )\n方法\n1：getTime 获取日期对象 2：setTime 给日历设置日期对象 3：getTimeInMillis 拿到时间毫秒值\n4：setTimeInMillis 给日历设置时间毫秒值 5：get 获取日历中某个字段信息\n6：set 修改日历的某个字段信息 7：add 为某个字段增加/减少时间值\n细节\n这个把获取的日期放在数组中月份范围是0~11(0代表1月)\n星期是从日开始的\n数组: [纪元，年，月，一年的第几周，一月的第几周，一月的第几天，\u0026hellip;\u0026hellip;]\nget方法是用数组索引获取代表的内容0~16 ， Java中定义常量替换了这些数字增加程序阅读性\nJDK8新增时间相关类\njdk8时间日期对象是不可变的，修改时间会产生一个新的时间对象\nDate 类\nZoneId:时区\n1：static getAvailableZoneIds()方法 获取Java中支持的所有时区\n2：static systemDefault()方法 获取系统默认时区\n3：static of方法 获取一个指定时区\nInstant时间戳\n1：now方法 获取当前时间的instant对象 (静态方法，直接用类名调用)\n2：ofxxx方法 根据秒/毫秒/纳秒获取instant对象 (静态方法，直接用类名调用)\n3：atZone方法 指定时区\n4：isxxx方法 判断系列的方法\n5：minusxxx方法 减少时间系列的方法\n6：plusxxx方法 增加时间系列的方法\nZoneDateTime带时区的时间\n1：now\n2：ofxxx\n3：withxxx 修改\n4：minusxxx 减少\n5：plusxxx 增加\nSimpleDateFormat 日期格式化类\nDateTimeFormatter用于时间的格式化和解析\n1：ofPattern方法 获取格式对象 (静态方法，直接用类名调用)\n2：format方法 按照指定方法格式化\nCalendar 日历类\nLocalDate:年，月，日\nLocalTime:时，分，秒\nLocalDateTime:年，月，日，时，分，秒\n方法\n1：now\n2：of\n3：getxxx 获取日历中的年|月|日|时|分|秒信息\n4：isBefore | isAfter 比较之前 | 之后\n5：withxxx 修改\n6：minusxxx 减少\n7：plusxxx 增加\n工具类\nDuration:时间间隔(天，分，秒，纳秒)\nDuration.between();第一个减第二个参数，可以用to..转成要求的天/分/秒\nPeriod时间间隔(年，月，日)\nPeriod.between();第一个减第二个参数，可以用get..获取单独的年月日\nChronoUnit时间间隔(所有单位)\nChronoUnit.xx.between();计算相差的年/月/日\u0026hellip;\n小知识\n以前的时间格林尼治时间简称GMT\n目前世界标准时间替换为原子钟简称UTC\n中国时间：世界标准时间+8小时\n包装类\nJDK5后增加了自动装箱和自动拆箱\n基本数据类型对应的对象\nchar-\u0026gt;Character int-\u0026gt;Integer 其余的首字母变大写\nInteger 为例子使用\n1：Integer i1=10;\n2：Integer i2=10;\n3：Integer i3=i1+i2;\n直接赋值即可Java底层会自动拆装箱\n四个静态方法，可以直接用类名.调用\ntoBinaryString(int i) 返回String 得到二进制\ntoOctalString(int i) 返回String 得到八进制\ntoHexString(int i) 返回String 得到十六进制\nparseInt(String s) 返回int 让字符转成整数\n八种包装类中除了Character都有对应的parsexxx方法进行转换\nparsexxx常用转化格式类型\n算法\n查找\n基本查找(顺序查找)\n普通顺序查找\n二分查找(折半查找)\n前提:数组中数据必须是有序的\n过程变量: min max mid (最小索引 最大索引 中间索引)\n插值查找(二分查找改进)\n要求数组有序且分布均匀\nmin max mid (最小索引 最大索引 中间索引)\n插值公式: mid = min+(key-arr(min))/(arr[max]-arr[min])?(max-min)\n斐波那契查找(二分查找改进)\n根据黄金分割点来计算mid位置\n黄金分割:1:0.618\nmid = min+黄金分割点左半边长度-1\n分块查找\n原则1: 前一块中最大数据小于后一块中所有数据(块内无序，块间有序)\n原则2: 块数量一般等于数字的个数开根号 例:16哥分4块\n核心思路:先确定查找的在哪块，然后在块内查找\nmax start/end (一个块的最大值 块的开始索引 块的结束索引)\n扩展(无规律数据)\nmax/min start/end (一个块的最大值 一个块的最小值 块的开始索引 块的结束索引)\n哈希查找\n扩展的分块查找\n数组划分范围查找的过程还需要添加数据\n划分范围\u0026ndash;挂载\n挂载:将同一个范围的数挂载到这个区域数组的后面\n排序\n冒泡排序\n相邻的元素两两比较，大的右边，小的左边\n选择排序\n拿0索引挨个比较依次类推\n插入排序\n索引0到n当作是有序的其余是无序的遍历无序数组放到合适位置\n快速排序\nstart/end/基准数\n规则\n1：刚开始基准数是0索引\n2：end从末尾找比基准数小的\n3：start从0开始找比基准数大的\n4：然后交换，如果start和end重合然后基准数和重合索引交换第一轮结束\n等循环结束后基准数左边都比他小，右边都比他大\n注意:如果基准数从0开始要先判断end再判断start\n需要用到递归算法\n递归算法:调用方法本身的算法\n递归需要有出口\n递归题型:爬楼梯，不死神兔，猴子吃桃\nArrays 数组操作\n操作数组的工具类\n方法\n1：toString(数组); 可以把数组拼接成字符串\n2：binarySearch(数组，元素); 二分查找法查找元素\u0026ndash;(前提是数组是升序，元素存在返回真实索引，不存在返回-插入点-1)\n3：copyOf(数组，新长度); 拷贝数组\u0026ndash;(小于数组id部分拷贝，大于补上默认值)\n4：copyOfRange(数组，起始，结束); 拷贝数组(指定范围)\u0026ndash;(包头不包尾)\n5：fill(数组，元素); 填充数组(覆盖)\n6：sort(数组); 按照默认方式进行数组排序\n7：sort(数组，规则); 按照指定规则排序\n只能给引用数据类型排序，基本数据类型需要变成其包装类\n第二个参数是一个接口可以用匿名内部类重写\n简单理解:o1-o2:升序/o2-o1:降序\n函数式编程\n是一种思想特点，忽略面向对象的复杂语法，强调做什么，而不是谁去做\nLambda表达式就是函数式编程的思想体现\nLambda表达式\n是jdk8开始后的一种新语法形式\n省略对象名称再加个 -\u0026gt;\n只能简化函数式接口匿名内部类的写法\n函数式接口: 有且仅有一个抽象方法的接口叫做函数式接口，接口上方可以加@Functionalinterface注解验证是否是函数式接口\nLambda表达式省略核心:可推导，可省略\n省略规则:\n1：参数可以省略不写\n2：如果只有一个参数，参数类型可以省略同时( )可以省略\n3：如果Lambda表达式的方法体只有一行，大括号，分号，return都可省，但要同时省略\n集合进阶-类\n集合分两大类: 单列集合Collection / 双列集合Map\n单列集合一次添加一个元素\n双列集合一次添加两个元素\n集合大家族\nCollection -\u0026gt; List / Set\nList -\u0026gt; ArrayList / LinkedLis t/ Vector(淘汰)\nList集合添加元素是有序，可重复，有索引\nSet -\u0026gt; HashSet / TreeSet\nHashSet -\u0026gt; LinkedHashSet\nSet集合添加元素是无序，不重复，无索引\nCollection单列集合\nCollection是单列集合祖宗接口，它的功能是全部单列集合都可继承使用的\n注意: Collection是一个接口\n方法\n1：add(E e) 添加\n2：clear() 清空元素\n3：remove(E e) 删除给定对象\n4：contains(Object obj) 是否包含对象 contains在底层是根据equals判断的，如果是自定义对象要重写equals方法\n5：isEmpty() 判断是否为空\n6：size() 返回集合长度\nCollection的通用遍历方式\n迭代器遍历\n迭代器不依赖索引\n迭代器在Java中的类是Iterator，迭代器是集合专用的遍历方式 Iterator x=list.iterator( )\n迭代器方法\na.hasNext(); 判断当前位置是否有元素\nb.next(); 获取当前位置元素，并将迭代器对象移向下一位置\nc.remove(); 删除\n注意:\na：当前位置没元素，用next会报错\nb：迭代器遍历完，不会复位\nc：循环中next方法只有有一个\nd：迭代器遍历是，不能用集合方法增加或者删除\n增强for遍历\n底层就是迭代器为了简化迭代器JDK5后出现的\n所有单列集合和数组才能使用增强for遍历\nfor(String s:list){\u0026hellip;}\ns只是一个第三方变量，不会改变原来的值\nLambda表达式遍历\n利用匿名内部类遍历用Lambda简化\nList集合\n继承了Collection的方法还有自己的方法\n方法\n1：add(int i，E e): 在集合指定位置插入索引\n2：remove(int i): 删除指定索引元素 调用方法时出现重载，优先调用实参和形参一致的方法\n3：set(int i，E e): 修改指定索引元素 返回被修改的元素\n4：get(int i): 返回指定索引元素\nList的遍历方式\n迭代器遍历\n和Collection一样\n列表迭代器遍历\nListIterator是Iterator的子接口\n方法: add / hasNext / next / remove\n比迭代器多了一个添加的方法\n增强for遍历\n和Collection一样\nLambda表达式遍历\n和Collection一样\n普通for循环\n利用索引循环\nArrayList集合\naddAll():一次性添加全部元素\nArrayList原理\n利用空参创建的集合在底层创建为0的数组\n添加第一个元素时，创建为10的数组\n存满时，会扩容1.5倍\n如果一次添加多个元素，1.5倍放不下，会新创建数组以实际长度为准\nLinkedList集合\n底层数据结构是双链表，查询慢，增删快\nLinkedList本身多了很多直接操作首尾元素的特有API\nSet集合\n特点\nSet特点\n无序: 存取顺序不一致\n不重复: 可以去除重复\n无索引: 没有带索引的方法，不能用普通for循环，也不能通过索引来获取元素\nSet实现类特点\nHashSet: 无序，不重复，无索引\nLinkedHashSet: 有序，不重复，无索引\nTreeSet: 可排序，不重复，无索引\nSet接口中的方法上基本与Collection的API一致\n接口方法可以去看Collection接口方法\nSet集合的 add( )方法返回值要注意，重复会返回false\nSet遍历方式\n迭代器遍历\n用hasNext( )判断是否有值\n用next( )来获取值\n增强for方式\n自动生成\nLambda表达式\nforEach( )方法来生成匿名内部类\n用Lambda表达式来简化\nHashSet集合\nHashSet底层采取了哈希表存储数据\n哈希表是一种对于增删改查数据性能都较好的结构\n哈希表组成\nJDK8前: 数组+链表\nJDK8后: 数组+链表+红黑树\n哈希表核心 -\u0026gt; 哈希值\n哈希值: 对象的整数形式\nint index = (数组长度 -1) \u0026amp; 哈希值\n哈希值\n根据hashCode方法算出来的int类型的整数\n该方法定义在Object类中，所有对象都可以调用，默认是使用地址值来计算(不建议)\n一般情况下，重写hashCode方法，利用对象内部的属性值计算哈希值\n对象的哈希值特点\n如果没有重写hashCode方法，不同对象计算出的哈希值不同(因为地址值不同)\n如果重写hashCode方法，不同对象只有属性相同，计算出的哈希值相同\n在极小概率下，不同属性或不同地址值计算出哈希值一样 (哈希碰撞)\nHashSet添加元素过程\n1：创建一个默认长度为16，默认加载因子为0.75的数组，数组名为table\n2：根据元素的哈希值根数组长度计算出应存入的位置\nint index = (数组长度 -1) \u0026amp; 哈希值\n3：判读当前是否为null，如果是null则直接存入\n4：如果不为null，则用equals方法比较属性值\n5：如果有一样的值了就不存，不一样就存进数组形成链表\nJDK8以前: 新元素存入数组，老元素挂载在新元素下面\nJDK8以后: 新元素直接挂载到老元素下面\n6：当数组存了 16?0.75 = 12 个元素时，数组会扩容成原来的两倍\n当链表长度大于8而且数组长度大于64时，当前链表会自动转成红黑树\n如果集合中存储的是自定义对象，必须重新hashCode和equals方法(否则是地址值来比较，没啥意义)\nHashSet的三个问题\nHashSet为什么存取顺序不一致?\n因为有挂载链表，会先遍历完当前链表才会去下一个地址\nHashSet为什么没有索引?\n因为HashSet底层是数组+链表+红黑树没法用索引\nHashSet是利用什么机制保证数据去重的?\nhashCode方法和equals方法\nLinkedHashSet集合\nLinkedHashSet底层原理特点\n有序，不重复，无索引\n这里有序是指保证存储和取出的元素顺序一致\n原理: 底层结构依然是哈希表，不过每个元素额外多了一个双链表的机制记录存储的顺序\n总结\n1：如果要数据去重默认使用HashSet\n2：如果要求去重还有存取有序才使用LinkedHashSet\nTreeSet集合\nTreeSet\u0026lt;\u0026hellip;\u0026gt; ts = new TreeSet \u0026lt;\u0026gt;( );\nTreeSet的底层原理特点\n不重复，无索引，可排序\n可排序: 按照元素的默认规则(由小到大)排序\nTreeSet集合底层是基于红黑树的数据结构实现排序的，增删改查性能都较好\n遍历方式\n迭代器\nIterator it = ts.iterator( ); 创建一个迭代器对象 it.hasNext(); 判读是否有元素\nit.next(); 获取当前元素，然后自动指向下一个元素位置\n增强for\nfor(int t : ts){\u0026hellip;}\nlambda表达式\nts.forEach(new Consumer(){\u0026hellip;}) 生成匿名内部类\nts.forEach(i -\u0026gt; System.out.println(i)); lambda简化匿名内部类\nTreeSet集合默认的规则\n对于数值类型: Integer Double \u0026hellip; 默认按照从小到大的顺序排序\n对于字符 字符串类型: 按照字符在ASCLL码表中的数字升序进行排序\nTreeSet的两种比较方式\n使用原则: 默认是使用第一种，如果第一种不能满足当前需求，就使用第二种\n当方式一和方式二重复时，以方式二为准\n默认排序/自然排序: javabean类实现Comparable接口指定比较规则\n重写方法，然后在方法里面写排序规则 (红黑树的添加规则)\n比较器排序: 在创建TreeSet对象的时候，在小括号里面传递比较器Comparator指定规则\nComparator是一个接口用匿名内部类创建\no1: 表示当前添加的元素\no2: 表示当前在红黑树存在的元素\n返回规则和之前一样\n如果一样就根据什么排序: 用三元运算符来判断\n方法返回值特点\n1：负数: 表示当前添加的元素是小的，存左边\n2：正数: 表示当前添加的元素是大的，存右边\n3：0: 表示当前添加的元素已经存在，舍弃\n单列集合小结\n如果想要集合中的元素可重复\n用ArrayList集合，基于数组的 (用的最多)\n如果想要集合中的元素可重复，而且当前的增删操作明显多于查询\n用LinkedList集合，基于链表的\n如果想对集合中的元素去重\n用HashSet集合，基于哈希表(用的最多)\n如果对集合中的元素去重，而且要保证存取顺序\n用LinkedHashSet集合，基于哈希表和双链表，效率低于HashSet\n如果想对集合中的元素进行排序\n用TreeSet集合，基于红黑树.后续也可以用List集合实现排序\nMap双列集合\n双列集合特点\n双列集合一次需要添加一对数据，分别为键和值\n键不能重复，值可以重复\n键和值是一一对应的，每一个键只能找到自己的值\n键+值这个整体我们称为 \u0026ldquo;键值对\u0026rdquo; 或者 \u0026ldquo;键值对对象\u0026rdquo; ，在Java中叫做 \u0026ldquo;Entry对象\u0026rdquo;\nMap的常见API\nMap是双层集合的顶层接口，它的功能是全部双列集合都可以继承使用的\n方法\n1：put(k key，v value): 添加元素\n添加对象是如果存在了，就会覆盖原来的对象，然后返回被覆盖的值\n2：remove(object key): 根据键删除元素\n3：void clear( ): 移除所有元素\n4：boolean containsKey(object key): 判断集合是否包含指定的键\n5：boolean containsValue(object value): 判断集合是否包含指定的值\n6：boolean isEmpty(): 判断集合是否为空\n7：int size(): 集合的长度，也就是集合中键值的个数\nMap的遍历方式\n键找值\nSet keys = map.keySet(); 先获得所有的键，存储到单列集合中\nfor(String key : keys){\u0026hellip;}; 再循环遍历\n(还可以用迭代器和lambda表达式)\n利用map集合中的键获取对应的值 get\nString value = map.get(key) 写在大括号里面\n依次获取键对应的值\n键值对\n用entrySet来获取所有的键值对\nSet\u0026lt;Entry\u0026lt;String， String\u0026raquo; strs = map.entrySet();\n获取所有的键值对，可以用getKey() / getValue()获取对应的元素\n如何可以用循环遍历依次获取每个\nLambda表达式\n就是利用第二章方式，依次得到每个值，然后调用accept方法\nHashMap集合\n是Map中比较常用的，没有新的方法用Map的方法就行\nHashMap的特点\nHashMap是Map的实现类\n没有额外的特有方法，直接使用Map的方法就行\n特点是由键决定的: 无序，不重复，无索引\nHashMap根HashSet底层原理一样，都是哈希表结构\n依赖HashCode和equals方法保证键的唯一(值无所谓)\n根据键来计算哈希值存储数组\n如果当前数组元素和要存储元素一样会覆盖\nHashMap的键位置如果是自定义对象，要重写HashCode和equals方法\nLinkedHashMap集合\n特点\n由键决定: 有序，不重复，无索引\n这里的有序是指的是保证存储和取出的顺序一致\n不重复是保证数据唯一，如果有重复的也是会覆盖\n原理: 底层数据结构依然是哈希表，只是每个键值对元素又额外的多了一个双链表的机制存储的顺序\nTreeMap集合\nTreeMap跟TreeSet底层原理一样，都是红黑树结构的\n由键决定特性: 不重复，无索引，可排序\n可排序: 对键进行排序\n注意: 默认按照键的从小到大进行排序，也可以自己规定键的排序规则\n代码书写两种排序规则\n实现Comparable接口，指定规则\n创建集合时传递Comparator比较器对象，指定比较规则\n如果两个都有按照Comparator为准\n之前的set中有排序规则的详情\n源码分析\n1：ctrl+B: 追踪源码分析 ; ctrl+F12: 查看所有的方法和类\n2：图标是C的表示是类，图标是M的表示都是方法\n3：方法名和类目一样表示的是构造方法，其余是成员方法\n4：格式:图标·方法名(形参): 返回值\n5：↑箭头表示重写的父类或者接口中的发放\n6：→箭头表示当前的方法继承了别的方法或者类\n7：F图标表示的是使用过的变量或者常量\n8：I图标表示是接口\n9：最后C图标小还有C图标，是内部类\n10：JAVA起飞课程下半部 14，15，16，17 集\n集合进阶-泛型\n泛型：jdk5中引用的特性，可以在编译阶段约束操作的数据类型，并检查\n泛型格式：\u0026lt;数据类型\u0026gt;\n注意：泛型只支持引用数据类型(包装类)\n扩展：Java中的泛型是伪泛型\n细节：不写泛型默认是Object，指定类型后传递数据时可传入其子类型\n泛型类\n当一个类中，某个变量类型不确定，就可以定义带有泛型的类\n格式：修饰符 class 类名 {..}\n泛型方法\n某个方法变量不确定可以在方法上定义泛型\n区别：类泛型所有方法都可用，方法泛型只有本方法可用\n格式：修饰符 void 名 (E e) {..}\n泛型接口\n格式: 修饰符 interface 名 {..}\n使用的两种不同的方式\n1：实现类给出具体类型\n2：实现类延续泛型，创建对象时再确定\n泛型的继承与通配符\n泛型不具备继承性但数据具备继承性\n🔣：泛型定义时是父类就没法使用其子类创建\n🔣：但是里面的元素/参数和以前一样不耽误使用\n解决方案 通配符 ?\n🔣：? extends E: 表示可以传递E或者E的所有子类\n🔣：? super E: 表示可以传递E或者E的所有父类\nCollections工具类 java.util.Collections:是集合工具类\n作用: collections不是集合，是集合工具类\n常见API\npublic static boolean addAll(Collection c，T\u0026hellip;elements): 批量添加元素\npublic static void shuffle(List\u003c?\u003e list): 打乱list集合元素的顺序\n\u0026hellip;sort(List list) 排序 / \u0026hellip;sort(List list，Comparator c) 根据指定规则排序\nbinarySearch(List list，T key) 二分查找排序\nfill(List list，T obj) 指定元素填充集合\nswap(List\u003c?\u003e list ，int i，int j) 交换集合中指定位置元素\ncopy max min clear\n可变参数/不可变参数\n可变参数\n方法形参的个数是可变化的\n格式： 在方法形参中写 (数据类型\u0026hellip;名)\n在方法的形参中我们最多只写一个可变参数\n在方法形参中除了可变参数还有别的参数，可变参数要写在最后\n可变参数本质就是一个数组\n不可变参数\n注意：这个集合不可添加，不可修改，不可删除\n创建不可变List集合\nList list = List.of(\u0026rdquo;??\u0026quot;，\u0026rdquo;??\u0026quot;，\u0026rdquo;??\u0026rdquo;);\n创建不可变Set集合\nSet set = Set.of(\u0026rdquo;??\u0026quot;，\u0026quot;??\u0026quot;，\u0026quot;??\u0026quot;);\n细节：当我们创建一个不可变Set集合时，里面参数一定要保证唯一性\n创建Map的不可变集合\nMap\u0026lt;String，String\u0026gt; map = Map.of(\u0026quot;??\u0026quot;，\u0026quot;??\u0026quot;，\u0026quot;??\u0026quot;，\u0026quot;??\u0026quot;);\nMap会自动识别两个为一个键值对\n细节1：建立Map时参数中键是不可重复的\n细节2：Map建立时的参数是有限的，最多20个，十个键值对\n细节3：如果参数大于20个就使用ofEntries方法(需要先转成数组)\n细节4：细节3白学，JDK10出现了copyOf方法直接底层判断更省事\n总结\n1：定义完成后不可修改，添加，删除\n2：List，Set，Map 接口中，都存在 of 方法可以创建不可变集合\n3：List\u0026ndash;直接用 Set\u0026ndash;元素不可重复 Map\u0026ndash;元素不可重复，数量限制\nStream流\n作用：stream就是结合Lambda表达式，简化集合数组的操作\n补充1：startsWith() 方法用于检测字符串是否以指定的前缀开始\n补充2：endsWith() 方法用于检测字符串是否以指定字符结束\n格式：list.stream().filter(name -\u0026gt; name.startsWith(\u0026quot;?\u0026quot;).filter(\u0026hellip;\u0026hellip;).forEach(name -\u0026gt; system.tou\u0026hellip;.))\nfilter：筛选条件 forEach循环输出\n例子：\n1 2 3 4 5 6 ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;aaa\u0026#34;); list.add(\u0026#34;bbb\u0026#34;); list.add(\u0026#34;ccc\u0026#34;); list.add(\u0026#34;ddd\u0026#34;); list.stream().filter(name-\u0026gt;name.startsWith(\u0026#34;a\u0026#34;)).filter(name-\u0026gt;name.length()==3).forEach(name-\u0026gt; System.out.println(name)); Stream流的思想： 类似于流水线，一层层筛选\nStream流的作用： 结合了Lambda表达式，简化集合，数组的操作\nStream流的步骤\n先得到一条Stream流(流水线)，并把数据放到流水线上\n双列集合使用Steam流需要用keySet()或者entrySet()转成单列，再使用\n数组\n1 2 int[] a = {1，2，3，1，2，3}; Arrays.stream(a).forEach(s-\u0026gt; System.out.println(s)); 零散数据\na：该方法是一个可变参数，可传零散数据也可传数组，\nb：但是数组必须是引用数据类型，如果是基本数据类型，会把数组当成一个数据放进去\n1 Java Stream.of(\u0026#34;1\u0026#34;，\u0026#34;6\u0026#34;，\u0026#34;4\u0026#34;，\u0026#34;2\u0026#34;).forEach(s -\u0026gt; System.out.println(s)); 使用中间方法对流水线上的数据进行操作\nStream流的中间方法\na：filter() 过滤\nb：limit() 获取前几个元素\nc：skip() 跳过前几个元素\nd：distinct() 元素去重，(依赖hashCode和equals方法)\ne：concat(??，??.foE\u0026hellip;) 合并a和b两个为一个流\nf：map(s -\u0026gt; \u0026hellip;..) 转换流中的数据 用parse\u0026hellip;来进行转换\n注意1：返回新的Stream流，原来的Stream流只能使用一次，建议使用链式编程\n注意2：修改Stream中的数据，不会影响原来集合或者数组中的内容\n使用终结方法对流水线上的数据进行操作\nStream流的终结方法\na：forEach() 遍历\nb：count() 统计\nc：toArray(value-\u0026gt;new String[value]) 收集流中的数据，放到数组中\n(1)toArray方法的参数作用：负责创建一个指定数组\n(2)toArray方法的底层：会依次得到流里每个数据，然后放到数组中\n(3)toArray方法的返回值：是一个装着流里面所有数据的数组\nd：collect() 收集流中的数据，放到集合中\n(1)收集到List中：括号里用Collectors.toList()方法来转换\n(2)收集到Set中：括号里用Collectors.toSet()方法来转换\n(3)收集到Set中是会自动去除重复的元素\n(4)收集到Map中：括号里用Collectors.toMap()方法来转换\n(5)toMap方法有参数一表示键和参数二表示值\n(6)参数中：Function泛型一:表示流中每个数据类型;泛型二表示Map集合中值的数据类型\n(7)参数中方法apply:形参:依次表示流中每个数据\\方法体:生成键|值的代码\\返回值:已经生成的键|值\n(8)简略书写 (s-\u0026gt;s.spl\u0026hellip;.，s-\u0026gt;s.int\u0026hellip;)\n(9)注意点:收集到Map集合中时，键不能重复\n中间方法: 方法调用完毕后还可以调用其他方法(过滤，转换)\n终结方法: 方法调用完毕后无法调用其他方法(统计，打印)\nStream流的输出一般用.forEach(s-\u0026gt;sout(s))\n方法引用\n解释: 把已经有的方法拿过来用，当做函数式接口中抽象方法的方法体\n要求\n1：引用处原本方法必须是函数式接口\n2：被引用的方法必须已经存在\n3：被引用方法的形参和返回值需要跟抽象方法(原本的方法)保持一致\n4：被引用方法的功能要满足当前需求\n:: 是什么符号 \u0026mdash; 方法引用符\n分类\n1：引用静态方法\n格式: 类名::静态方法\n2：引用成员方法\n格式: 对象::成员方法\na：引用其 他类的成员方法 其他类对象::方法名\nb：引用本类的成员方法 this::方法名(非静态，静态没有this对象，静态只能先创建本类对象再引用)\nc：引用父类的成员方法 super::方法名\n3：引用构造方法\n格式：类名::new\n自定义的类要注意里面的方法要和抽象方法的形参一致，不一致就新键个方法\n4：其他调用方式\na：使用类名引用成员方法 格式: 类名::成员方法\n规则: 需要有函数是接口\n被引用方法存在，被引用方法的形参需要根抽象方法的第二个形参到最后一个形参保持一致，返回值也要保持一致\n详解:\n第一个参数决定了可以引用那些类中的方法\n第二个参数到最后一个参数需要和引用方法的形参保持一致，如果没有第二个参数就说明引用的方法需要是一个无参的方法\n局限性:\n不能引用所有类中的方法\nb.引用数组的构造方法\n格式: 数据类型[]::new\n细节:数组的类型需要和流中的数据类型一致\n异常\nthrow：抛出 system.err.println(..): 输出红色信息\n总结\n异常是什么： 程序中可能出现的问题\n异常体系最上层父类谁： Exception\n异常分两类： 编译时异常和运行时异常\n编译时异常： 没有继承RuntimeExcpetion的异常，直接继承Excpetion.编译阶段就会提示错误\n运行时异常： RuntimeException本身和子类.编译时没有错误提示，运行时会出现\n编译时异常主要在提示程序员检查本地环境错误\n运行时异常就是代码错误\n异常的作用\n一: 异常是用来查询bug的关键参考信息\n二: 异常可以作为方法内部的一种特殊返回值，以便通知调用者底层的执行情况\n异常的处理方式\nJVM默认的处理方式\n把异常的名称，原因及异常出现的位置等信息输出在控制台\n程序停止执行，异常下面的代码也不会执行了\n自己处理(捕获异常)\n格式: try{\u0026hellip;}catch(\u0026hellip; e){\u0026hellip;}\n目的: 当代码出现异常时，可以让程序继续执行下去\ntry中遇到多个错误可以写多个catch与之对应\ntry中遇到第一个错误会直接去找catch，下面不会执行，但解决后再次运行可能会再出别的错误，所有要写多个catch\n如果try中的问题没有被捕获(catch中没有)最终还是会交给虚拟机处理\n细节:如果我们捕获多个异常，这些异常中如果存在父子关系，父类一定要在最下面\n了解:JKD7后，就可以才catch中同时捕获多个异常用|分隔开就行表示或\nThrowable的成员方法\ne就表示调用的Throwable的printStackTrace方法\npublic String getMessage() | 返回此throwable的详细消息字符串(了解)\npublic String toString() | 返回此可抛出的简短描述(了解)\npublic void printStackTrace() | 把异常的错误信息输出在控制台\nprintStackTrace包含了前两个的提示信息，同时printStackTrace仅仅是打印不会停止程序\n抛出处理\nthrows: 写在方法的定义处，表示声明一个异常 告诉调用者，使用本方法可能会出现一些异常\nthrow: 写在方法内，结束方法 手动抛出异常对象，交给调用者，方法中下面的代码就不再执行了\n自定义异常\n定义异常类\n写继承关系\n空参构造\n带参构造\nFile\nFile对象就表示一个路径，可以是文件的路劲，也可以是文件夹的路径\n这个路径可以是存在的，也可以是不存在的\n只能对文件本身进行操作，不能读写文件里面存储的数据\n构造方法\npubli File(String pathname) \u0026mdash; 根据文件路径创建文件对象\npubli File(String parent，String child) \u0026ndash; 根据父路径名字符串和子路径名字符串创建对象\npubli File(String parent，String child) \u0026ndash; 根据父路径对应文件对象和子路径名字符串创建对象\n方法\n判断类型方法\nisDirectory() 判断此路径名是否表示File为文件夹\nisFile() 判断此路径名是否表示File为文件\nexists() 判断此路径名表示的File是否存在\n获取类型方法\nlength() 返回文件的大小(单位:字节)\ngetAbsolutePath() 返回文件绝对路径\ngetPath() 返回定义文件时使用的路径\ngetName() 返回文件或者文件夹的名称，带后缀\nlastModified() 返回文件最后的修改时间\n创建和删除方法\ncreateNewFile() 创建一个新的空文件\n如果文件不存在就创建返回true否则返回false如果路径不存在就报错.\n如果没有写后缀就会创建一个无后缀的文件\nmkdir() 创建单级文件夹\nmkdirs() 创建多级文件夹\ndelete() 删除文件，空文件夹(不走回收站)\n获取并遍历方法\nlistFiles() 获取当前路径下所有内容\n路径不存在或者是文件或者路径需要权限都是返回null\n空文件返回为0的数组\n有内容会返回到file数组中，包括隐藏文件夹\nIO流\n存储和读取数据的解决方案\nI： input　O：output　流：像水流一样传输数据\nIO流的分类\n流的方向分为: 输入流和输出流\n操作文件类型分为: 字节流和字符流(字节流可操作所有文件，字符流只能操作纯文本文件)\nIO流的作用\n用于读写数据(本地文件，网络)\nIO流的体系\n字节流: InputStream(字节输入流) OutputStream(字节输出流)\n字符流: Reader(字符输入流) Writer(字符输出流)\n都是抽象类，要使用还得看子类\n字节流 FileOutputStream写数据的3种方式\n1：write(int b) 一次写一个字节数据\n2：write(byte[] b) 一次写一个字节数组数据\n3：write(byte[] b，int off，int len) 一次写一个字节数组的部分数据\n字节流输出细节\n1.创建字节输出流对象\n参数是字符串表示的路径或者是File对象都可以\n如果文件不存在会创建一个新的文件，但要保证父级路劲是存在的\n如果文件存在，默认会清空文件\n但是创建时，传递true当第二个参数可以打开续写功能\n2.写数据\nwrite方法的参数是整数，但实际写到里面的是根据ASCII码来转换的\n可以先定义字符串然后用getBytes()方法来变成字节数组\n如果要换行就定义一个字符串\u0026quot;\\r\\n\u0026quot;输出就行\n3.释放资源\n每次使用完流后都要释放资源\nFileInputStream读数据的方法\npublic int read() 一次读取一个字节\npublic int read(byte[] buffer) 一次读取一个字节数组数据\n注意: 一次读一个字节数据的数据，每次读取会尽可能把数组装满\n字节流输入细节\n1.创建对象\n格式: FileInputStream fis = new FileInputStream(\u0026quot;..\\.\\.\u0026quot;);\n如果文件不存在就会直接报错\n2.读取数据\n一次读取一个字节，读取的是数据对应的ASCII码上的数字\n读到文件末尾了read方法返回-1\n如果是字节数组读取每次读取会覆盖上次数据\n数据不够全部覆盖就会覆盖部分，残余数据不变\n例子:\n1 2 byte[] bytes = new byte[1024?1024?5]; int len=fis.read(bytes)//(返回读取字节数) 3.释放资源\n每次使用完流后都要释放资源\n释放规则:先开的最后关闭\ntry\u0026hellip;catch异常处理\n可能会导致没法释放资源，但是用finally{..}可以\nfinally{..}里的语句一定会执行，除非虚拟机停止\n字符流\n字符流底层就是字节流\n字符流=字节流+字符集\n特点: 一次读一个字节，遇到中文时，一次读多个字节\n使用场景: 对于纯文本进行读写操作\nFileReader字符输入\n1.创建字符输入流对象\npublic FileReader(File file) public FileReader(String pathname)\n细节: 如果文件不存在直接报错 2.读取数据\npublic int read() \u0026ndash; 读取数据，末尾返回-1\npublic int read(char[] buffer) \u0026ndash; 读取多个数据，末尾返回-1\n细节: 按字节读取，遇到中文，一次读多个字节，读取后解码\n细节: 空参是读取字节-\u0026gt;转十进制 有参多了一步强转\n3.释放资源\npublic int close()\nFileWriter字符输出\n1.创建字符输出流对象\npublic FileWriter(File file/String pathname)\npublic FileWriter(\u0026hellip;，boolean append) 续写开关\n细节: 参数是字符串还是File都可以\n细节: 如果不存在会创建一个，但要保证父级路劲存在\n细节: 如果存在会清空，不想清空就要打开续写开关\n2.输出方法\nvoid write(int c/String str/char[] chs)\nvoid write(String str，int off，int len) 写字符串一部分\nvoid write(char[] chs，int off，int len)写字符数组一部分\n细节: 如果write方法参数是整数，实际写的数据是字符集对于的字符\n3.释放资源\n字符流原理解析\n1.创建字符输入/输出流对象\n底层: 关联文件，并创建缓存区(长度:8192的字节数组)，字节流没有缓存区\n2.读取数据\n输入流底层:\n(1)判断缓存区是否有数据可以被读取\n(2)没有数据，就区文件中获取，尽可能装满缓冲区，文件也没有就返回-1\n(3)有数据就从缓冲区中读取数据\n(4)缓冲区读取文件会从头开始覆盖缓冲区内容\n空参的read方法:一次读取一个字节，遇到中文一次读取多个字节把字节解码且转成十进制返回\n有参的read方法:读取字节，解码，强转三步合并了，强转后的字符放到数组中\n输出流底层:\n(1)把要输出的对象存到缓存区，用flush或者close从缓存区输出到文件\n(2)缓冲区满了也会自动输出到文件\n(3)手动刷新\u0026ndash;flush 关闭资源\u0026ndash;close (4)BOM头\n高级流\nFileInputStream \u0026ndash; FileOutputStream FileReader \u0026ndash; FileWriter 都属于基本流\n创建带缓冲区的流是高级流\nBufferedInputStream \u0026ndash; BufferedOutputStream BufferedReader \u0026ndash; BufferedWriter\n字节缓冲流\n原理:底层自带了长度为8192的缓冲区提高性能\n构造方法\npublic BufferedInputStream(InputStream is)\npublic BufferedOutputStream(OutputStream os)\n把基本流包装成高级流，提高读取/写出数据的性能\n输入和输出分别创建两个缓冲区，节约了去硬盘找数据的时间\n例: BufferedInputStream buf = new BufferedInputStream(new FileInputStream(\u0026hellip;.));\n字符缓冲流\n有独有的方法\npublic String readLine() 输入的方法，读取一行数据，没有返回null\npublic void newLine() 跨平台换行\npublic void flush() 刷新\n缓存流自带8192的缓存区，字节流是8192个字节，字符是8192个字符\n建议:IO流随用随键，因为IO建立流会清空文件\n转换流\n属于字符流，本身也是一种高级流\n是字符流和字节流之间的桥梁\nInputStreamReader\u0026ndash;转换输入流 OutputStreamWriter\u0026ndash;转换输出流\n作用1:指定编码格式读取/输出文件(11版本淘汰了)\n作用2:字节流想要使用字符流中的方法\n例: 利用转换流指定字符编码读取\nFileReader fr = new FileReader(\u0026quot;\u0026hellip;\u0026quot;，Charset.forName(\u0026ldquo;GBK\u0026rdquo;));\n将文件内容按照GBK编码格式读取出来\n序列化流/对象操作输出流\nObjectInpoutStream\u0026ndash;反序列化流 ObjectOutputStream\u0026ndash;序列化流\n构造方法\npublic ObjectOutputStream(OutputStream out)\u0026ndash;把基本流包装成高级流\n成员方法\npublic final void writeObject(Object obj)\u0026ndash;把对象序列化写到文本中去\n小细节\n使用对象输出流将对象保存到文件时会出现NotSerializ\u0026hellip;\u0026hellip;异常\n解决方案: 需要让javabean类实现Seriailzable接口\n反序列化流/对象操作输入流\n构造方法\npublic ObjectInputStream(InputStream out)\u0026ndash;把基本流变成高级流\n成员方法\npublic Object readObject()\u0026ndash;把序列化到文件中的对象读取到程序中\n小细节\n序列化到文件后修改JavaBean再反序列化会报错，版本号不一致\n解决方案: 直接手打private static final long seriaLVersionUID=1L;\n在Settings中搜索Serializable，勾选两个，然后类名提示自动生成UID\ntransient:瞬态关键字\u0026ndash;不会把当前属性序列到本地文件中\n如果要序列化多个对象，一般先添加到集合在序列化到文件，这样读取就直接转成集合就行，方便循环读取\n打印流\n打印流不能读只能写\n分类: PrintStream\u0026ndash;字节打印流 PrintWriter\u0026ndash;字符打印流\n特点1: 打印流只操作文件目的地，不操作数据源\n特点2: 特有的写出方法可以实现，数据原样输出\n例 打印 97 文件中 97\n特点3: 特有的写出方法，可以实现自动刷新，自动换行\n打印一次数据 = 写出+换行+刷新\n字节打印流\n构造方法\n(1)public PrintStream(OutputStream/File/String)\u0026ndash;关联字节输出流/文件/文件路径\n(2)public PrintStream(String fileName，Charset charset)\u0026ndash;指定字符编码\n(3)字节流底层没有缓存区，开不开自动刷新没有区别，那俩方法没写\n成员方法\n(1)write(int b)\u0026ndash;常规方法，规则和之前一样，将指定字节输出\n(2)println(Xxx xx)\u0026ndash;特有方法，打印任意数据，自动刷新，自动换行\n(3)print(Xxx xx)\u0026ndash;特有方法，打印任意数据，不换行\n(4)printf(String format，object\u0026hellip; args)\u0026ndash;特有方法，带有占符位的打印数据，不换行\n字符打印流\n构造方法\n(1)public PrintWriter(Write/File/String)\u0026ndash;关联字符输出流/文件/文件路径\n(2)public PrintWriter(String fileName，Charset charset)\u0026ndash;指定字符编码\n(3)public PrintWriter(Write w，boolean autoFlush)\u0026ndash;自动刷新\n(4)public PrintWriter(OutputStream out，boolean autoFlush，Charset charset)\u0026ndash;指定字符编码且自动刷新\n(5)字符打印流底层有缓存区，想要自动刷新需要开启\n成员方法\n和字节成员方法基本一样\n解压缩流/压缩流\nZipInputStream\u0026ndash;解压缩流 ZipOutputStream\u0026ndash;压缩流\n解压缩流\n解压本质: 把每个ZipEntry按照层级拷贝到本地另一个文件夹中\ngetNextEntry(): 获取压缩包里面的文件或文件夹，没有数据会返回null\nread(): 获取文件的字节流\n压缩流\nZipEntry entry = new ZipEntry(\u0026quot;\u0026hellip;txt\u0026quot;): 创建ZipEntry对象\nputNextEntry(entry): 建立压缩包里面的压缩文件或者目录\n压缩包结构搭建好了，再把文件里面的内容用文件输出流传到压缩包中\nwrite(): 输出到文件里面\nCommons-io\nCommons-io是apache开源基金组织提供的一组有关IO操作的开源工具包\n作用: 提高IO流的开发效率\n有前面IO流的大部分内容，经典白学\nHutool工具包\n中国人发明的工具包\n读取文件内容\nFileUtil.readUtf8Lines(\u0026ldquo;文件地址\u0026rdquo;)\n写入到文件中\nFileUtil.writeLines(user，\u0026ldquo;文件地址\u0026rdquo;，\u0026ldquo;编码格式\u0026rdquo;)\n注册和登录用户的编码核心思想\n权重\n用数组添加0和1来实现权重(适用于小数据)\n计算权重的方法\n先提前在每个对象后面写好权重数字\n然后用字符流传到内存中\n定义一个类好管理对象里面每一个数据(主要是权重变量)\n然后把所有权重相加，把每个权重除以总权重，得出每个变量的权重范围\n后一个权重的范围是前一个权重数加上本身权重数\n然后就可以随机一个小数，去找这个数属于哪个权重范围(二分查找)\n会返回一个数然后就可以用数组去获取这个数对应的索引的信息\n然后就可以把权重数修改，然后返回给类对象\n然后建立字符流保存到文件中\n配置文件\nXML ini properties YAML\nproperties是一个双列集合，拥有Map集合的所有特点\n重点: 有一些特有方法，可以把集合中的数据按照键值对的形式写到或者读取到配置文件中\n创建properties时没有泛型类，所有properties可以添加任何数据，但是一般只添加字符串\nproperties和IO流结合的特有方法\nProperties prop = new Properties();\nprop.put(\u0026quot;..\u0026quot;，\u0026quot;..\u0026quot;)\u0026ndash;直接往文件里面写双列集合数据\nprop.store(file，\u0026quot;\u0026hellip;.\u0026quot;)\u0026ndash;直接往文件里面写注释\nprop.load(file)\u0026ndash;直接读取文件内容(只能读取双列集合的数据)\n乱码问题\n计算机存储规则\nGB2321字符集:1980年发布只有简体\nBIG5字符集:台湾地区繁体中文字符集\nGBK字符集:2000年3月17日发布，有简体，繁体和日韩汉字\nwindows系统默认使用GBK.系统显示ANSI\nUnicode字符集:国际标准字符集，世界各种语言定义一个唯一编码\n在计算机中任意数据都是二进制存储\n最小存储单位是字节\nGBK(汉字)\n完全兼容ASCII码\n规则1：汉字两个字节存储\n规则2：汉字高位字节二进制一定以1开头，转成十进制后是一个负数\n规则3：英文一个字节存储，兼容ASCII码，二进制前面补0，所有首位一定是0\nUnicode:万国码\n开始UTF-16:用24字节保存\n然后UTF-32:固定用4个字节\n最后UTF-8:用14字节保存\nUTF-8规则\nASCII:1个字节 0xxxxxxx\n简体中文: 3个字节 1110xxxx 10xxxxxx 10xxxxxx\nx是用对应的二进制去挨个填补\nUTF-8是字符集的一种编码方式\n乱码\n原因1: 读取数据时未读取完整个汉字\n原因2: 编码和解码的方式不统一\n编码\npublic byte[] getBytes() \u0026ndash; 默认方式\npublic byte[] getBytes(String charsetName) \u0026ndash; 指定方式\n解码\nString(byte[] bytes) \u0026ndash; 默认方式\nString(byte[] bytes，String charsetName) \u0026ndash; 指定方式\n多线程\n线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位\n进程: 进程是程序的基本执行实体\n简单理解: 应用软件中互相独立，可以同时运行的功能\n多线程内容讲解图:\n并发和并行\n并发:在同一个时刻，有多个指令在CPU上交替进行\n并行:在同一个时刻，有多个指令在多个CPU上同时执行\n实现方法\n继承Thread类的方式进行实现\n实现Runnable接口的方式进行实现\n利用Callable接口和Future接口方式实现\nThread实现方法\n用extends继承Thread，然后重写run方法\npublic class MyThread extends Thread{ \u0026hellip;run(){}}\n然后再测试类中创建实现Thread的类，然后调用start方法开启线程\nMyThread ts = new MyThread();\nts.setName(\u0026quot;..\u0026quot;)\u0026ndash;可以给run传数据，run里面调用getName可以获取数据\nts.start();\nRunnable实现方法\n用implements实现Runnable接口，然后重写里面的run方法\npublic class MyRunnable implements{\u0026hellip;run(){}}\n创建MyRunnable类对象，然后创建线程对象，用线程对象才可以开启线程\nMyRunnable my = new MyRunnable();\nThread tr = new Thread(my);\ntr.start();\n在Runnable的run中没法直接用getName获取内容\n先用Thread t = Thread.currenrThread();获取当前线程对象\n然后用t.getName()来获取setName(\u0026quot;\u0026hellip;\u0026quot;)中的内容\nCallable接口和Future接口实现方法\n创建一个MyCallable实现Callable接口，然后重写call方法(有返回值)\npublic class MyCallable implements Callable\u0026lt;泛型\u0026gt;{\u0026hellip;call()..}\n创建一个MyCallable类对象表示多线程要执行的任务，创建FutureTask的对象管理多线程运行的结果\nMyCallable mc = new MyCallable();\nFutureTask ft = new FutureTask\u0026lt;\u0026gt;(mc);\n创建Thread类对象，开启多线程\nThread t = new Thread(ft);\nt.start();\n然后调用FutureTask的实例对象的get()方法就可以获取返回值\nft.get();\n成员方法\nString getName()\u0026ndash;返回此线程的名称\nvoid setName(String name)\u0026ndash;设置线程的名字(构造方法也可以)\nstatic Thread currentThread()\u0026ndash;获取当前线程的对象\nstatic void sleep(long time)\u0026ndash;让线程休眠指定时间(毫秒)\nsetPriority(int newPriority)\u0026ndash;设置线程优先级(默认5)\nfinal int getPriority()\u0026ndash;获取线程优先级(不是绝对的，只是概率增加)\nfinal void setDaemon(boolean on)\u0026ndash;设置为守护线程(备胎)\npoublic static void yield()\u0026ndash;礼让线程(了解)\npublic static void join()\u0026ndash;插队线程(了解)\n守护线程:非守护线程结束后，守护线程会执行一点然后结束，不一定会执行到底\n生命周期:新建-\u0026gt;就绪(抢CPU执行权)-\u0026gt;运行代码-\u0026gt;结束线程\n中间遇到sleep()或者其他阻塞代码后会回到就绪状态\n线程锁(同步代码块)\n把操作共享数据的代码锁起来\n格式: synchronized(锁){\u0026hellip;}\n特点: 锁默认打开，有一个线程进去了，锁自动关闭:里面代码全部执行完毕，线程出来，锁自动打开\n要求: 锁对应可以是任意数据，但必须要唯一，可以用static来定义数据保证数据唯一性\n同步方法\n就是把synchronized关键字添加到方法上面\n格式: 修饰符 synchronized 返回值类型 方法名(参数){\u0026hellip;}\n特点1: 同步方法是锁住方法里面所有的代码\n特点2: 锁对象不能自己指定 非静态\u0026ndash;this 静态\u0026ndash;当前类的字节码文件对象\n细节: StringBuilder和StringBuffer方法基本一样，但是StringBuilder用于多线程是不安全的\nLock锁\n为了更加清晰的表达如何加锁和释放锁，JDK5后提高了一个Lock锁\nvoid lock()\u0026ndash;获得锁\nvoid unlock()\u0026ndash;释放锁\nLock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化\nstatic Lock lock = new ReentrantLock();\n加static是因为可能会创建多个实例化对象，但是锁要共享的\n死锁\n是个错误的，一个bug\n锁嵌套就容易造成死锁\n生产者和消费者(等待唤醒机制)\n消费者步骤\n1.判断桌子上是否有食物\n2.如果没有就等待\n3.如果有就开吃\n4.吃完后唤醒生产者继续做\n生产者步骤\n1.判断桌子上是否有食物\n2.有就等待\n3.没有就做食物\n4.把食物放到桌子上\n5.叫醒等待者开吃\n第一种实现方法\nvoid wait()\u0026ndash;当前线程等待，直到被其他线程唤醒\nvoid notify()\u0026ndash;随机唤醒单个线程\nvoid notifyAll()\u0026ndash;唤醒所有线程\n注意:调用方法时用锁对象去调用这些方法\n第二种实现方法\n阻塞队列方式实现\nput数据时:放不进去，会等会，就叫阻塞\ntake数据时:取出第一个数据，取不到时，会等着，也叫阻塞\n阻塞队列继承于四个接口从高到低分别是\nIterable-\u0026gt;Collection-\u0026gt;Queue-\u0026gt;BlockingQueue\n实现类分别为: ArrayBlockingQueue(底层是数组，有界)，LinkedBlockingQueue(底层是链表，最大值是int最大值，相当于无界)\n细节:生产者和消费者必须使用同一个生产队列，队列不需要写锁了\n在主函数实现类对象，在生产者或消费者类中去定义成员变量，如何创建Javabean有参方法\n线程的状态\n新建状态(new)\u0026mdash;\u0026ndash;创建线程对象\n就绪状态(runnable)\u0026mdash;\u0026ndash;start方法\n阻塞状态(blocked)\u0026mdash;\u0026ndash;无法获得锁对象\n等待状态(waiting)\u0026mdash;\u0026ndash;wait方法\n计时状态(timed_waiting)\u0026mdash;\u0026ndash;sleep方法\n结束状态(terminated)\u0026mdash;\u0026ndash;全部代码运行完毕\n线程池\n主要核心原理\n创建一个池子，池子中是空白的\n提交任务时，池子会创建一个新的线程对象，任务完毕时，归还线程下次再提交时直接复用线程\n如果提交任务时，池子中没有空闲线程，也无法创建新的线程，就会排队等待\n线程池一般不会销毁\n用线程池提交任务可以直接执行线程\n创建线程池\npublic static ExecutorService newCachedThreadPool()\u0026mdash;创建一个没上限的线程池\npublic static ExecutorService newFixedThreadPool(int nThreads)\u0026mdash;创建一个有上限的线程池\n例: ExecutorService pool = Executors.newCachedThreadPool();\u0026ndash;获取线程池对象\npool.submit(new MyRunnable());\u0026ndash;提交线程任务\npool.shutdown();\u0026ndash;销毁线程池\n自定义线程池\n例: ThreadPoolExecutor thor = new ThreadPoolExecutor(3，6，60，TimeUnit.SECONDS，new ArrayBlockINGqUEUE\u0026lt;\u0026gt;(3)，Executors.defaultThreadFactory()，new ThreadPoolExecutor.AbortPolicy());\n参数一核心线程数量\u0026mdash;不能小于0\n参数二最大线程数\u0026mdash;不能小于0\n参数三空闲线程最大存活时间\u0026mdash;不能小于0\n参数四时间单位\u0026mdash;用TimeUnit指定\n参数五任务队列\u0026mdash;不能为null\n参数六创建线程工厂\u0026mdash;不能为null\n参数七任务拒绝策略\u0026mdash;不能为null\n注意:\n自定义线程池中是核心线程满了然后任务队列也排满了之后剩余的线程再启用临时线程服务，所以不是先来先服务的\n拒绝策略一般都是默认的就行，当临时线程都满了，就会触发拒绝策略\n线程池多大合适?\nCPU密集型运算\u0026mdash;-最大并行数+1\nI/O密集型运算\u0026mdash;-最大并行数?期望CPU利用率?总时间(CPU计算时间+等待时间)/CPU计算时间\n最大并行数\u0026mdash;-idea可以获取电脑的最大处理器数\n网络编程\n网络编程就是在网络通信协议下，不同计算机上运行的程序，进行的数据传输\nJava中可以使用Java.net包下的技术轻松开发出常见的网络应用程序\n常见的架构\nCS\u0026mdash;\u0026ndash;客服端/服务器　BS\u0026mdash;\u0026ndash;浏览器/服务器\n网络编程三要素\nIP:设备在网络中的地址，是唯一的标识\n端口号:应用程序在设备中的唯一的标识\n协议:数据在网络中传输的规则，常见的协议有UDP，TCP，HTTP，HTTPS，FTP\nIP: IPV4和IPV6 特殊IP 127.0.0.1\u0026ndash;本机地址\n端口号: 应用程序在设备中唯一的标识，一个端口号只能被一个程序使用\nInetAddress的使用\n获取InetAddress的对象\nInetAddress address = InetAddress.getByName(\u0026ldquo;ip地址或者主机名\u0026rdquo;);\n然后就可以用address调用方法来获取电脑的信息了\nUDP协议\n用户数据报协议\nUDP是面向无连接通信协议\n速度快，有大小限制一次最多64K，数据不安全，易丢失\n发送数据\n创建对象\nDatagramSocket ds = new DatagramSocket(..);\u0026mdash;有参指定端口号发送，无参在可用端口号中随机选一个\n打包数据\nString str = \u0026ldquo;你好\u0026rdquo;;\nbyte[] bytes = str.getBytes();\nInetAddress address = InetAddress.getByName(\u0026ldquo;127.0.0.1\u0026rdquo;);\nint port = 10086;\nDatagramPacket dp = new DatagramPacket(bytes，bytes.length，address，port);\n发送数据\nds.send(dp);\n释放资源\nds.close();\n接收数据\n创建对象\nDatagramSocket ds = new DatagramSocket(10086);\u0026ndash;接收数据时一定要绑定端口，端口还要和打包时端口号一样\n接收数据包\nbyte[] bytes = new byte[1024];\nDatagramPacket dp = new DatagramPacket(bytes， bytes.length);\nds.receive(dp);\n解析数据包\nbyte[] data = dp.getData();\u0026ndash;获取数据\nint length = dp.getLength();\u0026ndash;获取数据长度\nInetAddress address = dp.getAddress();\u0026ndash;获取发送数据的电脑信息\nint port = dp.getPort();\u0026ndash;获取发送数据的端口号\nSystem.out.println(new String(data，0，length));\u0026ndash;数据需要转成字符串输出\n释放资源\nds.close();\n先运行接收后运行发送\n用while就可以实现多次发送数据，实时接收数据的聊天室案例\nUDP的三种通信方式\n单播 组播 广播\n单播:上面的代码就是单播\n组播:组播地址224.0.0.0~239.255.255.255 其中224.0.0.0!224.0.0.255为预留的组播地址\n广播:广播地址255.255.255.255\n创建组播\u0026ndash;MulticastSocket ms = new MulticastSocket();\n组播接收端多了一步要将当前本机添加到组播地址中\nInetAddress address = InetAddress.getByName(\u0026ldquo;224.0.0.1\u0026rdquo;);\nms.joinGroup(address);\n广播:把单播的地址改成255.255.255.255就可以了\nTCP协议\n传输控制协议TCP\nTCP协议是面向连接的通信协议\n速度慢，没有大小限制，数据安全\nTCP通信协议是一种可靠的，它在通信两端各建立一个Socket对象\n通过Socket产生IO流来进行网络通信\n客户端\n创建客户端对象\nSocket socket = new Socket(\u0026ldquo;127.0.0.1\u0026rdquo;， 10001);\n从连接通道中获取输出流\nOutputStream put = socket.getOutputStream();\n3.写出数据\nput.write(\u0026ldquo;aaa\u0026rdquo;.getBytes());\n4.释放资源\nput.close();\nsocket.close();\n补充: socket.shutdownOutput();\u0026mdash;表示数据传输 结束标志\n服务端\n创建服务端对象\nServerSocket ss = new ServerSocket(10001);\n监听客户端连接\nSocket socket = ss.accept();\n从连接通道中获取输入流\nInputStream str = socket.getInputStream();\n输出数据\nint b;\nwhile ((b = str.read()) != -1){System.out.print((char) b);} 5.释放资源\ninput.close();\nss.close();\n细节:\n客户端如果发送的数据是中文，需要在服务端进行字符流转换，要不会出现乱码\n用三次握手协议保证连接建立 (客-\u0026gt;服请求连接，服-\u0026gt;客响应，客-\u0026gt;服再次确认连接建立)\n用四次挥手协议断开连接，保证连接通道里面的数据处理完毕了 (客-\u0026gt;服请求，服-\u0026gt;客响应，服-\u0026gt;客确认取消，客-\u0026gt;服确认取消)\n小知识UUID: 随机生成一长串字符一般用作文件名\n反射\n反射允许对成员变量，成员方法和构造方法的信息进行编程访问\n可以将类中的信息扒的一干二净 分为获取和解剖\n获取是从class字节码文件中获取的\n获取class对象的三种方式\nClass.forName(\u0026ldquo;全类名\u0026rdquo;)\u0026mdash;源代码阶段\n类名.class\u0026mdash;加载阶段\n对象.getClass()\u0026mdash;运行\n这三种获取的是同一个数据\n得到class对象后就这个类的可以得到\nget:获得\u0026ndash;构造方法(Constructor)，字段(Field)，成员方法(Method)\nset:设置\u0026ndash;参数(Parameter)，修饰符(Modifiers)，私有的(Declared)\n利用反射获取构造方法和解剖\nClass类中用于获取构造方法的方法\nConstructor\u003c?\u003e[] getConstructors(): 返回所有公共构造方法对象的数组\nConstructor\u003c?\u003e[] getDeclaredConstructors(): 返回所有构造方法对象的数组\nConstructor\u003c?\u003e[] getConstructor(Class\u003c?\u003e\u0026hellip; parameterTypes): 返回单个公共构造方法对象\nConstructor\u003c?\u003e[] getDeclaredConstructor(Class\u003c?\u003e\u0026hellip; parameterTypes): 返回单个构造方法对象\nConstructor类中用于创建对象的方法\nT newInstance(Object\u0026hellip; initargs): 根据指定的构造方法创建对象\nsetAccessible(boolean flag): 设置为true，表示取消访问检查\n解剖构造方法中的各种信息\n获取了构造方法就可以调用方法获取构造方法的所有信息，包括但不限于权限修改符，名称，参数，创建对象\u0026hellip;\u0026hellip;.\n用T.setAccessible(true)可以临时取消权限，这样就可以创建获取的私有构造方法了(暴力反射)\n利用反射获取成员变量和解剖\nClass类中用于获取成员变量的方法\nField[] getFields(): 返回所有公共成员变量对象的数组\nField[] getDeclaredFields():返回所有成员变量的数组\nField getField(String name): 返回单个公共成员变量对象\nField getDeclaredField(String name): 返回单个成员变量\nField类中用于创建对象的方法\nvoid set(Object obj，Object value): 赋值\nObject get(Object obj): 获取值\n解剖成员变量中的各种信息\n当获取了成员变量后就可以调用get\u0026hellip;方法去获取变量的各种信息\n成员变量也是如果要操作私有变量的值要提前用setAccessible方法操作一下\n利用反射获取成员方法和解剖\nClass类中用于获取成员方法的方法\nMethod[] getMethods(): 返回所有公共成员方法对象的数组，包括继承的\nMethod[] getDeclaredMethods(): 返回所有成员方法对象的数组，不包括继承的\nMethod[] getMethod(): 返回单个公共成员方法\nMethod[] getDeclaredMethod(): 返回单个成员方法\nMethod类中用于创建对象的方法\nObject invoke(Object obj，Object\u0026hellip; args): 运行方法\n参数一: 用于obj对象调用该方法\n参数二: 调用方法的传递的参数(如果没有就不写)\n返回值: 方法的返回值(如果没有就不写)\n细节:获取方法的方法中，如果要表示准备获取方法里面的参数要用字节码文件 例:String.class\n反射的作用\n1.获取一个类里面所有的信息，获取到了之后，再执行其他的业务逻辑\n2.结合配置文件，动态的创建对象并调用方法\n动态代理\n特点: 无侵入式的给代码增加额外的功能\n对象如果干的活太多可以用代理来转移部分职责\n对象有什么方法想被代理，代理就一定要有什么方法\n代理是通过接口来来实现的\n要被代理的对象和代理对象都需要实现这个接口\n创建代理\njava.lang.reflect.Proxy类: 提高了为对象产生代理对象的方法\npublic static Object newProxyInstance(ClassLoader loader，Class\u003c?\u003e[] interfaces，InvocationHandler h)\n参数一: 用于指定用哪个类加载器，去加载生成的代理类\n参数二: 指定接口，这些接口用于指定生成的代理有哪些方法\n参数三: 用来指定生成的代理对象要干什么事情\n例: public static 接口名 createProxy(原本类名 变量名){\n接口名 star = (接口名) Proxy.newProxyInstance(\n类名.class.getClassLoader()，\nnew Class[] {接口名.class，接口名2.class\u0026hellip;}，\n重写内部类(代理的对象，要运行的方法，调用方法时传递的参数){\n可以用if判断当前时要运行哪个方法，然后先把准备工作做好后，然后在return里面调用\n原本类名.invoke(类，参数\u0026hellip;)方法去执行});}\n测试类中的例子: Star proxy = 代理类.createProxy(原本类);\nString result = proxy.方法(\u0026ldquo;参数\u0026rdquo;);\u0026mdash;底层会自动去找invoke方法\nsystem.out.print(result);\n数据结构\n数据结构是计算机底层存储组织数据的方式 ， 为了更加方便管理和使用数据\n常见数据结构\n栈\n后进先出，先进后出(一个口)\n队列\n先进先出，后进后出(两个口)\n数组\n查询块，增删慢的模型\n查找是用地址值和索引，删除不仅要删数据还要每个数据往前移动，添加也一样\n链表\n查询慢，增删块的模型\n一个结点就是一个数据\n一个结点有两个存储空间:数据和下个结点地址值\n扩展(双向链表:有三个元素)\n二叉树\n度:子节点数量\n普通的二叉树\n内部结构:父结点地址/值/左结点地址/右结点地址\n二叉树遍历\n前序遍历:根结点\u0026gt;左结点\u0026gt;右结点\n中序遍历:左结点\u0026gt;根结点\u0026gt;右结点\n后序遍历:左结点\u0026gt;右结点\u0026gt;根结点\n层序遍历:一层一层从左到右\n二叉查找树\n又称二叉排序树，二叉搜索树\n特点\n每个结点最多两个子结点\n任意结点左子树都小于它\n任意结点右子树都大于它\n添加规则\n小的存左边，大存右边，一样的不存\n查找:大的往右查，小的往左查\n弊端:左右可能不平衡，导致查找效率不高\n平衡二叉树\n规则: 任意节点左右子树高度差不超过1\n依靠旋转机制来保持树的平衡\n规则1左旋\n从添加的结点开始往父结点找不平衡的点\n然后把这个点变成自己的左结点\n右结点升级变成这个父节点\n如果原先的父结点有左结点把这个结点给降级的结点当右结点\n规则2右旋\n与左旋相反操作\n触发旋转机制的情况\n1.左左\n一次右旋搞定\n2.左右\n一次左旋变成左左情况\n然后再一次右旋\n3.右右\n一次左旋\n4.右左\n一次右旋变成右右\n然后再一次左旋\n红黑树\n是一个二叉查找树，但不是高度平衡，特有的红黑规则\n红黑树增删改查性能很好\n红黑规则\n每个节点只能是红或黑\n根结点必须是黑色\n如果一个节点没有子节点或者父节点，那该节点对应的指针属性为Nil，Nil视为叶节点，每个叶节点是黑的\n如果一个节点是红色呃的那他子节点必须是黑的(不能出现两个红节点相连的情况)\n对每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点\n添加节点规则\n添加节点默认是红色(效率高)\n问题\nCommon.rePosition(): 刷新???\n快捷键\n字符串转sb/转字符数组\npsvm:sout:数组名.fori:\nCtrl+Shift+↑/↓:一行上调或者下调\nCtrl+Alt+M:自动抽取方法\nCtrl+Alt+L:自动格式代码\nCtrl+Alt+V:自动生成左边\nShift+F6:批量修改\nCtrl+P:提示参数\nCtrl+N:搜索类\nCtrl+F12:找方法\nCtrl+B:追踪源码\nCtrl+O:覆盖和实现方法\nCtrl+alt+T:循环包裹选中代码\n鼠标滚轮拖动/alt+拖动\nshift+F6:更改全部的引用\nshutdown -s:一分种后关机\n","date":"2024-09-19T22:53:40+08:00","image":"https://hugo-add.github.io/p/javase/a_hu17924107177233021515.jpg","permalink":"https://hugo-add.github.io/p/javase/","title":"JavaSE"},{"content":"一、状态码大类 状态码分类 说明 1xx 响应中——临时状态码，表示请求已经接受，告诉客户端应该继续请求或者如果它已经完成则忽略它 2xx 成功——表示请求已经被成功接收，处理已完成 3xx 重定向——重定向到其它地方：它让客户端再发起一个请求以完成整个处理。 4xx 客户端错误——处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等 5xx 服务器端错误——处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等 二、常见的响应状态码 状态码 英文描述 解释 ==200== OK 客户端请求成功，即处理成功，这是我们最想看到的状态码 302 Found 指示所请求的资源已移动到由Location响应头给定的 URL，浏览器会自动重新访问到这个页面 304 Not Modified 告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧。隐式重定向 400 Bad Request 客户端请求有语法错误，不能被服务器所理解 403 Forbidden 服务器收到请求，但是拒绝提供服务，比如：没有权限访问相关资源 ==404== Not Found 请求资源不存在，一般是URL输入有误，或者网站资源被删除了 405 Method Not Allowed 请求方式有误，比如应该用GET请求方式的资源，用了POST 428 Precondition Required 服务器要求有条件的请求，告诉客户端要想访问该资源，必须携带特定的请求头 429 Too Many Requests 指示用户在给定时间内发送了太多请求（“限速”），配合 Retry-After(多长时间后可以请求)响应头一起使用 431 Request Header Fields Too Large 请求头太大，服务器不愿意处理请求，因为它的头部字段太大。请求可以在减少请求头域的大小后重新提交。 ==500== Internal Server Error 服务器发生不可预期的错误。服务器出异常了，赶紧看日志去吧 503 Service Unavailable 服务器尚未准备好处理请求，服务器刚刚启动，还未初始化好 状态码大全：https://cloud.tencent.com/developer/chapter/13553\n","date":"2024-09-19T21:39:11+08:00","image":"https://hugo-add.github.io/p/%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81/a_hu15272716850586177076.jpg","permalink":"https://hugo-add.github.io/p/%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81/","title":"响应状态码"},{"content":"1 线程状态 1.1 状态介绍 当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程\n状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class Thread { public enum State { /* 新建 */ NEW , /* 可运行状态 */ RUNNABLE , /* 阻塞状态 */ BLOCKED , /* 无限等待状态 */ WAITING , /* 计时等待 */ TIMED_WAITING , /* 终止 */ TERMINATED; } // 获取当前线程的状态 public State getState() { return jdk.internal.misc.VM.toThreadState(threadStatus); } } 通过源码我们可以看到Java中的线程存在6种状态，每种线程状态的含义如下\n线程状态 具体含义 NEW 一个尚未启动的线程的状态。也称之为初始状态、开始状态。线程刚被创建，但是并未启动。还没调用start方法。MyThread t = new MyThread()只有线程象，没有线程特征。 RUNNABLE 当我们调用线程对象的start方法，那么此时线程对象进入了RUNNABLE状态。那么此时才是真正的在JVM进程中创建了一个线程，线程一经启动并不是立即得到执行，线程的运行与否要听令与CPU的调度，那么我们把这个中间状态称之为可执行状态(RUNNABLE)也就是说它具备执行的资格，但是并没有真正的执行起来而是在等待CPU的度。 BLOCKED 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。 WAITING 一个正在等待的线程的状态。也称之为等待状态。造成线程等待的原因有两种，分别是调用Object.wait()、join()方法。处于等待状态的线程，正在等待其他线程去执行一个特定的操作。例如：因为wait()而等待的线程正在等待另一个线程去调用notify()或notifyAll()；一个因为join()而等待的线程正在等待另一个线程结束。 TIMED_WAITING 一个在限定时间内等待的线程的状态。也称之为限时等待状态。造成线程限时等待状态的原因有三种，分别是：Thread.sleep(long)，Object.wait(long)、join(long)。 TERMINATED 一个完全运行完成的线程的状态。也称之为终止状态、结束状态 各个状态的转换，如下图所示：\n1.2 案例演示 为了验证上面论述的状态即状态转换的正确性，也为了加深对线程状态转换的理解，下面通过三个案例演示线程间中的状态转换。\n1.2.1 案例一 本案例主要演示TIME_WAITING的状态转换。\n需求：编写一段代码，依次显示一个线程的这些状态：NEW -\u0026gt; RUNNABLE -\u0026gt; TIME_WAITING -\u0026gt; RUNNABLE -\u0026gt; TERMINATED\n为了简化我们的开发，本次我们使用匿名内部类结合lambda表达式的方式使用多线程。\n代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public class ThreadStateDemo01 { public static void main(String[] args) throws InterruptedException { //定义一个内部线程 Thread thread = new Thread(() -\u0026gt; { System.out.println(\u0026#34;2.执行thread.start()之后，线程的状态：\u0026#34; + Thread.currentThread().getState()); try { //休眠100毫秒 Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026#34;4.执行Thread.sleep(long)完成之后，线程的状态：\u0026#34; + Thread.currentThread().getState()); }); //获取start()之前的状态 System.out.println(\u0026#34;1.通过new初始化一个线程，但是还没有start()之前，线程的状态：\u0026#34; + thread.getState()); //启动线程 thread.start(); //休眠50毫秒 Thread.sleep(50); //因为thread1需要休眠100毫秒，所以在第50毫秒，thread处于sleep状态 //用main线程来获取thread1线程的状态，因为thread1线程睡眠时间较长 //所以当main线程执行的时候，thread1线程还没有睡醒，还处于计时等待状态 System.out.println(\u0026#34;3.执行Thread.sleep(long)时，线程的状态：\u0026#34; + thread.getState()); //thread1和main线程主动休眠150毫秒，所以在第150毫秒,thread早已执行完毕 Thread.sleep(100); System.out.println(\u0026#34;5.线程执行完毕之后，线程的状态：\u0026#34; + thread.getState() + \u0026#34;\\n\u0026#34;); } } 控制台输出\n1 2 3 4 5 1.通过new初始化一个线程，但是还没有start()之前，线程的状态：NEW 2.执行thread.start()之后，线程的状态：RUNNABLE 3.执行Thread.sleep(long)时，线程的状态：TIMED_WAITING 4.执行Thread.sleep(long)完成之后，线程的状态：RUNNABLE 5.线程执行完毕之后，线程的状态：TERMINATED 1.2.2 案例二 本案例主要演示WAITING的状态转换。\n需求：编写一段代码，依次显示一个线程的这些状态：NEW -\u0026gt; RUNNABLE -\u0026gt; WAITING -\u0026gt; RUNNABLE -\u0026gt; TERMINATED\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 public class ThreadStateDemo02 { public static void main(String[] args) throws InterruptedException { //定义一个对象，用来加锁和解锁 Object obj = new Object(); //定义一个内部线程 Thread thread1 = new Thread(() -\u0026gt; { System.out.println(\u0026#34;2.执行thread.start()之后，线程的状态：\u0026#34; + Thread.currentThread().getState()); synchronized (obj) { try { //thread1需要休眠100毫秒 Thread.sleep(100); //thread1100毫秒之后，通过wait()方法释放obj对象是锁 obj.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\u0026#34;4.被object.notify()方法唤醒之后，线程的状态：\u0026#34; + Thread.currentThread().getState()); }); //获取start()之前的状态 System.out.println(\u0026#34;1.通过new初始化一个线程，但是还没有start()之前，线程的状态：\u0026#34; + thread1.getState()); //启动线程 thread1.start(); //main线程休眠150毫秒 Thread.sleep(150); //因为thread1在第100毫秒进入wait等待状态，所以第150秒肯定可以获取其状态 System.out.println(\u0026#34;3.执行object.wait()时，线程的状态：\u0026#34; + thread1.getState()); //声明另一个线程进行解锁 new Thread(() -\u0026gt; { synchronized (obj) { //唤醒等待的线程 obj.notify(); } }).start(); //main线程休眠10毫秒等待thread1线程能够苏醒 Thread.sleep(10); //获取thread1运行结束之后的状态 System.out.println(\u0026#34;5.线程执行完毕之后，线程的状态：\u0026#34; + thread1.getState() + \u0026#34;\\n\u0026#34;); } } 控制台输出结果\n1 2 3 4 5 1.通过new初始化一个线程，但是还没有start()之前，线程的状态：NEW 2.执行thread.start()之后，线程的状态：RUNNABLE 3.执行object.wait()时，线程的状态：WAITING 4.被object.notify()方法唤醒之后，线程的状态：RUNNABLE 5.线程执行完毕之后，线程的状态：TERMINATED 1.2.3 案例三 本案例主要演示BLOCKED的状态转换。\n需求：编写一段代码，依次显示一个线程的这些状态：NEW -\u0026gt; RUNNABLE -\u0026gt; BLOCKED -\u0026gt; RUNNABLE -\u0026gt; TERMINATED\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 public class ThreadStateDemo03 { public static void main(String[] args) throws InterruptedException { //定义一个对象，用来加锁和解锁 Object obj2 = new Object(); //定义一个线程，先抢占了obj2对象的锁 new Thread(() -\u0026gt; { synchronized (obj2) { try { Thread.sleep(100); //第一个线程要持有锁100毫秒 obj2.wait(); //然后通过wait()方法进行等待状态，并释放obj2的对象锁 } catch (InterruptedException e) { e.printStackTrace(); } } }).start(); //定义目标线程，获取等待获取obj2的锁 Thread thread = new Thread(() -\u0026gt; { System.out.println(\u0026#34;2.执行thread.start()之后，线程的状态：\u0026#34; + Thread.currentThread().getState()); synchronized (obj2) { try { Thread.sleep(100); //thread3要持有对象锁100毫秒 obj2.notify(); //然后通过notify()方法唤醒所有在ojb2上等待的线程继续执行后续操作 } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\u0026#34;4.阻塞结束后，线程的状态：\u0026#34; + Thread.currentThread().getState()); }); //获取start()之前的状态 System.out.println(\u0026#34;1.通过new初始化一个线程，但是还没有thread.start()之前，线程的状态：\u0026#34; + thread.getState()); //启动线程 thread.start(); //先等100毫秒 Thread.sleep(50); //第一个线程释放锁至少需要100毫秒，所以在第50毫秒时，thread正在因等待obj的对象锁而阻塞 System.out.println(\u0026#34;3.因为等待锁而阻塞时，线程的状态：\u0026#34; + thread.getState()); //再等300毫秒 Thread.sleep(300); //两个线程的执行时间加上之前等待的50毫秒总共是250毫秒，所以第300毫秒，所有的线程都已经执行完毕 System.out.println(\u0026#34;5.线程执行完毕之后，线程的状态：\u0026#34; + thread.getState()); } } //---------------------代码简化-------------------------------------------- Object obj = new Object(); Thread t1 = new Thread(()-\u0026gt;{ synchronized (obj){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); t1.start(); Thread t2 = new Thread(()-\u0026gt;{ System.out.println(\u0026#34;线程开启之后的状态\u0026#34; + Thread.currentThread().getState()); synchronized (obj){ System.out.println(\u0026#34;进入之后的状态\u0026#34; + Thread.currentThread().getState()); } }); System.out.println(\u0026#34;创建线程对象后,但是不调用start方法的状态\u0026#34; + t2.getState()); t2.start(); Thread.sleep(100); System.out.println(t2.getState()); Thread.sleep(2000); System.out.println(t2.getState()); 控制台输出结果\n1 2 3 4 5 1.通过new初始化一个线程，但是还没有thread.start()之前，线程的状态：NEW 2.执行thread.start()之后，线程的状态：RUNNABLE 3.因为等待锁而阻塞时，线程的状态：BLOCKED 4.阻塞结束后，线程的状态：RUNNABLE 5.线程执行完毕之后，线程的状态：TERMINATED 通过上面3个案例的代码演示，我们可以证明开始章节说所述的线程状态以及线程状态转换都是正确的。\n2 线程池 2.1 概述 提到池，大家应该能想到的就是水池。水池就是一个容器，在该容器中存储了很多的水。那么什么是线程池呢？线程池也是可以看做成一个池子，在该池子中存储很多个线程。\n线程池存在的意义：\n系统创建一个线程的成本是比较高的，因为它涉及到与操作系统交互，当程序中需要创建大量生存期很短暂的线程时，频繁的创建和销毁线程对系统的资源消耗有可能大于业务处理是对系\n统资源的消耗，这样就有点\u0026quot;舍本逐末\u0026quot;了。针对这一种情况，为了提高性能，我们就可以采用线程池。线程池在启动的时，会创建大量空闲线程，当我们向线程池提交任务的时，线程池就\n会启动一个线程来执行该任务。等待任务执行完毕以后，线程并不会死亡，而是再次返回到线程池中称为空闲状态。等待下一次任务的执行。\n2.2 自定义线程池 2.2.1 线程池的设计思路 线程池的思路和生产者消费者模型是很接近的\n准备一个任务容器 一次性启动多个(2个)消费者线程 刚开始任务容器是空的，所以线程都在wait 直到一个外部线程向这个任务容器中扔了一个\u0026quot;任务\u0026quot;，就会有一个消费者线程被唤醒 这个消费者线程取出\u0026quot;任务\u0026quot;，并且执行这个任务，执行完毕后，继续等待下一次任务的到来 在整个过程中，都不需要创建新的线程，而是循环使用这些已经存在的线程。\n2.2.2 代码实现 实现思路：\n创建一个线程池类(ThreadPool) 在该类中定义两个成员变量poolSize(线程池初始化线程的个数) , BlockingQueue\u0026lt;Runnable\u0026gt;(任务容器) 通过构造方法来创建两个线程对象(消费者线程)，并且启动 使用内部类的方式去定义一个线程类(TaskThread),可以提供一个构造方法用来初始化线程名称 两个消费者线程需要不断的从任务容器中获取任务，如果没有任务，则线程处于阻塞状态。 提供一个方法(submit)向任务容器中添加任务 定义测试类进行测试 线程池类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 public class ThreadPool { // 初始化线程个数 private static final int DEFAULT_POOL_SIZE = 2 ; // 在该类中定义两个成员变量poolSize(线程池初始化线程的个数) , BlockingQueue\u0026lt;Runnable\u0026gt;(任务容器) private int poolSize = DEFAULT_POOL_SIZE ; private BlockingQueue\u0026lt;Runnable\u0026gt; blockingQueue = new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;() ; // 无参构造方法 public ThreadPool(){ this.initThread(); } // 有参构造方法，通过构造方法来创建两个线程对象(消费者线程)，并且启动 public ThreadPool(int poolSize) { if(poolSize \u0026gt; 0) { this.poolSize = poolSize ; } this.initThread(); } // 初始化线程方法 public void initThread(){ for(int x = 0 ; x \u0026lt; poolSize ; x++) { new TaskThread(\u0026#34;线程---\u0026gt;\u0026#34; + x).start(); } } // 提供一个方法(submit)向任务容器中添加任务 public void submit(Runnable runnable) { try { blockingQueue.put(runnable); } catch (InterruptedException e) { e.printStackTrace(); } } // 使用内部类的方式去定义一个线程类 public class TaskThread extends Thread { // 提供一个构造方法，用来初始化线程名称 public TaskThread(String name) { super(name); } @Override public void run() { while(true) { try { // 两个消费者线程需要不断的从任务容器中获取任务，如果没有任务，则线程处于阻塞状态。 Runnable task = blockingQueue.take(); task.run(); } catch (InterruptedException e) { e.printStackTrace(); } } } } } 测试类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class ThreadPoolDemo01 { public static void main(String[] args) { // 创建线程池对象,无参构造方法创建 // ThreadPool threadPool = new ThreadPool(); ThreadPool threadPool = new ThreadPool(5); // 提交任务 for(int x = 0 ; x \u0026lt; 10 ; x++) { threadPool.submit( () -\u0026gt; { System.out.println(Thread.currentThread().getName() + \u0026#34;----\u0026gt;\u0026gt;\u0026gt;处理了任务\u0026#34;); }); } } } 使用无参构造方法创建线程池对象，控制台输出结果\n1 2 3 4 5 6 7 8 9 10 线程---\u0026gt;0----\u0026gt;\u0026gt;\u0026gt;处理了任务 线程---\u0026gt;1----\u0026gt;\u0026gt;\u0026gt;处理了任务 线程---\u0026gt;0----\u0026gt;\u0026gt;\u0026gt;处理了任务 线程---\u0026gt;1----\u0026gt;\u0026gt;\u0026gt;处理了任务 线程---\u0026gt;0----\u0026gt;\u0026gt;\u0026gt;处理了任务 线程---\u0026gt;1----\u0026gt;\u0026gt;\u0026gt;处理了任务 线程---\u0026gt;0----\u0026gt;\u0026gt;\u0026gt;处理了任务 线程---\u0026gt;1----\u0026gt;\u0026gt;\u0026gt;处理了任务 线程---\u0026gt;0----\u0026gt;\u0026gt;\u0026gt;处理了任务 线程---\u0026gt;1----\u0026gt;\u0026gt;\u0026gt;处理了任务 通过控制台的输出，我们可以看到在线程池中存在两个线程，通过这2个线程处理了10个任务。\n使用有参构造方法创建线程池对象，传递的参数是5，控制台输出结果\n线程---\u0026gt;3----\u0026gt;\u0026gt;\u0026gt;处理了任务 线程---\u0026gt;4----\u0026gt;\u0026gt;\u0026gt;处理了任务 线程---\u0026gt;2----\u0026gt;\u0026gt;\u0026gt;处理了任务 线程---\u0026gt;0----\u0026gt;\u0026gt;\u0026gt;处理了任务 线程---\u0026gt;2----\u0026gt;\u0026gt;\u0026gt;处理了任务 线程---\u0026gt;4----\u0026gt;\u0026gt;\u0026gt;处理了任务 线程---\u0026gt;3----\u0026gt;\u0026gt;\u0026gt;处理了任务 线程---\u0026gt;1----\u0026gt;\u0026gt;\u0026gt;处理了任务 线程---\u0026gt;2----\u0026gt;\u0026gt;\u0026gt;处理了任务 线程---\u0026gt;0----\u0026gt;\u0026gt;\u0026gt;处理了任务 通过控制台的输出，我们可以看到在线程池中存在两个线程，通过这5个线程处理了10个任务。\n2.3 JDK中线程池 2.3.1 Executors JDK对线程池也进行了相关的实现，在真实企业开发中我们也很少去自定义线程池，而是使用JDK中自带的线程池。\n我们可以使用Executors中所提供的静态方法来创建线程池。\n获取线程池的方法：\n//通过不同的方法创建出来的线程池具有不同的特点。\n1 2 3 4 5 6 ExecutorService newCachedThreadPool(): 创建一个可缓存线程池，可灵活的去创建线程，并且灵活的回收线程，若无可回收，则新建线程。 ExecutorService newFixedThreadPool(int nThreads): 初始化一个具有固定数量线程的线程池 ExecutorService newSingleThreadExecutor(): 初始化一个具有一个线程的线程池 //做完一个，再做一个，不停歇，直到做完，老黄牛性格 ScheduledExecutorService newSingleThreadScheduledExecutor(): 初始化一个具有一个线程的线程池，支持定时及周期性任务执行 //按照固定的计划去执行线程，一个做完之后按照计划再做另一个 这个方法返回的都是ExecutorService类型的对象(ScheduledExecutorService继承ExecutorService),而ExecutorService可以看做就是一个线程池，那么ExecutorService\n给我们提供了哪些方法供我们使用呢？\nExecutorService中的常见方法：\n1 2 Future\u0026lt;?\u0026gt; submit(Runnable task)：\t提交任务方法 void shutdown()：\t关闭线程池的方法\t案例1：演示newCachedThreadPool方法所获取到的线程池的特点\n测试类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class ExecutorsDemo01 { // 演示Executors中的newCachedThreadPool返回的线程池的特点 public static void main(String[] args) throws InterruptedException { // 获取线程池对象 ExecutorService threadPool = Executors.newCachedThreadPool(); // 提交任务 threadPool.submit(() -\u0026gt; { System.out.println( Thread.currentThread().getName() + \u0026#34;---执行了任务\u0026#34;); }); // 提交任务 threadPool.submit(() -\u0026gt; { System.out.println( Thread.currentThread().getName() + \u0026#34;---执行了任务\u0026#34;); }); // 不使用线程池了，还可以将线程池关闭 threadPool.shutdown(); } } 控制台输出结果\n1 2 pool-1-thread-2---执行了任务 pool-1-thread-1---执行了任务 针对每一个任务，线程池为其分配一个线程去执行，我们可以在第二次提交任务的时候，让主线程休眠一小会儿，看程序的执行结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class ExecutorsDemo02 { // 演示Executors中的newCachedThreadPool返回的线程池的特点 public static void main(String[] args) throws InterruptedException { // 获取线程池对象 ExecutorService threadPool = Executors.newCachedThreadPool(); // 提交任务 threadPool.submit(() -\u0026gt; { System.out.println( Thread.currentThread().getName() + \u0026#34;---执行了任务\u0026#34;); }); // 线程休眠2秒，主线程休眠2秒，此时之前提交的任务应该已经执行完毕 TimeUnit.SECONDS.sleep(2); // 提交任务 threadPool.submit(() -\u0026gt; { System.out.println( Thread.currentThread().getName() + \u0026#34;---执行了任务\u0026#34;); }); // 不使用线程池了，还可以将线程池关闭 threadPool.shutdown(); } } 控制台输出结果\n1 2 pool-1-thread-1---执行了任务 pool-1-thread-1---执行了任务 我们发现是通过一个线程执行了两个任务。此时就说明线程池中的线程\u0026quot;pool-1-thread-1\u0026quot;被线程池回收了，成为了空闲线程，当我们再次提交任务的时候，该线程就去执行新的任务。\n案例2：演示newFixedThreadPool方法所获取到的线程池的特点\n测试类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ExecutorsDemo03 { // 演示newFixedThreadPool方法所获取到的线程池的特点 public static void main(String[] args) { // 获取线程池对象,初始化一个具有固定数量线程的线程池 ExecutorService threadPool = Executors.newFixedThreadPool(3); // 在该线程池中存在3个线程 // 提交任务 for(int x = 0 ; x \u0026lt; 5 ; x++) { threadPool.submit( () -\u0026gt; { System.out.println(Thread.currentThread().getName() + \u0026#34;-----\u0026gt;\u0026gt;\u0026gt;执行了任务\u0026#34; ); }); } // 关闭线程池 threadPool.shutdown(); } } 控制台输出结果\n1 2 3 4 5 pool-1-thread-1-----\u0026gt;\u0026gt;\u0026gt;执行了任务 pool-1-thread-2-----\u0026gt;\u0026gt;\u0026gt;执行了任务 pool-1-thread-2-----\u0026gt;\u0026gt;\u0026gt;执行了任务 pool-1-thread-2-----\u0026gt;\u0026gt;\u0026gt;执行了任务 pool-1-thread-3-----\u0026gt;\u0026gt;\u0026gt;执行了任务 通过控制台的输出结果，我们可以看到5个任务是通过3个线程进行执行的，说明此线程池中存在三个线程对象\n案例3：演示newSingleThreadExecutor方法所获取到的线程池的特点\n测试类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ExecutorsDemo04 { // 演示newSingleThreadExecutor方法所获取到的线程池的特点 public static void main(String[] args) { // 获取线程池对象,初始化一个具有一个线程的线程池 ExecutorService threadPool = Executors.newSingleThreadExecutor(); // 提交任务 for(int x = 0 ; x \u0026lt; 5 ; x++) { threadPool.submit(() -\u0026gt; { System.out.println(Thread.currentThread().getName() + \u0026#34;-----\u0026gt;\u0026gt;\u0026gt;执行了任务\u0026#34;); }); } // 关闭线程池 threadPool.shutdown(); } } 控制台输出结果\n1 2 3 4 5 pool-1-thread-1-----\u0026gt;\u0026gt;\u0026gt;执行了任务 pool-1-thread-1-----\u0026gt;\u0026gt;\u0026gt;执行了任务 pool-1-thread-1-----\u0026gt;\u0026gt;\u0026gt;执行了任务 pool-1-thread-1-----\u0026gt;\u0026gt;\u0026gt;执行了任务 pool-1-thread-1-----\u0026gt;\u0026gt;\u0026gt;执行了任务 通过控制台的输出结果，我们可以看到5个任务是通过1个线程进行执行的,说明此线程池中只存在一个线程对象。\n案例4： 演示newSingleThreadScheduledExecutor方法所获取到的线程池的特点(初始化一个具有一个线程的线程池)\n测试类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ExecutorsDemo05 { // 演示：newSingleThreadScheduledExecutor方法所获取到的线程池的第一个特点(初始化一个具有一个线程的线程池) public static void main(String[] args) { // 获取线程池对象 ScheduledExecutorService threadPool = Executors.newSingleThreadScheduledExecutor(); // 提交任务 for(int x = 0 ; x \u0026lt; 5 ; x++) { threadPool.submit(() -\u0026gt; { System.out.println(Thread.currentThread().getName() + \u0026#34;----\u0026gt;\u0026gt;执行了任务\u0026#34;); }); } // 关闭线程池 threadPool.shutdown(); } } 控制台输出结果\n1 2 3 4 5 pool-1-thread-1----\u0026gt;\u0026gt;执行了任务 pool-1-thread-1----\u0026gt;\u0026gt;执行了任务 pool-1-thread-1----\u0026gt;\u0026gt;执行了任务 pool-1-thread-1----\u0026gt;\u0026gt;执行了任务 pool-1-thread-1----\u0026gt;\u0026gt;执行了任务 通过控制台的输出结果，我们可以看到5个任务是通过1个线程进行执行的,说明此线程池中只存在一个线程对象。\n案例5： 演示newSingleThreadScheduledExecutor方法所获取到的线程池的特点(支持定时及周期性任务执行)\nScheduledExecutorService中和定时以及周期性执行相关的方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* 定时执行 command: 任务类对象 delay : 延迟多长时间开始执行任务, 任务提交到线程池以后我们需要等待多长时间开始执行这个任务 unit : 指定时间操作单元 */ public ScheduledFuture\u0026lt;?\u0026gt; schedule(Runnable command,long delay, TimeUnit unit); /* 周期性执行 command: 任务类对象 initialDelay: 延迟多长时间开始第一次该执行任务, 任务提交到线程池以后我们需要等待多长时间开始第一次执行这个任务 period: 下一次执行该任务所对应的时间间隔 unit: 指定时间操作单元 */ public ScheduledFuture\u0026lt;?\u0026gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit); 测试类1(演示定时执行)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class ExecutorsDemo06 { // 演示newSingleThreadScheduledExecutor方法所获取到的线程池的特点(支持定时及周期性任务执行) public static void main(String[] args) { // 获取线程池对象 ScheduledExecutorService threadPool = Executors.newSingleThreadScheduledExecutor(); // 提交任务,10s以后开始执行该任务 threadPool.schedule( () -\u0026gt; { System.out.println(Thread.currentThread().getName() + \u0026#34;----\u0026gt;\u0026gt;\u0026gt;执行了该任务\u0026#34;); } , 10 , TimeUnit.SECONDS) ; // 关闭线程池 threadPool.shutdown(); } } 测试类2(演示周期性执行)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class ExecutorsDemo07 { // 演示newSingleThreadScheduledExecutor方法所获取到的线程池的特点(支持定时及周期性任务执行) public static void main(String[] args) { // 获取线程池对象 ScheduledExecutorService threadPool = Executors.newSingleThreadScheduledExecutor(); // 提交任务,10s以后开始第一次执行该任务，然后每隔1秒执行一次 threadPool.scheduleAtFixedRate( () -\u0026gt; { System.out.println(Thread.currentThread().getName() + \u0026#34;----\u0026gt;\u0026gt;\u0026gt;执行了该任务\u0026#34;); } , 10 ,1, TimeUnit.SECONDS) ; } } 2.3.2 ThreadPoolExecutor 1) 基本使用 刚才我们是通过Executors中的静态方法去创建线程池的，通过查看源代码我们发现，其底层都是通过ThreadPoolExecutor构建的。比如：newFixedThreadPool方法的源码\n1 2 3 4 5 public static ExecutorService newFixedThreadPool(int nThreads) { // 创建了ThreadPoolExecutor对象，然后直接返回 return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;()); } 那么也可以使用ThreadPoolExecutor去创建线程池。\nThreadPoolExecutor最完整的构造方法：\n1 2 3 4 5 6 7 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u0026lt;Runnable\u0026gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 参数说明\n1 2 3 4 5 6 7 corePoolSize： 核心线程的最大值，不能小于0 maximumPoolSize：最大线程数，不能小于等于0，maximumPoolSize \u0026gt;= corePoolSize keepAliveTime： 空闲线程最大存活时间,不能小于0 unit： 时间单位 workQueue： 任务队列，不能为null threadFactory： 创建线程工厂,不能为null handler： 任务的拒绝策略,不能为null 案例演示通过ThreadPoolExecutor创建线程池\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class ThreadPoolExecutorDemo01 { // 演示基本使用 public static void main(String[] args) { // 通过ThreadPoolExecutor创建一个线程池对象 ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 60 , TimeUnit.SECONDS , new ArrayBlockingQueue\u0026lt;Runnable\u0026gt;(3) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.AbortPolicy()) ; /** * 以上代码表示的意思是：核心线程池中的线程数量最大为1,整个线程池中最多存在3个线程,空闲线程最大的存活时间为60,时间单位为秒,阻塞队列使用的是有界阻塞队列 * 容量为3,使用默认的线程工厂;以及默认的任务处理策略 */ // 提交任务 threadPoolExecutor.submit( () -\u0026gt; { System.out.println(Thread.currentThread().getName() + \u0026#34;------\u0026gt;\u0026gt;\u0026gt;执行了任务\u0026#34;); }); // 关闭线程池 threadPoolExecutor.shutdown(); } } 2) 工作原理 接下来我们就来研究一下线程池的工作原理，如下图所示\n当我们通过submit方法向线程池中提交任务的时候，具体的工作流程如下：\n客户端每次提交一个任务，线程池就会在核心线程池中创建一个工作线程来执行这个任务。当核心线程池中的线程已满时，则进入下一步操作。 把任务试图存储到工作队列中。如果工作队列没有满，则将新提交的任务存储在这个工作队列里，等待核心线程池中的空闲线程执行。如果工作队列满了，则进入下个流程。 线程池会再次在非核心线程池区域去创建新工作线程来执行任务，直到当前线程池总线程数量超过最大线程数时，就是按照指定的任务处理策略处理多余的任务。 举例说明：\n假如有一个工厂，工厂里面有10个工人(正式员工)，每个工人同时只能做一件任务。因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；当10个工人都有任务在做时，\n如果还来了任务，就把任务进行排队等待；如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来；然后就将任务也分配\n给这4个临时工人做；如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。当这14个工人当中有人空闲时，而新任务增长的速度\n又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。\n这里的工厂可以看做成是一个线程池，每一个工人可以看做成是一个线程。其中10个正式员工，可以看做成是核心线程池中的线程，临时工就是非核心线程池中的线程。当临时工处于空闲状态\n的时候，那么如果空闲的时间超过keepAliveTime所指定的时间，那么就会被销毁。\n3) 案例演示 接下来我们就通过一段代码的断点测试，来演示一下线程池的工作原理。\n案例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ThreadPoolExecutorDemo01 { public static void main(String[] args) { /** * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s */ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS , new ArrayBlockingQueue\u0026lt;\u0026gt;(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.AbortPolicy()) ; // 提交3个任务，此时会产生一个核心线程,一个临时工线程，队列中会存在一个任务，20s后临时工线程被回收，核心线程不会被回收 for(int x = 0 ; x \u0026lt; 3 ; x++) { threadPoolExecutor.submit(() -\u0026gt; {\t// 断点位置 System.out.println(Thread.currentThread().getName() + \u0026#34;----\u0026gt;\u0026gt; 执行了任务\u0026#34;); }); } } } 初次debug方式启动线程，查看变量值\n由于此时还没有提交任务，因此线程池中的线程数量为0，工作队列的任务数量也为0；提交一个任务\n再次查看各个值的变化\n再次提交一个任务\n再次查看各个值的变化\n此时会把第二个任务存储到工作队列中，因此工作队列的值为1了。再次提交一个任务\n再次查看各个值的变化\n此时3个任务都以及提交完毕，断点跳过。经过20s以后，再次查看该进程中的线程。\n我们发现非核心线程已经被线程池回收了。\n4) 任务拒绝策略 RejectedExecutionHandler是jdk提供的一个任务拒绝策略接口，它下面存在4个子类。\n1 2 3 4 ThreadPoolExecutor.AbortPolicy: 丢弃任务并抛出RejectedExecutionException异常。是默认的策略。 ThreadPoolExecutor.DiscardPolicy： 丢弃任务，但是不抛出异常 这是不推荐的做法。 ThreadPoolExecutor.DiscardOldestPolicy： 抛弃队列中等待最久的任务 然后把当前任务加入队列中。 ThreadPoolExecutor.CallerRunsPolicy: 调用任务的run()方法绕过线程池直接执行。 注：明确线程池对多可执行的任务数 = 队列容量 + 最大线程数\n案例演示1：演示ThreadPoolExecutor.AbortPolicy任务处理策略\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ThreadPoolExecutorDemo01 { public static void main(String[] args) { /** * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s */ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS , new ArrayBlockingQueue\u0026lt;\u0026gt;(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.AbortPolicy()) ; // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用AbortPolicy这个任务处理策略的时候，就会抛出异常 for(int x = 0 ; x \u0026lt; 5 ; x++) { threadPoolExecutor.submit(() -\u0026gt; { System.out.println(Thread.currentThread().getName() + \u0026#34;----\u0026gt;\u0026gt; 执行了任务\u0026#34;); }); } } } 控制台输出结果\n1 2 3 4 5 6 7 8 9 10 Exception in thread \u0026#34;main\u0026#34; java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@566776ad[Not completed, task = java.util.concurrent.Executors$RunnableAdapter@edf4efb[Wrapped task = com.itheima.javase.thread.pool.demo04.ThreadPoolExecutorDemo01$$Lambda$14/0x0000000100066840@2f7a2457]] rejected from java.util.concurrent.ThreadPoolExecutor@6108b2d7[Running, pool size = 3, active threads = 3, queued tasks = 1, completed tasks = 0] at java.base/java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2055) at java.base/java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:825) at java.base/java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1355) at java.base/java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:118) at com.itheima.javase.thread.pool.demo04.ThreadPoolExecutorDemo01.main(ThreadPoolExecutorDemo01.java:20) pool-1-thread-1----\u0026gt;\u0026gt; 执行了任务 pool-1-thread-3----\u0026gt;\u0026gt; 执行了任务 pool-1-thread-2----\u0026gt;\u0026gt; 执行了任务 pool-1-thread-3----\u0026gt;\u0026gt; 执行了任务 控制台报错，仅仅执行了4个任务，有一个任务被丢弃了\n案例演示2：演示ThreadPoolExecutor.DiscardPolicy任务处理策略\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class ThreadPoolExecutorDemo02 { public static void main(String[] args) { /** * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s */ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS , new ArrayBlockingQueue\u0026lt;\u0026gt;(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardPolicy()) ; // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用DiscardPolicy这个任务处理策略的时候，控制台不会报错 for(int x = 0 ; x \u0026lt; 5 ; x++) { threadPoolExecutor.submit(() -\u0026gt; { System.out.println(Thread.currentThread().getName() + \u0026#34;----\u0026gt;\u0026gt; 执行了任务\u0026#34;); }); } } } 控制台输出结果\n1 2 3 4 pool-1-thread-1----\u0026gt;\u0026gt; 执行了任务 pool-1-thread-1----\u0026gt;\u0026gt; 执行了任务 pool-1-thread-3----\u0026gt;\u0026gt; 执行了任务 pool-1-thread-2----\u0026gt;\u0026gt; 执行了任务 控制台没有报错，仅仅执行了4个任务，有一个任务被丢弃了\n案例演示3：演示ThreadPoolExecutor.DiscardOldestPolicy任务处理策略\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class ThreadPoolExecutorDemo02 { public static void main(String[] args) { /** * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s */ ThreadPoolExecutor threadPoolExecutor; threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS , new ArrayBlockingQueue\u0026lt;\u0026gt;(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardOldestPolicy()); // 提交5个任务 for(int x = 0 ; x \u0026lt; 5 ; x++) { // 定义一个变量，来指定指定当前执行的任务;这个变量需要被final修饰 final int y = x ; threadPoolExecutor.submit(() -\u0026gt; { System.out.println(Thread.currentThread().getName() + \u0026#34;----\u0026gt;\u0026gt; 执行了任务\u0026#34; + y); }); } } } 控制台输出结果\n1 2 3 4 pool-1-thread-2----\u0026gt;\u0026gt; 执行了任务2 pool-1-thread-1----\u0026gt;\u0026gt; 执行了任务0 pool-1-thread-3----\u0026gt;\u0026gt; 执行了任务3 pool-1-thread-1----\u0026gt;\u0026gt; 执行了任务4 由于任务1在线程池中等待时间最长，因此任务1被丢弃。\n案例演示4：演示ThreadPoolExecutor.CallerRunsPolicy任务处理策略\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class ThreadPoolExecutorDemo04 { public static void main(String[] args) { /** * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s */ ThreadPoolExecutor threadPoolExecutor; threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS , new ArrayBlockingQueue\u0026lt;\u0026gt;(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.CallerRunsPolicy()); // 提交5个任务 for(int x = 0 ; x \u0026lt; 5 ; x++) { threadPoolExecutor.submit(() -\u0026gt; { System.out.println(Thread.currentThread().getName() + \u0026#34;----\u0026gt;\u0026gt; 执行了任务\u0026#34;); }); } } } 控制台输出结果\n1 2 3 4 5 pool-1-thread-1----\u0026gt;\u0026gt; 执行了任务 pool-1-thread-3----\u0026gt;\u0026gt; 执行了任务 pool-1-thread-2----\u0026gt;\u0026gt; 执行了任务 pool-1-thread-1----\u0026gt;\u0026gt; 执行了任务 main----\u0026gt;\u0026gt; 执行了任务 通过控制台的输出，我们可以看到次策略没有通过线程池中的线程执行任务，而是直接调用任务的run()方法绕过线程池直接执行。\n3 volatile关键字 3.1 看程序说结果 分析如下程序，说出在控制台的输出结果。\nThread的子类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class VolatileThread extends Thread { // 定义成员变量 private boolean flag = false ; public boolean isFlag() { return flag;} @Override public void run() { // 线程休眠1秒 try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } // 将flag的值更改为true this.flag = true ; System.out.println(\u0026#34;flag=\u0026#34; + flag); } } 测试类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class VolatileThreadDemo01 { public static void main(String[] args) { // 创建VolatileThread线程对象 VolatileThread volatileThread = new VolatileThread() ; volatileThread.start(); // 在main线程中获取开启的线程中flag的值 while(true) { System.out.println(\u0026#34;main线程中获取开启的线程中flag的值为\u0026#34; + volatileThread.isFlag()); } } } 控制台输出结果\n1 前面是false，过了一段时间之后就变成了true 按照我们的分析，当我们把volatileThread线程启动起来以后，那么volatileThread线程开始执行。在volatileThread线程的run方法中，线程休眠1s，休眠一秒以后那么flag的值应该为\ntrue，此时我们在主线程中不停的获取flag的值。发现前面释放false，后面是true\n信息，那么这是为什么呢？要想知道原因，那么我们就需要学习一下JMM。\n3.2 JMM 概述：JMM(Java Memory Model)Java内存模型,是java虚拟机规范中所定义的一种内存模型。\nJava内存模型(Java Memory Model)描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节。\n特点：\n所有的共享变量都存储于主内存(计算机的RAM)这里所说的变量指的是实例变量和类变量。不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。\n每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。\n线程对变量的所有的操作(读，写)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主\n内存完成。\n3.3 问题分析 了解了一下JMM,那么接下来我们就来分析一下上述程序产生问题的原因。\n产生问题的流程分析：\nVolatileThread线程从主内存读取到数据放入其对应的工作内存\n将flag的值更改为true，但是这个时候flag的值还没有回写主内存\n此时main线程读取到了flag的值并将其放入到自己的工作内存中，此时flag的值为false\nVolatileThread线程将flag的值写回到主内存，但是main函数里面的while(true)调用的是系统比较底层的代码，速度快，快到没有时间再去读取主内存中的值，所以while(true)\n读取到的值一直是false。(如果有一个时刻main线程从主内存中读取到了flag的最新值，那么if语句就可以执行，main线程何时从主内存中读取最新的值，我们无法控制)\n我们可以让主线程执行慢一点，执行慢一点以后，在某一个时刻，可能就会读取到主内存中最新的flag的值，那么if语句就可以进行执行。\n测试类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class VolatileThreadDemo02 { public static void main(String[] args) throws InterruptedException { // 创建VolatileThread线程对象 VolatileThread volatileThread = new VolatileThread() ; volatileThread.start(); // main方法 while(true) { if(volatileThread.isFlag()) { System.out.println(\u0026#34;执行了======\u0026#34;); } // 让线程休眠100毫秒 TimeUnit.MILLISECONDS.sleep(100); } } } 控制台输出结果\n1 2 3 4 5 flag=true 执行了====== 执行了====== 执行了====== .... 此时我们可以看到if语句已经执行了。当然我们在真实开发中可能不能使用这种方式来处理这个问题，那么这个问题应该怎么处理呢？我们就需要学习下一小节的内容。\n3.4 问题处理 3.4.1 加锁 第一种处理方案，我们可以通过加锁的方式进行处理。\n测试类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class VolatileThreadDemo03 { public static void main(String[] args) throws InterruptedException { // 创建VolatileThread线程对象 VolatileThread volatileThread = new VolatileThread() ; volatileThread.start(); // main方法 while(true) { // 加锁进行问题处理 synchronized (volatileThread) { if(volatileThread.isFlag()) { System.out.println(\u0026#34;执行了======\u0026#34;); } } } } } 控制台输出结果\n1 2 3 4 5 flag=true 执行了====== 执行了====== 执行了====== .... 工作原理说明\n对上述代码加锁完毕以后，某一个线程支持该程序的过程如下：\na.线程获得锁\nb.清空工作内存\nc.从主内存拷贝共享变量最新的值到工作内存成为副本\nd.执行代码\ne.将修改后的副本的值刷新回主内存中\nf.线程释放锁\n3.4.2 volatile关键字 第二种处理方案，我们可以通过volatile关键字来修饰flag变量。\n线程类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public class VolatileThread extends Thread { // 定义成员变量 private volatile boolean flag = false ; public boolean isFlag() { return flag;} @Override public void run() { // 线程休眠1秒 try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } // 将flag的值更改为true this.flag = true ; System.out.println(\u0026#34;flag=\u0026#34; + flag); } } //--------------------------------更新之后的案例------------------------------------------- public class VolatileTest extends Thread{ boolean flag = false; int i = 0; public void run() { while (!flag) { i++; } System.out.println(\u0026#34;stope\u0026#34; + i); } public static void main(String[] args) throws Exception { VolatileTest vt = new VolatileTest(); vt.start(); Thread.sleep(10); vt.flag = true; } } 控制台输出结果\n1 2 3 4 5 flag=true 执行了====== 执行了====== 执行了====== .... 工作原理说明\n执行流程分析\nVolatileThread线程从主内存读取到数据放入其对应的工作内存 将flag的值更改为true，但是这个时候flag的值还没有回写主内存 此时main线程读取到了flag的值并将其放入到自己的工作内存中，此时flag的值为false VolatileThread线程将flag的值写到主内存 main线程工作内存中的flag变量副本失效 main线程再次使用flag时，main线程会从主内存读取最新的值，放入到工作内存中，然后在进行使用 总结： volatile保证不同线程对共享变量操作的可见性，也就是说一个线程修改了volatile修饰的变量，当修改写回主内存时，另外一个线程立即看到最新的值。\n​ 但是volatile不保证原子性(关于原子性问题，我们在下面的小节中会介绍)。\nvolatile与synchronized的区别：\nvolatile只能修饰实例变量和类变量，而synchronized可以修饰方法，以及代码块。\nvolatile保证数据的可见性，但是不保证原子性(多线程进行写操作，不保证线程安全);而synchronized是一种排他（互斥）的机制(因此有时我们也将synchronized这种锁称\n之为排他（互斥）锁)，synchronized修饰的代码块，被修饰的代码块称之为同步代码块，无法被中断可以保证原子性，也可以间接的保证可见性。\n4 原子性 概述：所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行，多个操作是一个不可以分割的整体。\n//比如说：你喂你女朋友吃冰淇淋，如果没有女朋友，你就假想一下，实在不行，你就喂你旁边的哥们吃一口冰淇淋。这就是一个不可分割的整体，一个是你喂，一个是她吃。这就是一个整体，如果没有她吃，那么你喂就没有意义，如果没有你喂，她吃就没有意义。\n//比如：从张三的账户给李四的账户转1000元，这个动作将包含两个基本的操作：从张三的账户扣除1000元，给李四的账户增加1000元。这两个操作必须符合原子性的要求，要么都成功要么\n都失败。\n4.1 看程序说结果 分析如下程序的执行结果\n线程类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class VolatileAtomicThread implements Runnable { // 定义一个int类型的变量 private int count = 0 ; @Override public void run() { // 对该变量进行++操作，100次 for(int x = 0 ; x \u0026lt; 100 ; x++) { count++ ;\tSystem.out.println(\u0026#34;冰淇淋的个数 =========\u0026gt;\u0026gt;\u0026gt;\u0026gt; \u0026#34; + count); } } } 测试类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class VolatileAtomicThreadDemo { public static void main(String[] args) { // 创建VolatileAtomicThread对象 VolatileAtomicThread volatileAtomicThread = new VolatileAtomicThread() ; // 开启100个线程对count进行++操作 for(int x = 0 ; x \u0026lt; 100 ; x++) { new Thread(volatileAtomicThread).start(); } } } 程序分析：我们在主线程中通过for循环启动了100个线程，每一个线程都会对VolatileAtomicThread类中的count加100次。那么直接结果应该是10000。但是真正的执行结果和我们分析\n的是否一样呢？运行程序(多运行几次)，查看控制台输出结果\n1 2 3 4 .... count =========\u0026gt;\u0026gt;\u0026gt;\u0026gt; 9997 count =========\u0026gt;\u0026gt;\u0026gt;\u0026gt; 9998 count =========\u0026gt;\u0026gt;\u0026gt;\u0026gt; 9999 通过控制台的输出，我们可以看到最终count的结果可能并不是10000。接下来我们就来分析一下问题产生的原因。\n4.2 问题分析说明 以上问题主要是发生在count++操作上：\ncount++操作包含3个步骤：\n从主内存中读取数据到工作内存 对工作内存中的数据进行++操作 将工作内存中的数据写回到主内存 count++操作不是一个原子性操作，也就是说在某一个时刻对某一个操作的执行，有可能被其他的线程打断。\n产生问题的执行流程分析：\n假设此时count的值是100，线程A需要对改变量进行自增1的操作，首先它需要从主内存中读取变量count的值。由于CPU的切换关系，此时CPU的执行权被切换到了B线程。A线程就处\n于就绪状态，B线程处于运行状态。\n线程B也需要从主内存中读取count变量的值,由于线程A没有对count值做任何修改因此此时B读取到的数据还是100\n线程B工作内存中对count执行了+1操作，但是未刷新之主内存中\n此时CPU的执行权切换到了A线程上，由于此时线程B没有将工作内存中的数据刷新到主内存，因此A线程工作内存中的变量值还是100，没有失效。A线程对工作内存中的数据进行了+1操作。\n线程B将101写入到主内存\n线程A将101写入到主内存\n虽然计算了2次，但是只对A进行了1次修改。\n4.3 volatile原子性测试 我们刚才说到了volatile在多线程环境下只保证了共享变量在多个线程间的可见性，但是不保证原子性。那么接下来我们就来做一个测试。测试的思想，就是使用volatile修饰count。\n线程类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class VolatileAtomicThread implements Runnable { // 定义一个int类型的变量,并且使用volatile修饰 private volatile int count = 0 ; @Override public void run() { // 对该变量进行++操作，100次 for(int x = 0 ; x \u0026lt; 100 ; x++) { count++ ;\tSystem.out.println(\u0026#34;count =========\u0026gt;\u0026gt;\u0026gt;\u0026gt; \u0026#34; + count); } } } 控制台输出结果(需要运行多次)\n1 2 3 4 ... count =========\u0026gt;\u0026gt;\u0026gt;\u0026gt; 9997 count =========\u0026gt;\u0026gt;\u0026gt;\u0026gt; 9998 count =========\u0026gt;\u0026gt;\u0026gt;\u0026gt; 9999 通过控制台结果的输出，我们可以看到程序还是会出现问题。因此也就证明volatile关键字是不保证原子性的。\n4.4 volatile使用场景 volatile关键字不保证原子性操作，那么同学们可能会存在一些疑问，volatile关键字在什么情况下进行使用呢？这里我们举两个基本的使用场景。\n4.4.1 状态标志 比如现在存在一个线程不断向控制台输出一段话\u0026quot;传智播客中国IT教育的标杆\u0026hellip;.\u0026quot;,当这个线程执行5秒以后，将该线程结束。\n实现思路：定义一个boolean类型的变量，这个变量就相当于一个标志。当这个变量的值为true的时候，线程一直执行，10秒以后我们把这个变量的值更改为false，此时结束该线程的执行。\n为了保证一个线程对这个变量的修改，另外一个线程立马可以看到，这个变量就需要通过volatile关键字进行修饰。\n线程类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class VolatileUseThread implements Runnable { // 定义标志变量 private volatile boolean shutdown = false ; @Override public void run() { while(!shutdown) { System.out.println(\u0026#34;传智播客中国IT教育的标杆....\u0026#34;); } } // 关闭线程 public void shutdown() { this.shutdown = true ; } } 测试类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class VolatileUseThreadDemo01 { public static void main(String[] args) throws InterruptedException { // 创建线程任务类对象 VolatileUseThread volatileUseThread = new VolatileUseThread() ; // 创建线程对象 Thread thread = new Thread(volatileUseThread); // 启动线程 thread.start(); // 主线程休眠 TimeUnit.SECONDS.sleep(5); // 关闭线程 volatileUseThread.shutdown(); } } 观察控制台输出，volatileUseThread线程执行5秒以后程序结束。\n4.4.2 独立观察 //AI养猪。。。。\n//设备区测量温度\n//当温度高了。。。需要给猪开空调。。。加冰棍。。。加喝的水。。。\nvolatile的另一种简单使用场景是：定期\u0026quot;发布\u0026quot;观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器数据，并更新包\n含这个volatile变量的值。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。这种使用就是多个线程操作共享变量，但是是有一个线程对其进行写操作，其他的线程都是读。\n我们可以设计一个程序，模拟上面的温度传感器案例。\n实现步说明\n定义一个温度传感器(TemperatureSensor)的类,在该类中定义两个成员变量(temperature(温度值)，type(传感器的类型))，temperature变量需要被volatile修饰\n定义一个读取温度传感器的线程的任务类(ReadTemperatureRunnable)，该类需要定义一个TemperatureSensor类型的成员变量(该线程需要读取温度传感器的数据)\n定义一个定时采集温度的线程任务类(GatherTemperatureRunnable)，该类需要定义一个TemperatureSensor类型的成员变量(该线程需要将读到的温度设置给传感器)\n创建测试类(TemperatureSensorDemo)\n创建TemperatureSensor对象 创建ReadTemperatureRunnable类对象，把TemperatureSensor作为构造方法的参数传递过来 创建GatherTemperatureRunnable类对象，把TemperatureSensor作为构造方法的参数传递过来 创建2个Thread对象，并启动，把第二步所创建的对象作为构造方法参数传递过来，这两个线程负责读取TemperatureSensor中的温度数据 创建1个Thread对象，并启动，把第三步所创建的对象作为构造方法参数传递过来，这个线程负责读取定时采集数据中的温度数据 TemperatureSensor类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class TemperatureSensor { // 温度传感器类 private volatile int temperature ; // 温度值 private String type ; // 传感器的类型 public int getTemperature() { return temperature; } public void setTemperature(int temperature) { this.temperature = temperature; } public String getType() { return type; } public void setType(String type) { this.type = type; } } ReadTemperatureRunnable类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class ReadTemperatureRunnable implements Runnable { // 温度传感器 private TemperatureSensor temperatureSensor ; public ReadTemperatureRunnable(TemperatureSensor temperatureSensor) { this.temperatureSensor = temperatureSensor ; } @Override public void run() { // 不断的读取温度传感器中的数据 while(true) { // 读取数据 System.out.println(Thread.currentThread().getName() + \u0026#34;---读取到的温度数据为------\u0026gt;\u0026gt;\u0026gt; \u0026#34; + temperatureSensor.getTemperature()); try { // 让线程休眠100毫秒，便于观察 TimeUnit.MILLISECONDS.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } } } GatherTemperatureRunnable类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class GatherTemperatureRunnable implements Runnable { // 温度传感器 private TemperatureSensor temperatureSensor ; public GatherTemperatureRunnable(TemperatureSensor temperatureSensor) { this.temperatureSensor = temperatureSensor ; } @Override public void run() { // 定义一个变量，表示环境初始温度 int temperature = 23 ; // 不断进行数据采集 while(true) { // 将采集到的数据设置给温度传感器 System.out.println(Thread.currentThread().getName() + \u0026#34;-----采集到的数据为-----\u0026gt;\u0026gt;\u0026gt; \u0026#34; + temperature); temperatureSensor.setTemperature(temperature); try { // 线程休眠2秒,模拟每隔两秒采集一次数据 TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } // 环境温度改变 temperature += 2 ; } } } 测试类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class TemperatureSensorDemo { public static void main(String[] args) { // 创建TemperatureSensor对象 TemperatureSensor temperatureSensor = new TemperatureSensor(); // 创建ReadTemperatureRunnable类对象 ReadTemperatureRunnable readTemperatureRunnable = new ReadTemperatureRunnable(temperatureSensor) ; // 创建GatherTemperatureRunnable类对象 GatherTemperatureRunnable gatherTemperatureRunnable = new GatherTemperatureRunnable(temperatureSensor) ; // 创建2个Thread对象，并启动; 这两个线程负责读取TemperatureSensor中的温度数据 for(int x = 0 ; x \u0026lt; 2 ; x++) { new Thread(readTemperatureRunnable).start(); } // 创建1个Thread对象，并启动，这个线程负责读取定时采集数据中的温度数据 Thread gatherThread = new Thread(gatherTemperatureRunnable); gatherThread.setName(\u0026#34;温度采集线程\u0026#34;); gatherThread.start(); } } 控制台输出结果\n1 2 3 4 5 6 7 ... 温度采集线程-----采集到的数据为-----\u0026gt;\u0026gt;\u0026gt; 23 Thread-0---读取到的温度数据为------\u0026gt;\u0026gt;\u0026gt; 23 ... 温度采集线程-----采集到的数据为-----\u0026gt;\u0026gt;\u0026gt; 25 Thread-1---读取到的温度数据为------\u0026gt;\u0026gt;\u0026gt; 25 ... 通过控制台的输出，我们可以看到当温度采集线程刚采集到环境温度以后，那么此时两个温度读取线程就可以立即感知到环境温度的变化。\n4.5 问题处理 接下来我们就来讲解一下我们上述案例(引入原子性问题的案例)的解决方案。\n4.5.1 锁机制 我们可以给count++操作添加锁，那么count++操作就是临界区中的代码，临界区中的代码一次只能被一个线程去执行，所以count++就变成了原子操作。\n线程任务类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class VolatileAtomicThread implements Runnable { // 定义一个int类型的变量, private int count = 0 ; // 定义一个Object类型的变量，该变量将作为同步代码块的锁 private Object obj = new Object(); @Override public void run() { // 对该变量进行++操作，100次 for(int x = 0 ; x \u0026lt; 100 ; x++) { synchronized (obj){ count++ ; System.out.println(\u0026#34;count =========\u0026gt;\u0026gt;\u0026gt;\u0026gt; \u0026#34; + count); } } } } 控制台输出结果\n1 2 3 count =========\u0026gt;\u0026gt;\u0026gt;\u0026gt; 9998 count =========\u0026gt;\u0026gt;\u0026gt;\u0026gt; 9999 count =========\u0026gt;\u0026gt;\u0026gt;\u0026gt; 10000 4.5.2 原子类 1) AtomicInteger 概述：java从JDK1.5开始提供了java.util.concurrent.atomic包(简称Atomic包)，这个包中的原子操作类提供了一种用法简单，性能高效，线程安全地更新一个变量的方式。因为变\n量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性(字段)。本次我们只讲解\n使用原子的方式更新基本类型，使用原子的方式更新基本类型Atomic包提供了以下3个类：\nAtomicBoolean： 原子更新布尔类型\nAtomicInteger： 原子更新整型\nAtomicLong：\t原子更新长整型\n以上3个类提供的方法几乎一模一样，所以本节仅以AtomicInteger为例进行讲解，AtomicInteger的常用方法如下：\n1 2 3 4 5 6 7 8 public AtomicInteger()：\t初始化一个默认值为0的原子型Integer public AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integer int get(): 获取值 int getAndIncrement(): 以原子方式将当前值加1，注意，这里返回的是自增前的值。 int incrementAndGet(): 以原子方式将当前值加1，注意，这里返回的是自增后的值。 int addAndGet(int data):\t以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。 int getAndSet(int value): 以原子方式设置为newValue的值，并返回旧值。 案例演示AtomicInteger的基本使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class AtomicIntegerDemo01 { // 原子型Integer public static void main(String[] args) { // 构造方法 // public AtomicInteger()：初始化一个默认值为0的原子型Integer // AtomicInteger atomicInteger = new AtomicInteger() ; // System.out.println(atomicInteger); // public AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integer AtomicInteger atomicInteger = new AtomicInteger(5) ; System.out.println(atomicInteger); // 获取值 System.out.println(atomicInteger.get()); // 以原子方式将当前值加1，这里返回的是自增前的值 System.out.println(atomicInteger.getAndIncrement()); System.out.println(atomicInteger.get()); // 以原子方式将当前值加1，这里返回的是自增后的值 System.out.println(atomicInteger.incrementAndGet()); // 以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果 System.out.println(atomicInteger.addAndGet(8)); // 以原子方式设置为newValue的值，并返回旧值 System.out.println(atomicInteger.getAndSet(20)); System.out.println(atomicInteger.get()); } } 2) 案例改造 使用AtomicInteger对案例进行改造。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class VolatileAtomicThread implements Runnable { // 定义一个int类型的变量 private AtomicInteger atomicInteger = new AtomicInteger() ; @Override public void run() { // 对该变量进行++操作，100次 for(int x = 0 ; x \u0026lt; 100 ; x++) { int i = atomicInteger.incrementAndGet(); System.out.println(\u0026#34;count =========\u0026gt;\u0026gt;\u0026gt;\u0026gt; \u0026#34; + i); } } } 控制台输出结果\n1 2 3 4 ... count =========\u0026gt;\u0026gt;\u0026gt;\u0026gt; 9998 count =========\u0026gt;\u0026gt;\u0026gt;\u0026gt; 9999 count =========\u0026gt;\u0026gt;\u0026gt;\u0026gt; 10000 通过控制台的执行结果，我们可以看到最终得到的结果就是10000，因此也就证明AtomicInteger所提供的方法是原子性操作方法。\n4.6 AtomicInteger原理 4.6.1 原理介绍 AtomicInteger的本质：自旋锁 + CAS算法\nCAS的全成是： Compare And Swap(比较再交换); 是现代CPU广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。CAS可以将read-modify-write转换为原子操作，这个原子操作\n直接由处理器保证。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当旧预期值A和内存值V相同时，将内存值V修改为B并返回true，否则什么都不做，并返回false。\n举例说明：\n在内存值V当中，存储着值为10的变量。 此时线程1想要把变量的值增加1。对线程1来说，旧的预期值 A = 10 ，要修改的新值 B = 11。 在线程1要提交更新之前，另一个线程2抢先一步，把内存值V中的变量值率先更新成了11。 线程1开始提交更新，首先进行A和内存值V的实际值比较（Compare），发现A不等于V的值，提交失败。 线程1重新获取内存值V作为当前A的值，并重新计算想要修改的新值。此时对线程1来说，A = 11，B = 12。这个重新尝试的过程被称为自旋。 这一次比较幸运，没有其他线程改变V的值。线程1进行Compare，发现A和V的值是相等的。 线程1进行SWAP，把内存V的值替换为B，也就是12。 举例说明：这好比春节的时候抢火车票，下手快的会抢先买到票，而下手慢的可以再次尝试，直到买到票。\n4.6.2 源码分析 那么接下来我们就来查看一下AtomicInteger类中incrementAndGet方法的源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class AtomicInteger extends Number implements java.io.Serializable { // cas算法的实现类 private static final jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe(); // 表示变量值在内存中的偏移量地址，unsafe类就是根据内存偏移量地址获取数据值。 private static final long VALUE = U.objectFieldOffset(AtomicInteger.class, \u0026#34;value\u0026#34;); private volatile int value; // 以原子方式将当前值加1，这里返回的是自增后的值 public final int incrementAndGet() { /* this表示当前AtomicInteger对象 ，1表示要增加的值 */ return U.getAndAddInt(this, VALUE, 1) + 1;\t// 调用Unsafe类中的getAndAddInt方法 } } UnSafe类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public final class Unsafe { // Unsafe类中的getAndAddInt方法 public final int getAndAddInt(Object o, long offset, int delta) { int v; // do...while就是自旋操作,当CAS成功以后，循环结束 do { // 获取AtomicInteger类中所封装的int类型的值，就相当于旧的预期值A v = getIntVolatile(o, offset); // 调用本类的weakCompareAndSetInt方法实现比较在交换； o: AtomicInteger对象, v: 相当于旧的预期值A, v + delta：新值B } while (!weakCompareAndSetInt(o, offset, v, v + delta)); return v; } // Unsafe类中的weakCompareAndSetInt方法 public final boolean weakCompareAndSetInt(Object o, long offset, int expected, int x) { return compareAndSetInt(o, offset, expected, x); } // 本地方法，调用CPU指令实现CAS public final native boolean compareAndSetInt(Object o, long offset, int expected, int x); } 4.7 CAS与Synchronized CAS和Synchronized都可以保证多线程环境下共享数据的安全性。那么他们两者有什么区别？\nSynchronized是从悲观的角度出发：\n总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线\n程阻塞，用完后再把资源转让给其它线程）。因此Synchronized我们也将其称之为悲观锁。jdk中的ReentrantLock也是一种悲观锁。\nCAS是从乐观的角度出发:\n总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。CAS这种机制我们也可以将其称之为乐观锁。\n5 并发工具类 在JDK的并发包里提供了几个非常有用的并发容器和并发工具类。供我们在多线程开发中进行使用。\n5.1 ConcurrentHashMap 5.1.1 概述以及基本使用 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。\n基于以上两个原因我们可以使用JDK1.5以后所提供的ConcurrentHashMap。\n案例1：演示HashMap线程不安全\n实现步骤\n创建一个HashMap集合对象 创建两个线程对象，第一个线程对象向集合中添加元素(1-24),第二个线程对象向集合中添加元素(25-50); 主线程休眠1秒，以便让其他两个线程将数据填装完毕 从集合中找出键和值不相同的数据 测试类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 public class HashMapDemo01 { public static void main(String[] args) { // 创建一个HashMap集合对象 HashMap\u0026lt;String , String\u0026gt; hashMap = new HashMap\u0026lt;String , String\u0026gt;() ; // 创建两个线程对象,我们本次使用匿名内部类的方式去常见线程对象 Thread t1 = new Thread() { @Override public void run() { // 第一个线程对象向集合中添加元素(1-24) for(int x = 1 ; x \u0026lt; 25 ; x++) { hashMap.put(String.valueOf(x) , String.valueOf(x)) ; } } }; // 线程t2 Thread t2 = new Thread() { @Override public void run() { // 第二个线程对象向集合中添加元素(25-50) for(int x = 25 ; x \u0026lt; 51 ; x++) { hashMap.put(String.valueOf(x) , String.valueOf(x)) ; } } }; // 启动线程 t1.start(); t2.start(); System.out.println(\u0026#34;----------------------------------------------------------\u0026#34;); try { // 主线程休眠2s，以便让其他两个线程将数据填装完毕 TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } // 从集合中找出键和值不相同的数据 for(int x = 1 ; x \u0026lt; 51 ; x++) { // HashMap中的键就是当前循环变量的x这个数据的字符串表现形式 ， 根据键找到值，然后在进行判断 if( !String.valueOf(x).equals( hashMap.get(String.valueOf(x)) ) ) { System.out.println(String.valueOf(x) + \u0026#34;:\u0026#34; + hashMap.get(String.valueOf(x))); } } } } 控制台输出结果\n1 2 ---------------------------------------------------------- 5:null 通过控制台的输出结果，我们可以看到在多线程操作HashMap的时候，可能会出现线程安全问题。\n注1：需要多次运行才可以看到具体的效果; 可以使用循环将代码进行改造，以便让问题方便的暴露出来！\n案例2：演示Hashtable线程安全\n测试类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 public class HashtableDemo01 { public static void main(String[] args) { // 创建一个Hashtable集合对象 Hashtable\u0026lt;String , String\u0026gt; hashtable = new Hashtable\u0026lt;String , String\u0026gt;() ; // 创建两个线程对象,我们本次使用匿名内部类的方式去常见线程对象 Thread t1 = new Thread() { @Override public void run() { // 第一个线程对象向集合中添加元素(1-24) for(int x = 1 ; x \u0026lt; 25 ; x++) { hashtable.put(String.valueOf(x) , String.valueOf(x)) ; } } }; // 线程t2 Thread t2 = new Thread() { @Override public void run() { // 第二个线程对象向集合中添加元素(25-50) for(int x = 25 ; x \u0026lt; 51 ; x++) { hashtable.put(String.valueOf(x) , String.valueOf(x)) ; } } }; // 启动线程 t1.start(); t2.start(); System.out.println(\u0026#34;----------------------------------------------------------\u0026#34;); try { // 主线程休眠2s，以便让其他两个线程将数据填装完毕 TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } // 从集合中找出键和值不相同的数据 for(int x = 1 ; x \u0026lt; 51 ; x++) { // Hashtable中的键就是当前循环变量的x这个数据的字符串表现形式 ， 根据键找到值，然后在进行判断 if( !String.valueOf(x).equals( hashtable.get(String.valueOf(x)) ) ) { System.out.println(String.valueOf(x) + \u0026#34;:\u0026#34; + hashtable.get(String.valueOf(x))); } } } } 不论该程序运行多少次，都不会产生数据问题。因此也就证明Hashtable是线程安全的。\nHashtable保证线程安全的原理：\n查看Hashtable的源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Hashtable\u0026lt;K,V\u0026gt; extends Dictionary\u0026lt;K,V\u0026gt; implements Map\u0026lt;K,V\u0026gt;, Cloneable, java.io.Serializable { // Entry数组，一个Entry就相当于一个元素 private transient Entry\u0026lt;?,?\u0026gt;[] table; // Entry类的定义 private static class Entry\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; { final int hash;\t// 当前key的hash码值 final K key;\t// 键 V value;\t// 值 Entry\u0026lt;K,V\u0026gt; next;\t// 下一个节点 } // 存储数据 public synchronized V put(K key, V value){...} // 获取数据 public synchronized V get(Object key){...} // 获取长度 public synchronized int size(){...} ... } 对应的结构如下图所示\nHashtable保证线程安全性的是使用方法全局锁进行实现的。在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable\n的同步方法时，会进入阻塞状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。\n案例3：演示ConcurrentHashMap线程安全\n测试类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 public class ConcurrentHashMapDemo01 { public static void main(String[] args) { // 创建一个ConcurrentHashMap集合对象 ConcurrentHashMap\u0026lt;String , String\u0026gt; concurrentHashMap = new ConcurrentHashMap\u0026lt;String , String\u0026gt;() ; // 创建两个线程对象,我们本次使用匿名内部类的方式去常见线程对象 Thread t1 = new Thread() { @Override public void run() { // 第一个线程对象向集合中添加元素(1-24) for(int x = 1 ; x \u0026lt; 25 ; x++) { concurrentHashMap.put(String.valueOf(x) , String.valueOf(x)) ; } } }; // 线程t2 Thread t2 = new Thread() { @Override public void run() { // 第二个线程对象向集合中添加元素(25-50) for(int x = 25 ; x \u0026lt; 51 ; x++) { concurrentHashMap.put(String.valueOf(x) , String.valueOf(x)) ; } } }; // 启动线程 t1.start(); t2.start(); System.out.println(\u0026#34;----------------------------------------------------------\u0026#34;); try { // 主线程休眠2s，以便让其他两个线程将数据填装完毕 TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } // 从集合中找出键和值不相同的数据 for(int x = 1 ; x \u0026lt; 51 ; x++) { // concurrentHashMap中的键就是当前循环变量的x这个数据的字符串表现形式 ， 根据键找到值，然后在进行判断 if( !String.valueOf(x).equals( concurrentHashMap.get(String.valueOf(x)) ) ) { System.out.println(String.valueOf(x) + \u0026#34;:\u0026#34; + concurrentHashMap.get(String.valueOf(x))); } } } } 不论该程序运行多少次，都不会产生数据问题。因此也就证明ConcurrentHashMap是线程安全的。\n5.1.2 源码分析 由于ConcurrentHashMap在jdk1.7和jdk1.8的时候实现原理不太相同，因此需要分别来讲解一下两个不同版本的实现原理。\n1) jdk1.7版本 ConcurrentHashMap中的重要成员变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class ConcurrentHashMap\u0026lt;K, V\u0026gt; extends AbstractMap\u0026lt;K, V\u0026gt; implements ConcurrentMap\u0026lt;K, V\u0026gt;, Serializable { /** * Segment翻译中文为\u0026#34;段\u0026#34; , 段数组对象 */ final Segment\u0026lt;K,V\u0026gt;[] segments; // Segment是一种可重入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色，将一个大的table分割成多个小的table进行加锁。 static final class Segment\u0026lt;K,V\u0026gt; extends ReentrantLock implements Serializable { transient volatile int count; // Segment中元素的数量，由volatile修饰，支持内存可见性； transient int modCount;\t// 对table的大小造成影响的操作的数量（比如put或者remove操作）; transient int threshold;\t// 扩容阈值; transient volatile HashEntry\u0026lt;K,V\u0026gt;[] table; // 链表数组，数组中的每一个元素代表了一个链表的头部; final float loadFactor;\t// 负载因子 } // Segment中的元素是以HashEntry的形式存放在数组中的，其结构与普通HashMap的HashEntry基本一致，不同的是Segment的HashEntry，其value由\t// volatile修饰，以支持内存可见性，即写操作对其他读线程即时可见。 static final class HashEntry\u0026lt;K,V\u0026gt; { final int hash;\t// 当前节点key对应的哈希码值 final K key;\t// 存储键 volatile V value;\t// 存储值 volatile HashEntry\u0026lt;K,V\u0026gt; next;\t// 下一个节点 } } 对应的结构如下图所示\n简单来讲，就是ConcurrentHashMap比HashMap多了一次hash过程，第1次hash定位到Segment，第2次hash定位到HashEntry，然后链表搜索找到指定节点。在进行写操作时，只需锁住写\n元素所在的Segment即可(这种锁被称为分段锁)，其他Segment无需加锁，从而产生锁竞争的概率大大减小，提高了并发读写的效率。该种实现方式的缺点是hash过程比普通的HashMap要长\n(因为需要进行两次hash操作)。\nConcurrentHashMap的put方法源码分析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 public class ConcurrentHashMap\u0026lt;K, V\u0026gt; extends AbstractMap\u0026lt;K, V\u0026gt; implements ConcurrentMap\u0026lt;K, V\u0026gt;, Serializable { public V put(K key, V value) { // 定义一个Segment对象 Segment\u0026lt;K,V\u0026gt; s; // 如果value的值为空，那么抛出异常 if (value == null) throw new NullPointerException(); // hash函数获取key的hashCode，然后做了一些处理 int hash = hash(key); // 通过key的hashCode定位segment int j = (hash \u0026gt;\u0026gt;\u0026gt; segmentShift) \u0026amp; segmentMask; // 对定位的Segment进行判断，如果Segment为空，调用ensureSegment进行初始化操作(第一次hash定位) if ((s = (Segment\u0026lt;K,V\u0026gt;)UNSAFE.getObject(segments, (j \u0026lt;\u0026lt; SSHIFT) + SBASE)) == null) s = ensureSegment(j); // 调用Segment对象的put方法添加元素 return s.put(key, hash, value, false); } // Segment是一种可ReentrantLock，在ConcurrentHashMap里扮演锁的角色，将一个大的table分割成多个小的table进行加锁。 static final class Segment\u0026lt;K,V\u0026gt; extends ReentrantLock implements Serializable { // 添加元素 final V put(K key, int hash, V value, boolean onlyIfAbsent) { // 尝试对该段进行加锁,如果加锁失败，则调用scanAndLockForPut方法;在该方法中就要进行再次尝试或者进行自旋等待 HashEntry\u0026lt;K,V\u0026gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value); V oldValue; try { // 获取HashEntry数组对象 HashEntry\u0026lt;K,V\u0026gt;[] tab = table; // 根据key的hashCode值计算索引(第二次hash定位) int index = (tab.length - 1) \u0026amp; hash; HashEntry\u0026lt;K,V\u0026gt; first = entryAt(tab, index); for (HashEntry\u0026lt;K,V\u0026gt; e = first;;) // 若不为null if (e != null) { K k; // 判读当前节点的key是否和链表头节点的key相同(依赖于hashCode方法和equals方法) // 如果相同，值进行更新 if ((k = e.key) == key || (e.hash == hash \u0026amp;\u0026amp; key.equals(k))) { oldValue = e.value; if (!onlyIfAbsent) { e.value = value; ++modCount; } break; } e = e.next; } else { // 若头结点为null // 将新节点添加到链表中 if (node != null) node.setNext(first); else node = new HashEntry\u0026lt;K,V\u0026gt;(hash, key, value, first); int c = count + 1; // 如果超过阈值，则进行rehash操作 if (c \u0026gt; threshold \u0026amp;\u0026amp; tab.length \u0026lt; MAXIMUM_CAPACITY) rehash(node); else setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; } } } finally { unlock(); } return oldValue; } } } 注：源代码进行简单讲解即可(核心：进行了两次哈希定位以及加锁过程)\n2) jdk1.8版本 在JDK1.8中为了进一步优化ConcurrentHashMap的性能，去掉了Segment分段锁的设计。在数据结构方面，则是跟HashMap一样，使用一个哈希表table数组。(数组 + 链表 + 红黑树)\n而线程安全方面是结合CAS机制 + 局部锁实现的，减低锁的粒度，提高性能。同时在HashMap的基础上，对哈希表table数组和链表节点的value，next指针等使用volatile来修饰，从而\n实现线程可见性。\nConcurrentHashMap中的重要成员变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class ConcurrentHashMap\u0026lt;K,V\u0026gt; extends AbstractMap\u0026lt;K,V\u0026gt; implements ConcurrentMap\u0026lt;K,V\u0026gt;, Serializable { // Node数组 transient volatile Node\u0026lt;K,V\u0026gt;[] table; // Node类的定义 static class Node\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; { final int hash;\t// 当前key的hashCode值 final K key;\t// 键 volatile V val;\t// 值 volatile Node\u0026lt;K,V\u0026gt; next;\t// 下一个节点 } // TreeNode类的定义 static final class TreeNode\u0026lt;K,V\u0026gt; extends Node\u0026lt;K,V\u0026gt; { TreeNode\u0026lt;K,V\u0026gt; parent; // 父节点 TreeNode\u0026lt;K,V\u0026gt; left;\t// 左子节点 TreeNode\u0026lt;K,V\u0026gt; right; // 右子节点 TreeNode\u0026lt;K,V\u0026gt; prev; // needed to unlink next upon deletion boolean red;\t// 节点的颜色状态 } } 对应的结构如下图\nConcurrentHashMap的put方法源码分析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 public class ConcurrentHashMap\u0026lt;K,V\u0026gt; extends AbstractMap\u0026lt;K,V\u0026gt; implements ConcurrentMap\u0026lt;K,V\u0026gt;, Serializable { // 添加元素 public V put(K key, V value) { return putVal(key, value, false); } // putVal方法定义 final V putVal(K key, V value, boolean onlyIfAbsent) { // key为null直接抛出异常 if (key == null || value == null) throw new NullPointerException(); // 计算key所对应的hashCode值 int hash = spread(key.hashCode()); int binCount = 0; for (Node\u0026lt;K,V\u0026gt;[] tab = table;;) { Node\u0026lt;K,V\u0026gt; f; int n, i, fh; // 哈希表如果不存在，那么此时初始化哈希表 if (tab == null || (n = tab.length) == 0) tab = initTable(); // 通过hash值计算key在table表中的索引，将其值赋值给变量i,然后根据索引找到对应的Node，如果Node为null,做出处理 else if ((f = tabAt(tab, i = (n - 1) \u0026amp; hash)) == null) { // 新增链表头结点，cas方式添加到哈希表table if (casTabAt(tab, i, null, new Node\u0026lt;K,V\u0026gt;(hash, key, value, null))) break; } else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else { V oldVal = null; // f为链表头结点，使用synchronized加锁 synchronized (f) { if (tabAt(tab, i) == f) { if (fh \u0026gt;= 0) { binCount = 1; for (Node\u0026lt;K,V\u0026gt; e = f;; ++binCount) { K ek; // 节点已经存在，更新value即可 if (e.hash == hash \u0026amp;\u0026amp; ((ek = e.key) == key || (ek != null \u0026amp;\u0026amp; key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } // 该key对应的节点不存在,则新增节点并添加到该链表的末尾 Node\u0026lt;K,V\u0026gt; pred = e; if ((e = e.next) == null) { pred.next = new Node\u0026lt;K,V\u0026gt;(hash, key, value, null); break; } } } else if (f instanceof TreeBin) { // 红黑树节点，则往该红黑树更新或添加该节点即可 Node\u0026lt;K,V\u0026gt; p; binCount = 2; if ((p = ((TreeBin\u0026lt;K,V\u0026gt;)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } } } // 判断是否需要将链表转为红黑树 if (binCount != 0) { if (binCount \u0026gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; } } } addCount(1L, binCount); return null; } // CAS算法的核心类 private static final sun.misc.Unsafe U; static { try { U = sun.misc.Unsafe.getUnsafe(); ... } catch (Exception e) { throw new Error(e); } } // 原子获取链表节点 static final \u0026lt;K,V\u0026gt; Node\u0026lt;K,V\u0026gt; tabAt(Node\u0026lt;K,V\u0026gt;[] tab, int i) { return (Node\u0026lt;K,V\u0026gt;)U.getObjectVolatile(tab, ((long)i \u0026lt;\u0026lt; ASHIFT) + ABASE); } // CAS更新或新增链表节点 static final \u0026lt;K,V\u0026gt; boolean casTabAt(Node\u0026lt;K,V\u0026gt;[] tab, int i, Node\u0026lt;K,V\u0026gt; c, Node\u0026lt;K,V\u0026gt; v) { return U.compareAndSwapObject(tab, ((long)i \u0026lt;\u0026lt; ASHIFT) + ABASE, c, v); } } 简单总结：\n如果当前需要put的key对应的链表在哈希表table中还不存在，即还没添加过该key的hash值对应的链表，则调用casTabAt方法，基于CAS机制来实现添加该链表头结点到哈希表\ntable中，避免该线程在添加该链表头结的时候，其他线程也在添加的并发问题；如果CAS失败，则进行自旋，通过继续第2步的操作；\n如果需要添加的链表已经存在哈希表table中，则通过tabAt方法，基于volatile机制，获取当前最新的链表头结点f，由于f指向的是ConcurrentHashMap的哈希表table的某条\n链表的头结点，故虽然f是临时变量，由于是引用共享的该链表头结点，所以可以使用synchronized关键字来同步多个线程对该链表的访问。在synchronized(f)同步块里面则是与\nHashMap一样遍历该链表，如果该key对应的链表节点已经存在，则更新，否则在链表的末尾新增该key对应的链表节点。\n5.2 CountDownLatch CountDownLatch允许一个或多个线程等待其他线程完成操作以后，再执行当前线程；比如我们在主线程需要开启2个其他线程，当其他的线程执行完毕以后我们再去执行主线程，针对这\n个需求我们就可以使用CountDownLatch来进行实现。CountDownLatch中count down是倒着数数的意思；CountDownLatch是通过一个计数器来实现的，每当一个线程完成了自己的\n任务后，可以调用countDown()方法让计数器-1，当计数器到达0时，调用CountDownLatch的await()方法的线程阻塞状态解除，继续执行。\nCountDownLatch的相关方法\n1 2 3 public CountDownLatch(int count)\t// 初始化一个指定计数器的CountDownLatch对象 public void await() throws InterruptedException\t// 让当前线程等待 public void countDown()\t// 计数器进行减1 案例演示：使用CountDownLatch完成上述需求(我们在主线程需要开启2个其他线程，当其他的线程执行完毕以后我们再去执行主线程)\n实现思路：在main方法中创建一个CountDownLatch对象，把这个对象作为作为参数传递给其他的两个任务线程\n线程任务类1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class CountDownLatchThread01 implements Runnable { // CountDownLatch类型成员变量 private CountDownLatch countDownLatch ; public CountDownLatchThread01(CountDownLatch countDownLatch) { // 构造方法的作用：接收CountDownLatch对象 this.countDownLatch = countDownLatch ; } @Override public void run() { try { Thread.sleep(10000); System.out.println(\u0026#34;10秒以后执行了CountDownLatchThread01......\u0026#34;); } catch (InterruptedException e) { e.printStackTrace(); } // 调用CountDownLatch对象的countDown方法对计数器进行-1操作 countDownLatch.countDown(); } } 线程任务类2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class CountDownLatchThread02 implements Runnable { // CountDownLatch类型成员变量 private CountDownLatch countDownLatch ; public CountDownLatchThread02(CountDownLatch countDownLatch) { // 构造方法的作用：接收CountDownLatch对象 this.countDownLatch = countDownLatch ; } @Override public void run() { try { Thread.sleep(3000); System.out.println(\u0026#34;3秒以后执行了CountDownLatchThread02......\u0026#34;); } catch (InterruptedException e) { e.printStackTrace(); } // 调用CountDownLatch对象的countDown方法对计数器进行-1操作 countDownLatch.countDown(); } } 测试类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class CountDownLatchDemo01 { public static void main(String[] args) { // 1. 创建一个CountDownLatch对象 CountDownLatch countDownLatch = new CountDownLatch(2) ; // CountDownLatch中的计数器的默认值就是2 // 2. 创建线程任务类对象，并且把这个CountDownLatch对象作为构造方法的参数进行传递 CountDownLatchThread01 countDownLatchThread01 = new CountDownLatchThread01(countDownLatch) ; // 3. 创建线程任务类对象，并且把这个CountDownLatch对象作为构造方法的参数进行传递 CountDownLatchThread02 countDownLatchThread02 = new CountDownLatchThread02(countDownLatch) ; // 4. 创建线程对象，并启动线程 Thread t1 = new Thread(countDownLatchThread01); Thread t2 = new Thread(countDownLatchThread02); t1.start(); t2.start(); // 5. 在主线程中调用 CountDownLatch中的await让主线程处于阻塞状态 try { countDownLatch.await(); } catch (InterruptedException e) { e.printStackTrace(); } // 6. 程序结束的输出 System.out.println(\u0026#34;主线程执行了.... 程序结束了......\u0026#34;); } } 控制台输出结果\n1 2 3 3秒以后执行了CountDownLatchThread02...... 10秒以后执行了CountDownLatchThread01...... 主线程执行了.... 程序结束了...... CountDownLatchThread02线程先执行完毕，此时计数器-1；CountDownLatchThread01线程执行完毕，此时计数器-1；当计数器的值为0的时候，主线程阻塞状态接触，主线程向下执行。\n5.3 CyclicBarrier 5.3.1 概述以及基本使用 CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障\n才会开门，所有被屏障拦截的线程才会继续运行。\n例如：公司召集5名员工开会，等5名员工都到了，会议开始。我们创建5个员工线程，1个开会线程，几乎同时启动，使用CyclicBarrier保证5名员工线程全部执行后，再执行开会线程。\nCyclicBarrier的相关方法\n1 2 public CyclicBarrier(int parties, Runnable barrierAction) // 用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景 public int await()\t// 每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞 案例演示：模拟员工开会\n实现步骤：\n创建一个员工线程类(EmployeeThread),该线程类中需要定义一个CyclicBarrier类型的形式参数 创建一个开会线程类(MettingThread) 测试类 创建CyclicBarrier对象 创建5个EmployeeThread线程对象，把第一步创建的CyclicBarrier对象作为构造方法参数传递过来 启动5个员工线程 员工线程类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class EmployeeThread extends Thread { // CyclicBarrier类型的成员变量 private CyclicBarrier cyclicBarrier ; public EmployeeThread(CyclicBarrier cyclicBarrier) { // 使用构造方法对CyclicBarrier进行初始化 this.cyclicBarrier = cyclicBarrier ; } @Override public void run() { try { // 模拟开会人员的随机到场 Thread.sleep((int) (Math.random() * 1000)); System.out.println(Thread.currentThread().getName() + \u0026#34; 到了! \u0026#34;); cyclicBarrier.await(); } catch (Exception e) { e.printStackTrace(); } } } 开会线程类\n1 2 3 4 5 6 7 8 public class MettingThread extends Thread { @Override public void run() { System.out.println(\u0026#34;好了，人都到了，开始开会......\u0026#34;); } } 测试类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class CyclicBarrierDemo01 { public static void main(String[] args) { // 创建CyclicBarrier对象 CyclicBarrier cyclicBarrier = new CyclicBarrier(5 , new MettingThread()) ; // 创建5个EmployeeThread线程对象，把第一步创建的CyclicBarrier对象作为构造方法参数传递过来 EmployeeThread thread1 = new EmployeeThread(cyclicBarrier) ; EmployeeThread thread2 = new EmployeeThread(cyclicBarrier) ; EmployeeThread thread3 = new EmployeeThread(cyclicBarrier) ; EmployeeThread thread4 = new EmployeeThread(cyclicBarrier) ; EmployeeThread thread5 = new EmployeeThread(cyclicBarrier) ; // 启动5个员工线程 thread1.start(); thread2.start(); thread3.start(); thread4.start(); thread5.start(); } } 5.3.2 使用场景 使用场景：CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。\n比如：现在存在两个文件，这个两个文件中存储的是某一个员工两年的工资信息(一年一个文件)，现需要对这两个文件中的数据进行汇总；使用两个线程读取2个文件中的数据，当两个文\n件中的数据都读取完毕以后，进行数据的汇总操作。\n分析：要想在两个线程读取数据完毕以后进行数据的汇总，那么我们就需要定义一个任务类(该类需要实现Runnable接口)；两个线程读取完数据以后再进行数据的汇总，那么我们可以将\n​\t两个线程读取到的数据先存储到一个集合中，而多线程环境下最常见的线程集合类就是ConcurrentHashMap，而这个集合需要被两个线程都可以进行使用，那么我们可以将这个集\n​\t合作为我们任务类的成员变量，然后我们在这个任务类中去定义一个CyclicBarrier对象，然后在定义一个方法(count)，当调用这个count方法的时候需要去开启两个线程对象，\n​\t使用这两个线程对象读取数据，把读取到的数据存储到ConcurrentHashMap对象，当一个线程读取数据完毕以后，调用CyclicBarrier的awit方法(告诉CyclicBarrier我已经\n​\t到达了屏障)，然后在任务类的run方法对ConcurrentHashMap的数据进行汇总操作；\n实现步骤:\n定义一个任务类CyclicBarrierThreadUse(实现了Runnable接口) 定义成员变量：CyclicBarrier ，ConcurrentHashMap 1 2 private CyclicBarrier cyclicBarrier = new CyclicBarrier(2 , this) ; private ConcurrentHashMap\u0026lt;Integer , String\u0026gt; concurrentHashMap = new ConcurrentHashMap\u0026lt;Integer , String\u0026gt;() ; 定义一个方法count方法，在count方法中开启两个线程对象(可以使用匿名内部类的方式实现) 在run方法中对ConcurrentHashMap中的数据进行汇总 编写测试类CyclicBarrierThreadUseDemo 创建CyclicBarrierThreadUse对象，调用count方法 任务类代代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 public class CyclicBarrierThreadUse implements Runnable { // 当前我们两个线程到达了屏障点以后，我们需要立即对数据进行汇总, 因此我们需要使用第二个构造方法 // 并且我们当前这个类就是一个任务类，因此我们可以直接传递参数this private CyclicBarrier cyclicBarrier = new CyclicBarrier(2 , this) ; private ConcurrentHashMap\u0026lt;Integer , String\u0026gt; concurrentHashMap = new ConcurrentHashMap\u0026lt;Integer , String\u0026gt;() ; // 存储两个线程所读取的数据 public void count() { // 定义一个方法count方法，在count方法中开启两个线程对象(可以使用匿名内部类的方式实现) // 线程1 new Thread(new Runnable() { @Override public void run() { // 读取数据 BufferedReader bufferedReader = null ; try { bufferedReader = new BufferedReader(new FileReader(\u0026#34;D:\\\\salary\\\\2017-salary.txt\u0026#34;)) ; String line = null ; while((line = bufferedReader.readLine()) != null) { concurrentHashMap.put(Integer.parseInt(line) , \u0026#34;\u0026#34;) ; // 小的问题，工资信息不能重复 } } catch (Exception e) { e.printStackTrace(); } finally { if(bufferedReader != null) { try { bufferedReader.close(); } catch (IOException e) { e.printStackTrace(); } } } // 模拟任务的执行时间 try { TimeUnit.SECONDS.sleep(5) ; System.out.println(Thread.currentThread().getName() + \u0026#34;---------------------线程读取数据完毕....\u0026#34;); cyclicBarrier.await() ; //通知cyclicBarrier当前线程已经到达了屏障点 } catch (Exception e) { e.printStackTrace(); } } }).start(); // 线程2 new Thread(new Runnable() { @Override public void run() { // 读取数据 BufferedReader bufferedReader = null ; try { bufferedReader = new BufferedReader(new FileReader(\u0026#34;D:\\\\salary\\\\2019-salary.txt\u0026#34;)) ; String line = null ; while((line = bufferedReader.readLine()) != null) { concurrentHashMap.put(Integer.parseInt(line) , \u0026#34;\u0026#34;) ; // 小的问题，工资信息不能重复 } } catch (Exception e) { e.printStackTrace(); } finally { if(bufferedReader != null) { try { bufferedReader.close(); } catch (IOException e) { e.printStackTrace(); } } } // 模拟任务的执行时间 try { TimeUnit.SECONDS.sleep(10) ; System.out.println(Thread.currentThread().getName() + \u0026#34;---------------------线程读取数据完毕....\u0026#34;); cyclicBarrier.await() ; //通知cyclicBarrier当前线程已经到达了屏障点 } catch (Exception e) { e.printStackTrace(); } } }).start(); } @Override public void run() { // 获取concurrentHashMap中的数据进行汇总 Enumeration\u0026lt;Integer\u0026gt; enumeration = concurrentHashMap.keys(); // 获取concurrentHashMap中所有的键 /** * 这个Enumeration的使用和我们之前所学习过的迭代器类似 * boolean hasMoreElements(); 判断集合中是否存在下一个元素 * E nextElement(); 获取元素 */ int result = 0 ; while(enumeration.hasMoreElements()) { Integer integer = enumeration.nextElement(); result += integer ; } // 输出 System.out.println(result); } } 测试类代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class CyclicBarrierThreadUseDemo01 { public static void main(String[] args) { // 创建任务类的对象 CyclicBarrierThreadUse cyclicBarrierThreadUse = new CyclicBarrierThreadUse(); // 调用count方法进行数据汇总 cyclicBarrierThreadUse.count(); } } 5.4 Semaphore Semaphore字面意思是信号量的意思，它的作用是控制访问特定资源的线程数目。\n举例：现在有一个十字路口，有多辆汽车需要进经过这个十字路口，但是我们规定同时只能有两辆汽车经过。其他汽车处于等待状态，只要某一个汽车经过了这个十字路口，其他的汽车才可以经\n过，但是同时只能有两个汽车经过。如何限定经过这个十字路口车辆数目呢? 我们就可以使用Semaphore。\nSemaphore的常用方法\n1 2 3 public Semaphore(int permits)\tpermits 表示许可线程的数量 public void acquire() throws InterruptedException\t表示获取许可 public void release()\t表示释放许可 案例演示：模拟汽车通过十字路口\n实现步骤：\n创建一个汽车的线程任务类(CarThreadRunnable),在该类中定义一个Semaphore类型的成员变量 创建测试类 创建线程任务类对象 创建5个线程对象，并启动。(5个线程对象，相当于5辆汽车) CarThreadRunnable类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class CarThreadRunnable implements Runnable { // 创建一个Semaphore对象,限制只允许2个线程获取到许可证 private Semaphore semaphore = new Semaphore(2) ; @Override public void run() { // 这个run只允许2个线程同时执行 try { // 获取许可证 semaphore.acquire(); System.out.println(Thread.currentThread().getName() + \u0026#34;-----\u0026gt;\u0026gt;正在经过十字路口\u0026#34;); // 模拟车辆经过十字路口所需要的时间 Random random = new Random(); int nextInt = random.nextInt(7); TimeUnit.SECONDS.sleep(nextInt); System.out.println(Thread.currentThread().getName() + \u0026#34;-----\u0026gt;\u0026gt;驶出十字路口\u0026#34;); // 释放许可证 semaphore.release(); } catch (InterruptedException e) { e.printStackTrace(); } } } 测试类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class SemaphoreDemo01 { public static void main(String[] args) { // 创建线程任务类对象 CarThreadRunnable carThreadRunnable = new CarThreadRunnable() ; // 创建5个线程对象，并启动。 for(int x = 0 ; x \u0026lt; 5 ; x++) { new Thread(carThreadRunnable).start(); } } } 控制台输出结果\n1 2 3 4 5 6 7 8 9 10 Thread-0-----\u0026gt;\u0026gt;正在经过十字路口 Thread-1-----\u0026gt;\u0026gt;正在经过十字路口 Thread-1-----\u0026gt;\u0026gt;驶出十字路口 Thread-2-----\u0026gt;\u0026gt;正在经过十字路口 Thread-0-----\u0026gt;\u0026gt;驶出十字路口 Thread-3-----\u0026gt;\u0026gt;正在经过十字路口 Thread-2-----\u0026gt;\u0026gt;驶出十字路口 Thread-4-----\u0026gt;\u0026gt;正在经过十字路口 Thread-4-----\u0026gt;\u0026gt;驶出十字路口 Thread-3-----\u0026gt;\u0026gt;驶出十字路口 通过控制台输出，我们可以看到当某一个汽车\u0026quot;驶出\u0026quot;十字路口以后，就会有一个汽车立马驶入。\n5.5 Exchanger 5.5.1 概述以及基本使用 Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。\n举例：比如男女双方结婚的时候，需要进行交换结婚戒指。\nExchanger常用方法\n1 2 public Exchanger()\t// 构造方法 public V exchange(V x)\t// 进行交换数据的方法，参数x表示本方数据 ，返回值v表示对方数据 这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，\n将本线程生产出来的数据传递给对方。\n案例演示：模拟交互结婚戒指\n实现步骤：\n创建一个男方的线程类(ManThread),定义一个Exchanger类型的成员变量 创建一个女方的线程类(WomanThread),定义一个Exchanger类型的成员变量 测试类 创建一个Exchanger对象 创建一个ManThread对象，把第一步所创建的Exchanger作为构造方法参数传递过来 创建一个WomanThread对象，把第一步所创建的Exchanger作为构造方法参数传递过来 启动两个线程 ManThread类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class ManThread extends Thread { // 定义Exchanger类型的变量 private Exchanger\u0026lt;String\u0026gt; exchanger ; private String name ; public ManThread(Exchange\u0026lt;String\u0026gt; exchanger , String name) { super(name); this.name = name ; this.exchanger = exchanger ; } @Override public void run() { try { String result = exchanger.exchange(\u0026#34;钻戒\u0026#34;); System.out.println(name + \u0026#34;----\u0026gt;\u0026gt;把钻戒给媳妇\u0026#34;); System.out.println(name + \u0026#34;----\u0026gt;\u0026gt;得到媳妇给的\u0026#34; + result); } catch (InterruptedException e) { e.printStackTrace(); } } } WomanThread类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class WomanThread extends Thread { // 定义Exchanger类型的变量 private Exchanger\u0026lt;String\u0026gt; exchanger ; private String name ; public WomanThread(Exchanger\u0026lt;String\u0026gt; exchanger , String name) { super(name) ; this.name = name ; this.exchanger = exchanger ; } @Override public void run() { try { String result = exchanger.exchange(\u0026#34;铝戒\u0026#34;); System.out.println(name + \u0026#34;----\u0026gt;\u0026gt;把铝戒给老公\u0026#34;); System.out.println(name + \u0026#34;----\u0026gt;\u0026gt;得到老公给的\u0026#34; + result); } catch (InterruptedException e) { e.printStackTrace(); } } } 测试类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ExchangerDemo01 { public static void main(String[] args) { // 创建一个Exchanger对象 Exchanger\u0026lt;String\u0026gt; exchanger = new Exchanger\u0026lt;String\u0026gt;() ; // 创建一个ManThread对象 ManThread manThread = new ManThread(exchanger , \u0026#34;杨过\u0026#34;) ; // 创建一个WomanThread对象 WomanThread womanThread = new WomanThread(exchanger , \u0026#34;小龙女\u0026#34;) ; // 启动线程 manThread.start(); womanThread.start(); } } 5.5.2 使用场景 使用场景：可以做数据校对工作\n比如: 现在存在一个文件，该文件中存储的是某一个员工一年的工资信息，现需要将这个员工的工资信息录入到系统中，采用AB岗两人进行录入，录入到两个文件中，系统需要加载这两\n个文件，并对两个文件数据进行校对，看看是否录入一致，\n实现步骤：\n创建一个测试类(ExchangerUseDemo) 通过匿名内部类的方法创建两个线程对象 两个线程分别读取文件中的数据，然后将数据存储到各自的集合中 当每一个线程读取完数据以后，就将数据交换给对方 然后每个线程使用对方传递过来的数据与自己所录入的数据进行比对 ExchangerUseDemo类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 public class ExchangerUseDemo { public static void main(String[] args) { // 1. 创建Exchanger对象 Exchanger\u0026lt;ArrayList\u0026lt;String\u0026gt;\u0026gt; exchanger = new Exchanger\u0026lt;ArrayList\u0026lt;String\u0026gt;\u0026gt;() ; // 2. 通过匿名内部类的方法创建两个线程对象 new Thread(new Runnable() { @Override public void run() { try { // 读取文件中的数据，然后将其存储到集合中 ArrayList\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;String\u0026gt;() ; BufferedReader bufferedReader = new BufferedReader(new FileReader(\u0026#34;D:\\\\salary\\\\2017-salary.txt\u0026#34;)) ; String line = null ; while((line = bufferedReader.readLine()) != null) { arrayList.add(line) ; } // arrayList.add(\u0026#34;90000\u0026#34;) ; // arrayList.set(0 , \u0026#34;90000\u0026#34;) ; arrayList.remove(0) ; // 调用Exchanger中的exchange方法完成数据的交换 ArrayList\u0026lt;String\u0026gt; exchange = exchanger.exchange(arrayList); // 先比对长度 if(arrayList.size() == exchange.size()) { // 然后使用对方线程所传递过来的数据和自己线程所读取到的数据进行比对 for(int x = 0 ; x \u0026lt; arrayList.size() ; x++) { // 本方数据 String benfangElement = arrayList.get(x); // 对方数据 String duifangElement = exchange.get(x); // 比对 if(!benfangElement.equals(duifangElement)) { System.out.println(\u0026#34;数据存在问题.....\u0026#34;); } } }else { System.out.println(\u0026#34;数据存在问题.....\u0026#34;); } } catch (Exception e) { e.printStackTrace(); } } }).start(); // 线程2 new Thread(new Runnable() { @Override public void run() { try { // 读取文件中的数据，然后将其存储到集合中 ArrayList\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;String\u0026gt;() ; BufferedReader bufferedReader = new BufferedReader(new FileReader(\u0026#34;D:\\\\salary\\\\2017-salary.txt\u0026#34;)) ; String line = null ; while((line = bufferedReader.readLine()) != null) { arrayList.add(line) ; } // 调用Exchanger中的exchange方法完成数据的交换 ArrayList\u0026lt;String\u0026gt; exchange = exchanger.exchange(arrayList); // 先比对长度 if(arrayList.size() == exchange.size()) { // 然后使用对方线程所传递过来的数据和自己线程所读取到的数据进行比对 for(int x = 0 ; x \u0026lt; arrayList.size() ; x++) { // 本方数据 String benfangElement = arrayList.get(x); // 对方数据 String duifangElement = exchange.get(x); // 比对 if(!benfangElement.equals(duifangElement)) { System.out.println(\u0026#34;数据存在问题.....\u0026#34;); } } }else { System.out.println(\u0026#34;数据存在问题.....\u0026#34;); } } catch (Exception e) { e.printStackTrace(); } } }).start(); } } ","date":"2024-09-19T11:15:10+08:00","image":"https://hugo-add.github.io/p/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8B%93%E5%B1%95/a_hu18030570661709054373.jpg","permalink":"https://hugo-add.github.io/p/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8B%93%E5%B1%95/","title":"多线程拓展"},{"content":"常见的七种查找算法： ​\t数据结构是数据存储的方式，算法是数据计算的方式。所以在开发中，算法和数据结构息息相关。今天的讲义中会涉及部分数据结构的专业名词，如果各位铁粉有疑惑，可以先看一下哥们后面录制的数据结构，再回头看算法。\n1. 基本查找 ​\t也叫做顺序查找\n​ 说明：顺序查找适合于存储结构为数组或者链表。\n基本思想：顺序查找也称为线形查找，属于无序查找算法。从数据结构线的一端开始，顺序扫描，依次将遍历到的结点与要查找的值相比较，若相等则表示查找成功；若遍历结束仍没有找到相同的，表示查找失败。\n示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class A01_BasicSearchDemo1 { public static void main(String[] args) { //基本查找/顺序查找 //核心： //从0索引开始挨个往后查找 //需求：定义一个方法利用基本查找，查询某个元素是否存在 //数据如下：{131, 127, 147, 81, 103, 23, 7, 79} int[] arr = {131, 127, 147, 81, 103, 23, 7, 79}; int number = 82; System.out.println(basicSearch(arr, number)); } //参数： //一：数组 //二：要查找的元素 //返回值： //元素是否存在 public static boolean basicSearch(int[] arr, int number){ //利用基本查找来查找number在数组中是否存在 for (int i = 0; i \u0026lt; arr.length; i++) { if(arr[i] == number){ return true; } } return false; } } 2. 二分查找 ​\t也叫做折半查找\n说明：元素必须是有序的，从小到大，或者从大到小都是可以的。\n如果是无序的，也可以先进行排序。但是排序之后，会改变原有数据的顺序，查找出来元素位置跟原来的元素可能是不一样的，所以排序之后再查找只能判断当前数据是否在容器当中，返回的索引无实际的意义。\n基本思想：也称为是折半查找，属于有序查找算法。用给定值先与中间结点比较。比较完之后有三种情况：\n相等\n说明找到了\n要查找的数据比中间节点小\n说明要查找的数字在中间节点左边\n要查找的数据比中间节点大\n说明要查找的数字在中间节点右边\n代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package com.itheima.search; public class A02_BinarySearchDemo1 { public static void main(String[] args) { //二分查找/折半查找 //核心： //每次排除一半的查找范围 //需求：定义一个方法利用二分查找，查询某个元素在数组中的索引 //数据如下：{7, 23, 79, 81, 103, 127, 131, 147} int[] arr = {7, 23, 79, 81, 103, 127, 131, 147}; System.out.println(binarySearch(arr, 150)); } public static int binarySearch(int[] arr, int number){ //1.定义两个变量记录要查找的范围 int min = 0; int max = arr.length - 1; //2.利用循环不断的去找要查找的数据 while(true){ if(min \u0026gt; max){ return -1; } //3.找到min和max的中间位置 int mid = (min + max) / 2; //4.拿着mid指向的元素跟要查找的元素进行比较 if(arr[mid] \u0026gt; number){ //4.1 number在mid的左边 //min不变，max = mid - 1； max = mid - 1; }else if(arr[mid] \u0026lt; number){ //4.2 number在mid的右边 //max不变，min = mid + 1; min = mid + 1; }else{ //4.3 number跟mid指向的元素一样 //找到了 return mid; } } } } 3. 插值查找 在介绍插值查找之前，先考虑一个问题：\n​\t为什么二分查找算法一定要是折半，而不是折四分之一或者折更多呢？\n其实就是因为方便，简单，但是如果我能在二分查找的基础上，让中间的mid点，尽可能靠近想要查找的元素，那不就能提高查找的效率了吗？\n二分查找中查找点计算如下：\nmid=(low+high)/2, 即mid=low+1/2*(high-low);\n我们可以将查找的点改进为如下：\nmid=low+(key-a[low])/(a[high]-a[low])*(high-low)，\n这样，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。\n基本思想：基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。\n**细节：**对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。\n代码跟二分查找类似，只要修改一下mid的计算方式即可。\n4. 斐波那契查找 在介绍斐波那契查找算法之前，我们先介绍一下很它紧密相连并且大家都熟知的一个概念——黄金分割。\n黄金比例又称黄金分割，是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为1:0.618或1.618:1。\n0.618被公认为最具有审美意义的比例数字，这个数值的作用不仅仅体现在诸如绘画、雕塑、音乐、建筑等艺术领域，而且在管理、工程设计等方面也有着不可忽视的作用。因此被称为黄金分割。\n在数学中有一个非常有名的数学规律：斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….\n（从第三个数开始，后边每一个数都是前两个数的和）。\n然后我们会发现，随着斐波那契数列的递增，前后两个数的比值会越来越接近0.618，利用这个特性，我们就可以将黄金比例运用到查找技术中。\n基本思想：也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。\n斐波那契查找也是在二分查找的基础上进行了优化，优化中间点mid的计算方式即可\n代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 public class FeiBoSearchDemo { public static int maxSize = 20; public static void main(String[] args) { int[] arr = {1, 8, 10, 89, 1000, 1234}; System.out.println(search(arr, 1234)); } public static int[] getFeiBo() { int[] arr = new int[maxSize]; arr[0] = 1; arr[1] = 1; for (int i = 2; i \u0026lt; maxSize; i++) { arr[i] = arr[i - 1] + arr[i - 2]; } return arr; } public static int search(int[] arr, int key) { int low = 0; int high = arr.length - 1; //表示斐波那契数分割数的下标值 int index = 0; int mid = 0; //调用斐波那契数列 int[] f = getFeiBo(); //获取斐波那契分割数值的下标 while (high \u0026gt; (f[index] - 1)) { index++; } //因为f[k]值可能大于a的长度，因此需要使用Arrays工具类，构造一个新法数组，并指向temp[],不足的部分会使用0补齐 int[] temp = Arrays.copyOf(arr, f[index]); //实际需要使用arr数组的最后一个数来填充不足的部分 for (int i = high + 1; i \u0026lt; temp.length; i++) { temp[i] = arr[high]; } //使用while循环处理，找到key值 while (low \u0026lt;= high) { mid = low + f[index - 1] - 1; if (key \u0026lt; temp[mid]) {//向数组的前面部分进行查找 high = mid - 1; /* 对k--进行理解 1.全部元素=前面的元素+后面的元素 2.f[k]=k[k-1]+f[k-2] 因为前面有k-1个元素没所以可以继续分为f[k-1]=f[k-2]+f[k-3] 即在f[k-1]的前面继续查找k-- 即下次循环,mid=f[k-1-1]-1 */ index--; } else if (key \u0026gt; temp[mid]) {//向数组的后面的部分进行查找 low = mid + 1; index -= 2; } else {//找到了 //需要确定返回的是哪个下标 if (mid \u0026lt;= high) { return mid; } else { return high; } } } return -1; } } 5. 分块查找 当数据表中的数据元素很多时，可以采用分块查找。\n汲取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找\n分块查找适用于数据较多，但是数据不会发生变化的情况，如果需要一边添加一边查找，建议使用哈希查找\n分块查找的过程：\n需要把数据分成N多小块，块与块之间不能有数据重复的交集。 给每一块创建对象单独存储到数组当中 查找数据的时候，先在数组查，当前数据属于哪一块 再到这一块中顺序查找 代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 package com.itheima.search; public class A03_BlockSearchDemo { public static void main(String[] args) { /* 分块查找 核心思想： 块内无序，块间有序 实现步骤： 1.创建数组blockArr存放每一个块对象的信息 2.先查找blockArr确定要查找的数据属于哪一块 3.再单独遍历这一块数据即可 */ int[] arr = {16, 5, 9, 12,21, 18, 32, 23, 37, 26, 45, 34, 50, 48, 61, 52, 73, 66}; //创建三个块的对象 Block b1 = new Block(21,0,5); Block b2 = new Block(45,6,11); Block b3 = new Block(73,12,17); //定义数组用来管理三个块的对象（索引表） Block[] blockArr = {b1,b2,b3}; //定义一个变量用来记录要查找的元素 int number = 37; //调用方法，传递索引表，数组，要查找的元素 int index = getIndex(blockArr,arr,number); //打印一下 System.out.println(index); } //利用分块查找的原理，查询number的索引 private static int getIndex(Block[] blockArr, int[] arr, int number) { //1.确定number是在那一块当中 int indexBlock = findIndexBlock(blockArr, number); if(indexBlock == -1){ //表示number不在数组当中 return -1; } //2.获取这一块的起始索引和结束索引 --- 30 // Block b1 = new Block(21,0,5); ---- 0 // Block b2 = new Block(45,6,11); ---- 1 // Block b3 = new Block(73,12,17); ---- 2 int startIndex = blockArr[indexBlock].getStartIndex(); int endIndex = blockArr[indexBlock].getEndIndex(); //3.遍历 for (int i = startIndex; i \u0026lt;= endIndex; i++) { if(arr[i] == number){ return i; } } return -1; } //定义一个方法，用来确定number在哪一块当中 public static int findIndexBlock(Block[] blockArr,int number){ //100 //从0索引开始遍历blockArr，如果number小于max，那么就表示number是在这一块当中的 for (int i = 0; i \u0026lt; blockArr.length; i++) { if(number \u0026lt;= blockArr[i].getMax()){ return i; } } return -1; } } class Block{ private int max;//最大值 private int startIndex;//起始索引 private int endIndex;//结束索引 public Block() { } public Block(int max, int startIndex, int endIndex) { this.max = max; this.startIndex = startIndex; this.endIndex = endIndex; } /** * 获取 * @return max */ public int getMax() { return max; } /** * 设置 * @param max */ public void setMax(int max) { this.max = max; } /** * 获取 * @return startIndex */ public int getStartIndex() { return startIndex; } /** * 设置 * @param startIndex */ public void setStartIndex(int startIndex) { this.startIndex = startIndex; } /** * 获取 * @return endIndex */ public int getEndIndex() { return endIndex; } /** * 设置 * @param endIndex */ public void setEndIndex(int endIndex) { this.endIndex = endIndex; } public String toString() { return \u0026#34;Block{max = \u0026#34; + max + \u0026#34;, startIndex = \u0026#34; + startIndex + \u0026#34;, endIndex = \u0026#34; + endIndex + \u0026#34;}\u0026#34;; } } 6. 哈希查找 哈希查找是分块查找的进阶版，适用于数据一边添加一边查找的情况。\n一般是数组 + 链表的结合体或者是数组+链表 + 红黑树的结合体\n在课程中，为了让大家方便理解，所以规定：\n数组的0索引处存储1~100 数组的1索引处存储101~200 数组的2索引处存储201~300 以此类推 但是实际上，我们一般不会采取这种方式，因为这种方式容易导致一块区域添加的元素过多，导致效率偏低。\n更多的是先计算出当前数据的哈希值，用哈希值跟数组的长度进行计算，计算出应存入的位置，再挂在数组的后面形成链表，如果挂的元素太多而且数组长度过长，我们也会把链表转化为红黑树，进一步提高效率。\n具体的过程，大家可以参见B站阿玮讲解课程：从入门到起飞。在集合章节详细讲解了哈希表的数据结构。全程采取动画形式讲解，让大家一目了然。\n在此不多做阐述。\n7. 树表查找 本知识点涉及到数据结构：树。\n建议先看一下后面阿玮讲解的数据结构，再回头理解。\n基本思想：二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。\n二叉查找树（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree），具有下列性质的二叉树：\n1）若任意节点左子树上所有的数据，均小于本身；\n2）若任意节点右子树上所有的数据，均大于本身；\n二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。\n​ 不同形态的二叉查找树如下图所示：\n基于二叉查找树进行优化，进而可以得到其他的树表查找算法，如平衡树、红黑树等高效算法。\n具体细节大家可以参见B站阿玮讲解课程：从入门到起飞。在集合章节详细讲解了树数据结构。全程采取动画形式讲解，让大家一目了然。\n在此不多做阐述。\n​\t不管是二叉查找树，还是平衡二叉树，还是红黑树，查找的性能都比较高\n十大排序算法： 1. 冒泡排序 冒泡排序（Bubble Sort）也是一种简单直观的排序算法。\n它重复的遍历过要排序的数列，一次比较相邻的两个元素，如果他们的顺序错误就把他们交换过来。\n这个算法的名字由来是因为越大的元素会经由交换慢慢\u0026quot;浮\u0026quot;到最后面。\n当然，大家可以按照从大到小的方式进行排列。\n1.1 算法步骤 相邻的元素两两比较，大的放右边，小的放左边 第一轮比较完毕之后，最大值就已经确定，第二轮可以少循环一次，后面以此类推 如果数组中有n个数据，总共我们只要执行n-1轮的代码就可以 1.2 动图演示 1.3 代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public class A01_BubbleDemo { public static void main(String[] args) { /* 冒泡排序： 核心思想： 1，相邻的元素两两比较，大的放右边，小的放左边。 2，第一轮比较完毕之后，最大值就已经确定，第二轮可以少循环一次，后面以此类推。 3，如果数组中有n个数据，总共我们只要执行n-1轮的代码就可以。 */ //1.定义数组 int[] arr = {2, 4, 5, 3, 1}; //2.利用冒泡排序将数组中的数据变成 1 2 3 4 5 //外循环：表示我要执行多少轮。 如果有n个数据，那么执行n - 1 轮 for (int i = 0; i \u0026lt; arr.length - 1; i++) { //内循环：每一轮中我如何比较数据并找到当前的最大值 //-1：为了防止索引越界 //-i：提高效率，每一轮执行的次数应该比上一轮少一次。 for (int j = 0; j \u0026lt; arr.length - 1 - i; j++) { //i 依次表示数组中的每一个索引：0 1 2 3 4 if(arr[j] \u0026gt; arr[j + 1]){ int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } printArr(arr); } private static void printArr(int[] arr) { //3.遍历数组 for (int i = 0; i \u0026lt; arr.length; i++) { System.out.print(arr[i] + \u0026#34; \u0026#34;); } System.out.println(); } } 2. 选择排序 2.1 算法步骤 从0索引开始，跟后面的元素一一比较 小的放前面，大的放后面 第一次循环结束后，最小的数据已经确定 第二次循环从1索引开始以此类推 第三轮循环从2索引开始以此类推 第四轮循环从3索引开始以此类推。 2.2 动图演示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 public class A02_SelectionDemo { public static void main(String[] args) { /* 选择排序： 1，从0索引开始，跟后面的元素一一比较。 2，小的放前面，大的放后面。 3，第一次循环结束后，最小的数据已经确定。 4，第二次循环从1索引开始以此类推。 */ //1.定义数组 int[] arr = {2, 4, 5, 3, 1}; //2.利用选择排序让数组变成 1 2 3 4 5 /* //第一轮： //从0索引开始，跟后面的元素一一比较。 for (int i = 0 + 1; i \u0026lt; arr.length; i++) { //拿着0索引跟后面的数据进行比较 if(arr[0] \u0026gt; arr[i]){ int temp = arr[0]; arr[0] = arr[i]; arr[i] = temp; } }*/ //最终代码： //外循环：几轮 //i:表示这一轮中，我拿着哪个索引上的数据跟后面的数据进行比较并交换 for (int i = 0; i \u0026lt; arr.length -1; i++) { //内循环：每一轮我要干什么事情？ //拿着i跟i后面的数据进行比较交换 for (int j = i + 1; j \u0026lt; arr.length; j++) { if(arr[i] \u0026gt; arr[j]){ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } } printArr(arr); } private static void printArr(int[] arr) { //3.遍历数组 for (int i = 0; i \u0026lt; arr.length; i++) { System.out.print(arr[i] + \u0026#34; \u0026#34;); } System.out.println(); } } 3. 插入排序 插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过创建有序序列和无序序列，然后再遍历无序序列得到里面每一个数字，把每一个数字插入到有序序列中正确的位置。\n插入排序在插入的时候，有优化算法，在遍历有序序列找正确位置时，可以采取二分查找\n3.1 算法步骤 将0索引的元素到N索引的元素看做是有序的，把N+1索引的元素到最后一个当成是无序的。\n遍历无序的数据，将遍历到的元素插入有序序列中适当的位置，如遇到相同数据，插在后面。\nN的范围：0~最大索引\n3.2 动图演示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 package com.itheima.mysort; public class A03_InsertDemo { public static void main(String[] args) { /* 插入排序： 将0索引的元素到N索引的元素看做是有序的，把N+1索引的元素到最后一个当成是无序的。 遍历无序的数据，将遍历到的元素插入有序序列中适当的位置，如遇到相同数据，插在后面。 N的范围：0~最大索引 */ int[] arr = {3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48}; //1.找到无序的哪一组数组是从哪个索引开始的。 2 int startIndex = -1; for (int i = 0; i \u0026lt; arr.length; i++) { if(arr[i] \u0026gt; arr[i + 1]){ startIndex = i + 1; break; } } //2.遍历从startIndex开始到最后一个元素，依次得到无序的哪一组数据中的每一个元素 for (int i = startIndex; i \u0026lt; arr.length; i++) { //问题：如何把遍历到的数据，插入到前面有序的这一组当中 //记录当前要插入数据的索引 int j = i; while(j \u0026gt; 0 \u0026amp;\u0026amp; arr[j] \u0026lt; arr[j - 1]){ //交换位置 int temp = arr[j]; arr[j] = arr[j - 1]; arr[j - 1] = temp; j--; } } printArr(arr); } private static void printArr(int[] arr) { //3.遍历数组 for (int i = 0; i \u0026lt; arr.length; i++) { System.out.print(arr[i] + \u0026#34; \u0026#34;); } System.out.println(); } } 4. 快速排序 快速排序是由东尼·霍尔所发展的一种排序算法。\n快速排序又是一种分而治之思想在排序算法上的典型应用。\n快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！\n它是处理大数据最快的排序算法之一了。\n4.1 算法步骤 从数列中挑出一个元素，一般都是左边第一个数字，称为 \u0026ldquo;基准数\u0026rdquo;; 创建两个指针，一个从前往后走，一个从后往前走。 先执行后面的指针，找出第一个比基准数小的数字 再执行前面的指针，找出第一个比基准数大的数字 交换两个指针指向的数字 直到两个指针相遇 将基准数跟指针指向位置的数字交换位置，称之为：基准数归位。 第一轮结束之后，基准数左边的数字都是比基准数小的，基准数右边的数字都是比基准数大的。 把基准数左边看做一个序列，把基准数右边看做一个序列，按照刚刚的规则递归排序 4.2 动图演示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 package com.itheima.mysort; import java.util.Arrays; public class A05_QuickSortDemo { public static void main(String[] args) { System.out.println(Integer.MAX_VALUE); System.out.println(Integer.MIN_VALUE); /* 快速排序： 第一轮：以0索引的数字为基准数，确定基准数在数组中正确的位置。 比基准数小的全部在左边，比基准数大的全部在右边。 后面以此类推。 */ int[] arr = {1,1, 6, 2, 7, 9, 3, 4, 5, 1,10, 8}; //int[] arr = new int[1000000]; /* Random r = new Random(); for (int i = 0; i \u0026lt; arr.length; i++) { arr[i] = r.nextInt(); }*/ long start = System.currentTimeMillis(); quickSort(arr, 0, arr.length - 1); long end = System.currentTimeMillis(); System.out.println(end - start);//149 System.out.println(Arrays.toString(arr)); //课堂练习： //我们可以利用相同的办法去测试一下，选择排序，冒泡排序以及插入排序运行的效率 //得到一个结论：快速排序真的非常快。 /* for (int i = 0; i \u0026lt; arr.length; i++) { System.out.print(arr[i] + \u0026#34; \u0026#34;); }*/ } /* * 参数一：我们要排序的数组 * 参数二：要排序数组的起始索引 * 参数三：要排序数组的结束索引 * */ public static void quickSort(int[] arr, int i, int j) { //定义两个变量记录要查找的范围 int start = i; int end = j; if(start \u0026gt; end){ //递归的出口 return; } //记录基准数 int baseNumber = arr[i]; //利用循环找到要交换的数字 while(start != end){ //利用end，从后往前开始找，找比基准数小的数字 //int[] arr = {1, 6, 2, 7, 9, 3, 4, 5, 10, 8}; while(true){ if(end \u0026lt;= start || arr[end] \u0026lt; baseNumber){ break; } end--; } System.out.println(end); //利用start，从前往后找，找比基准数大的数字 while(true){ if(end \u0026lt;= start || arr[start] \u0026gt; baseNumber){ break; } start++; } //把end和start指向的元素进行交换 int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; } //当start和end指向了同一个元素的时候，那么上面的循环就会结束 //表示已经找到了基准数在数组中应存入的位置 //基准数归位 //就是拿着这个范围中的第一个数字，跟start指向的元素进行交换 int temp = arr[i]; arr[i] = arr[start]; arr[start] = temp; //确定6左边的范围，重复刚刚所做的事情 quickSort(arr,i,start - 1); //确定6右边的范围，重复刚刚所做的事情 quickSort(arr,start + 1,j); } } 其他排序方式待更新~\n","date":"2024-09-19T11:15:10+08:00","image":"https://hugo-add.github.io/p/%E9%BB%91%E9%A9%AC%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/a_hu8796385503214875142.jpg","permalink":"https://hugo-add.github.io/p/%E9%BB%91%E9%A9%AC%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/","title":"黑马算法笔记"},{"content":"恐怖故事合集 不是传说，真事。我一个隔壁班的同学，第一天还和我有说有笑的，第二天几发现死在我家附近的立交桥山下了。而且被分尸..\n上小学的时候有个闺密关系特别好那时候我把他爸爸妈妈喊干爸干妈突然一天他爸爸特别奇怪的死掉了她家是做生意的平时特别累干妈说干爸是猝死然后我也没多问毕竟是小学 以后过了两年吧我们一块上初中然后有一天我闺蜜做梦梦到他爸带她出去玩然后他爸拿她的手机在九寨沟给她拍了一张照片\n有个女孩对着镜子玩石头剪刀布，结果女孩哭了，因为她赢了\n每次扫墓前奶奶总会被托梦，前年清明家里人一起扫墓，奶奶说xx昨天给我托梦，说烧纸就烧黄纸，不要那种几亿一张的天地银行钞票，那是假的用不掉\n我姨爹小时候和九个小伙伴一起去河里洗冷水澡，洗着洗着就发现多了一个不认识的人，吓得大家赶紧上岸回家，也没注意只有8个人上来了，几个小时后家长来找的时候就只捞到尸体了，外婆姨爹从那之后再也没去河里洗过澡，本来那条河里原来就淹死过人的\n小时候在客厅泡脚，对面桌上放了一个不锈钢的脸盆。然后我就看到脸盆里有个穿白衣服的人一直在对我摇头。我仔细看，还是看到有个人在跟我摇头。我确信，里面的人坐的是我的位置，可我那天穿了一件红色的马甲，发型也不一样。\n真事:小学组织去玩，女生一个寝室，偏偏被分到上铺。天花板到处都是红色的字体写的有鬼不要住这儿。当时也没想太多，晚上睡不着和同学聊天。凌晨时，看见窗外面有一个老爷爷扛着什么东西，然后用那个东西一个劲的刨地。第二天出去却发现什么都没有，关键是我们是看着老爷爷走的。寝室以前就被传过有鬼\n以前有个道士给一个男人算命说今天晚上12点会有个女鬼来找他，叫他躲在床下面这样女鬼就看不见他了。晚上到了男人躲好以后，12点了他听见咚咚咚的声音，这时他看向床边时有一个女头正看着他，身子倒立…原来是道士算错了，他应该躲在高处而不是低处。\n姐姐和我说的故事有个人在宾馆睡觉老听到 背靠背我们背靠背的声音 但就是找不到人 后来他把床反过来 上面贴着一具尸体 卧槽从此不敢朝天睡贴墙壁\n农历七月十五鬼门开时没给爷爷烧纸半夜被一声剧响吵醒开灯一看房里的柜子上的玻璃全部炸碎了。\n偶然翻到以前的日记，发现我在同一个星期写的都是一个人，那个人我完全没印象，后来问问以前的同班朋友她说压根没这个人！！\n首先说这是真事儿，我妈小时候住在农村，有天晚上我妈睡不着觉，就往窗户外面看，看到个女人倒吊着的头披头散发看着我妈妈，面目狰狞，直接吓到我妈了，赶紧把我姥姥叫醒了，结果那个女的就消失了，我妈还被我姥训了一顿，后来才听说当时附近有个女的上吊自杀了，我妈现在还信誓旦旦的说当时肯定没看错首先说这是真事儿，我妈小时候住在农村，有天晚上我妈睡不着觉，就往窗户外面看，看到个女人倒吊着的头披头散发看着我妈妈，面目狰狞，直接吓到我妈了，赶紧把我姥姥叫醒了，结果那个女的就消失了，我妈还被我姥训了一顿，后来才听说当时附近有个女的上吊自杀了，我妈现在还信誓旦旦的说当时肯定没看错\n有次在宿舍睡觉梦到鬼拍了下我肩膀，我立刻吓醒了然后发现根本动弹不得而且床边就趴着刚刚那只鬼，我吓得立刻闭上眼睛又睁开它就不见了，可还是动不了，脑袋很清醒，过了两分钟后总算真的睁开了眼睛，动作和视角还是维持着刚刚的，我立马弹了起来就不敢睡了。后来问同学他说这是鬼压床，很正常。。\n我来说个真的，小小时候和爸妈一起睡，到了半夜我醒了，突然看见通往客厅的走廊上有一个绿色透明的人在走，吓死，我赶紧拍醒旁边的爸爸，但不敢出声，他估计没醒透，拿枕头拍了拍妈妈，自己睡着了，妈妈居然没醒，我再一看走廊，那个人不见了。我上次跟爸爸说了下，他说以为是我睡不着，拿手拍了我的背\n睡前故事 ","date":"2024-09-12T21:13:05+08:00","image":"https://hugo-add.github.io/p/%E6%95%85%E4%BA%8B%E5%90%88%E9%9B%86/a_hu6307248181568134095.jpg","permalink":"https://hugo-add.github.io/p/%E6%95%85%E4%BA%8B%E5%90%88%E9%9B%86/","title":"故事合集"},{"content":"部署使用说明 get add .\ngit commit -m \u0026ldquo;update\u0026rdquo;\ngit push\n执行完后可能会失败,可能是网络问题,多执行几次就行\n项目结构说明 归档 归档最上面的类别就是categories下的分类文件夹,会自动识别\n分类 主页的分类是在categories文件夹中定义样式的,在文章中创建的分类只有空白的显示\n一个分类对应一个文件夹,文件的命名方式是**_index.md**\n图片一般是本地引用的图片\n其他说明 本地运行 hugo server -D 新建个文章 hugo new content post/***/index.md md书写注意 一个\u0026quot;#\u0026ldquo;md无法识别成目录,会导致无目录显示,需要两个或两个以上才可以识别成功 ","date":"2024-09-10T20:58:04+08:00","image":"https://hugo-add.github.io/p/%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/a_hu13111365700940705450.jpg","permalink":"https://hugo-add.github.io/p/%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","title":"使用手册"}]