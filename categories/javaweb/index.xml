<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>JavaWeb on 小李的神秘空间</title>
        <link>https://hugo-add.github.io/categories/javaweb/</link>
        <description>Recent content in JavaWeb on 小李的神秘空间</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>『呼吸别停』</copyright>
        <lastBuildDate>Sat, 21 Sep 2024 12:15:23 +0800</lastBuildDate><atom:link href="https://hugo-add.github.io/categories/javaweb/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>JavaWeb</title>
        <link>https://hugo-add.github.io/p/javaweb/</link>
        <pubDate>Sat, 21 Sep 2024 12:15:23 +0800</pubDate>
        
        <guid>https://hugo-add.github.io/p/javaweb/</guid>
        <description>&lt;img src="https://hugo-add.github.io/p/javaweb/a.jpg" alt="Featured image of post JavaWeb" /&gt;&lt;h1 id=&#34;javaweb&#34;&gt;JavaWeb
&lt;/h1&gt;&lt;h2 id=&#34;初始web前端&#34;&gt;初始Web前端
&lt;/h2&gt;&lt;p&gt;Web标准也称网页标准&lt;br&gt;
&lt;strong&gt;三个组成部分&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTML超文本标记语言: 负责网页的结构(页面元素和内容)&lt;/li&gt;
&lt;li&gt;CSS层叠样式表: 负责网页的表现(页面元素的外观，位置等)&lt;/li&gt;
&lt;li&gt;JavaScript: 负责网页的行为(交互效果)&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.w3school.com.cn&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方文档&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;html&#34;&gt;HTML
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;HTML标签特点&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不区分大小写&lt;/li&gt;
&lt;li&gt;标签属性值单双引号都可以&lt;/li&gt;
&lt;li&gt;HTML语法松散&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;HTML标签&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt;到&lt;code&gt;&amp;lt;h6&amp;gt;&lt;/code&gt;重要程度依次降低，都是提前预定义好的，不能自己随便定义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;hr&amp;gt;&lt;/code&gt;水平线标签&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;...&amp;quot; width = &amp;quot;&amp;quot; height=&amp;quot;&amp;quot;&amp;gt;&lt;/code&gt;图片标签(./当前目录，../上级目录)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;行标签，没有任何意义，就是赋予内容一个标签名字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;视频标签 src:规定视频的url   controls:显示播放控件   width:宽 height:高&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;音频标签 src:规定音频的url   controls:显示播放控件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;段落标签&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;b&amp;gt;/&amp;lt;strong&amp;gt;&lt;/code&gt;文本加粗标签&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;css&#34;&gt;CSS
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;CSS引入方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;行内样式: 写在标签的style属性中(不推荐)&lt;/li&gt;
&lt;li&gt;内嵌样式: 写在style标签中(可以写在页面的任何位置，但通常约定写在head标签中)&lt;/li&gt;
&lt;li&gt;外联样式: 写在一个单独的.css文件中(需要通过link标签在网页中引入)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;颜色表示方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键字:预定义的颜色吗&amp;mdash;red，green，blue&amp;hellip;&lt;/li&gt;
&lt;li&gt;rgb表示法:红绿蓝三原色，每项取值时0~255&amp;mdash;rgb(255，0，0)&amp;hellip;&lt;/li&gt;
&lt;li&gt;十六进制表示法:#开头，将数字转换成十六进制表示&amp;mdash;#000000，#cccccc(简写#000，#ccc)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;CSS选择器&lt;/strong&gt;:用来选取需要设置样式的元素(标签)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;元素选择器:根据标签类型来选择修改样式&lt;/li&gt;
&lt;li&gt;id选择器:根据id名来选择修改样式(id是唯一的)&lt;/li&gt;
&lt;li&gt;类选择器:根据class名来选择修改样式(类名可以重复)&lt;/li&gt;
&lt;li&gt;优先级:id选择器&amp;gt;类选择器&amp;gt;元素选择器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;CSS属性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;color:设置文本的颜色&lt;/li&gt;
&lt;li&gt;font-size:设置字体大小&lt;/li&gt;
&lt;li&gt;text-decoration:规定添加到文本的修饰，none表示定义标准的文本&lt;/li&gt;
&lt;li&gt;line-height:设置行高&lt;/li&gt;
&lt;li&gt;text-indent:定义第一行内容缩进&lt;/li&gt;
&lt;li&gt;text-align:规定元素中的文本的水平对齐方式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;超链接&lt;/strong&gt;:&lt;code&gt;&amp;lt;a href=&amp;quot;链接跳转地址&amp;quot; target=&amp;quot;定义是否在新页面打开&amp;quot;&amp;gt;&lt;/code&gt;&lt;br&gt;
&lt;em&gt;注意:HTML中无论输入多少空格都只会显示一个，可以使用空格占位符&amp;amp;nbsp&lt;/em&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;页面布局&lt;/strong&gt;&lt;br&gt;
盒子:页面中所有的元素(标签)，都可以看做是一个盒子，由盒子将页面中的元素包含在一个矩形区域内，通过盒子的视角更方便的进行页面布局&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;盒子模型的组成:内容区域(content)，内边距区域(padding)，边框区域(border)，外边框区域(margin)&lt;br&gt;&lt;/li&gt;
&lt;li&gt;布局标签:实际开发中会大量使用div和span这俩个没有语义的布局标签&lt;br&gt;&lt;/li&gt;
&lt;li&gt;div标签:一行只显示一个，宽度默认是夫元素的宽度，高度默认是内容撑开，可以设置宽高&lt;br&gt;&lt;/li&gt;
&lt;li&gt;span标签:一行可以显示多个，宽度高度默认有内容撑开，不可以自己设置宽高&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例 div {&lt;br&gt;
　　width: 200px;&lt;br&gt;
　　height: 200px;&lt;br&gt;
　　box-sizing: border-box;&amp;ndash;指定width和height为盒子的宽高&lt;br&gt;
　　background-color: red;&amp;ndash;背景色&lt;br&gt;
　　padding: 20px;&amp;ndash;内边距 上-&amp;gt;右-&amp;gt;下-&amp;gt;左&lt;br&gt;
　　border: 10px solid red;&amp;ndash;边框 边框-&amp;gt;宽度-&amp;gt;线条类型-&amp;gt;颜色&lt;br&gt;
　　margin: 30px;&amp;ndash;外边距 上-&amp;gt;右-&amp;gt;下-&amp;gt;左&lt;br&gt;
　　}&lt;br&gt;
&lt;img src=&#34;https://hugo-add.github.io/p/javaweb/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.jpg&#34;
	width=&#34;289&#34;
	height=&#34;218&#34;
	srcset=&#34;https://hugo-add.github.io/p/javaweb/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B_hu16027846493424078178.jpg 480w, https://hugo-add.github.io/p/javaweb/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B_hu819726171574015655.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;盒子模型&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;132&#34;
		data-flex-basis=&#34;318px&#34;
	
&gt;
&lt;em&gt;注意:如果要设置某一个方位的属性只需要在属性名后加上方位就行&lt;/em&gt; 如:padding-top，padding-left&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表格标签&lt;/strong&gt;&lt;br&gt;
表格中的数据会以行和列的形式展示出来&lt;br&gt;
&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;定义表格整体，可以包裹多个&lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; border边框宽  windth宽  cellspacing间隙&lt;br&gt;
&lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt;表格的行可以包裹多个&lt;code&gt;&amp;lt;tb&amp;gt;&amp;lt;br&amp;gt;&lt;/code&gt;
&lt;code&gt;&amp;lt;tb&amp;gt;&lt;/code&gt;表格单元格(普通)，可以包裹内容，如果是表头单元格可以替换成&lt;th&gt;&lt;br&gt;
表单标签&lt;br&gt;
表单标签&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;&lt;br&gt;
场景: 在网页中主要负责数据采集功能如:注册，登录等&lt;br&gt;
表单项: 不同类型的input元素，下拉列表，文本域等&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;定义表单项，通过type属性控制输入形式&lt;br&gt;&lt;/li&gt;
&lt;li&gt;input的type属性:text，password，radio，checkbox，file，date，datetime-local，time，number，hidden，button，submit&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;定义下拉列表&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;定义文本域&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;注意:表单项必须有name属性才可以提交&lt;/em&gt;    &lt;br&gt;
属性&lt;br&gt;
1：action:规定当提交表单时向何处发送表单数据，URL&lt;br&gt;
2：method:规定用于发送表单数据的方式 get，post&lt;br&gt;
get:url后面拼接表单数据，有长度限制，默认值  post:消息体中传递，参数无限制&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;javascriptbr&#34;&gt;JavaScript&lt;br&gt;
&lt;/h3&gt;&lt;p&gt;是一门跨平台，面向对象的脚本语言&lt;br&gt;
&lt;strong&gt;JS引入方式&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部脚本:JS代码定义在HTML页面中位于&lt;code&gt;&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;之间&lt;br&gt;&lt;/li&gt;
&lt;li&gt;外部脚本:定义在外部JS文件中，只包含JS代码，&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意:&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;可以在任何位置，但是一般在body元素底部，改善显示速度，JS文件里面不含&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签，&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;不能自闭合&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JS基础语法&lt;/strong&gt;&lt;br&gt;
书写语法&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;区分大小写&lt;br&gt;&lt;/li&gt;
&lt;li&gt;每行结尾的分号可有可无&lt;br&gt;&lt;/li&gt;
&lt;li&gt;注释:单行注释&amp;mdash;-//&amp;hellip;   多行注释&amp;mdash;-/&lt;em&gt;&amp;hellip;&lt;/em&gt;/&lt;br&gt;&lt;/li&gt;
&lt;li&gt;大括号表示代码块&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输出语句&lt;br&gt;
使用window.alert()&amp;ndash;写入警告框&lt;br&gt;
使用document.write()&amp;ndash;写入HTML页面中&lt;br&gt;
使用console.log()&amp;ndash;写入浏览器控制台&lt;br&gt;&lt;/p&gt;
&lt;p&gt;变量&lt;br&gt;
JS中用var关键字来声明变量(全局，可重复声明)&lt;br&gt;
JS是一门弱类型语言，变量可以存放不同类型的值&lt;br&gt;
规则:组成是字母，数字，下划线，或美元符号，数字不能开头&lt;br&gt;
新增的 let(代码块生效，不能重复声明)  const(只读声明，一旦定义不能更改)&lt;br&gt;&lt;/p&gt;
&lt;p&gt;数据类型&lt;br&gt;
JS中分为:原始类型和引用类型&lt;br&gt;
number数字，string字符串，boolean布尔，null空，undefined未初始化默认值&lt;br&gt;
使用typeof运算符可以获取数据类型&lt;br&gt;&lt;/p&gt;
&lt;p&gt;运算符&lt;br&gt;
算术运算符:+，-，&lt;em&gt;，/，%，++，&amp;ndash;&lt;br&gt;
赋值运算符:=，+=，-=，&lt;/em&gt;=，/=，%=&lt;br&gt;
比较运算符:&amp;gt;，&amp;lt;，&amp;gt;=，&amp;lt;=，!=，==，===&lt;br&gt;
逻辑运算符:&amp;amp;&amp;amp;，||，!&lt;br&gt;
三元运算符:&amp;hellip;? a:b&lt;br&gt;
==会进行类型转换 ===不会进行类型转换&lt;br&gt;
类型转换
1.字符串转换成数字，从第一个开始到第一个非数字，如果为空就是NaN&lt;br&gt;
2.转换成布尔型，0和空和NaN和undefined都会转换成False&lt;br&gt;
流程控制语句&lt;br&gt;
省略&amp;hellip;..&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JS函数&lt;/strong&gt;&lt;br&gt;
函数是被设计为执行特点任务的代码块&lt;br&gt;
JS函数通过function关键字进行定义 语法为 function a(..){&amp;hellip;}&lt;br&gt;
形参不需要类型，返回值也不需要定义类型，直接return返回即可&lt;br&gt;
第二种定义方式:var a=function(..){&amp;hellip;}&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JS对象&lt;/strong&gt;&lt;br&gt;
Array对象&lt;br&gt;
定义1: var 变量名 = new Array(&amp;hellip;)&lt;br&gt;
定义2: var 变量名 = [&amp;hellip;]&lt;br&gt;
访问: 变量名[索引] = 值&lt;br&gt;
JS种数组长度可越界会自动增加索引，里面数据类型也可以存储任意类型&lt;br&gt;
属性:length&amp;ndash;返回数组元素数量&lt;br&gt;
方法:forEach(..)=&amp;gt;{..}&amp;ndash;遍历有值的元素  push()&amp;ndash;添加  splice()&amp;ndash;删除&lt;br&gt;
String字符串&lt;br&gt;
定义1: var 变量名 = new String(&amp;quot;&amp;hellip;&amp;quot;)&lt;br&gt;
定义2: var 变量名 = &amp;ldquo;&amp;hellip;&amp;quot;&lt;br&gt;
属性:length&amp;ndash;长度&lt;br&gt;
方法:charAt()&amp;ndash;返回指定位置字符  indexOf()&amp;ndash;检索字符串  trim()&amp;ndash;去除两边空格  substring()&amp;ndash;截取(包头不包尾)&lt;br&gt;&lt;/p&gt;
&lt;p&gt;JS自定义对象&lt;br&gt;
定义格式:&lt;br&gt;
var 对象名 = {&lt;br&gt;
属性名1: 属性值1，&lt;br&gt;
属性名2: 属性值2，&lt;br&gt;
函数名称: function(形参列表){&amp;hellip;}};&lt;br&gt;
调用格式:对象名.属性名;   对象名.函数名();&lt;br&gt;&lt;/p&gt;
&lt;p&gt;JSON&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JSON是通过JavaScript对象标记法书写的文本&lt;br&gt;&lt;/li&gt;
&lt;li&gt;JSON就是key和value形式的键值对，只不过key需要用双引号引起来&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;语法简单，层次鲜明，现多用于作为数据载体，在网络中进行数据传输&lt;br&gt;
定义:var 变量名 = &amp;lsquo;{&amp;ldquo;key1&amp;rdquo;:value1，&amp;ldquo;key2&amp;rdquo;:value2}&amp;rsquo;;&lt;br&gt;
value的数据类型 数字&amp;ndash;正常写，字符串&amp;ndash;双引号，逻辑值&amp;ndash;true/false，数组&amp;ndash;方括号，对象&amp;ndash;花括号&lt;br&gt;
例:var a = &amp;lsquo;{&amp;ldquo;name&amp;rdquo;:&amp;ldquo;Tom&amp;rdquo;，&amp;ldquo;age&amp;rdquo;:20，&amp;ldquo;add&amp;rdquo;:[&amp;ldquo;上&amp;rdquo;，&amp;ldquo;下&amp;rdquo;]}&amp;rsquo;;  &lt;br&gt;
方法: parse()&amp;ndash;将JSON变量转成JS对象    stringify()&amp;ndash;将JS对象转成JSON变量&lt;br&gt;&lt;/p&gt;
&lt;p&gt;BOM&lt;br&gt;
BOM是浏览器对象模型，允许JS与浏览器对话，JS将浏览器的各个组成部分封装为对象&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Window:浏览器窗口对象&lt;br&gt;
直接使用window，其中window可以省略&lt;br&gt;&lt;/li&gt;
&lt;li&gt;属性:history:&amp;mdash;location:&amp;mdash;navigator: 获取对象的对象，详情参考官方文档&lt;br&gt;&lt;/li&gt;
&lt;li&gt;方法:alert()警告弹窗 confirm()消息弹窗 setInterval()周期延迟运行 setTimeout()延迟运行&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Navigator:浏览器对象&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Screen:屏幕对象&lt;br&gt;&lt;/li&gt;
&lt;li&gt;History:历史记录对象&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Location:地址栏对象&lt;br&gt;&lt;/li&gt;
&lt;li&gt;获取:window.location.属性/location.属性&lt;br&gt;&lt;/li&gt;
&lt;li&gt;属性:href设置或返回完整的URL&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DOM&lt;br&gt;
DOM是文档对象模型&lt;br&gt;
将标记语言的各个组成部分封装为对应的对象&lt;br&gt;
JS通过DOM就能够对HTML进行操作&lt;br&gt;
&lt;img src=&#34;https://hugo-add.github.io/p/javaweb/%E6%96%87%E6%A1%A3%E6%A8%A1%E5%9E%8B.jpg&#34;
	width=&#34;652&#34;
	height=&#34;705&#34;
	srcset=&#34;https://hugo-add.github.io/p/javaweb/%E6%96%87%E6%A1%A3%E6%A8%A1%E5%9E%8B_hu2622013208711930112.jpg 480w, https://hugo-add.github.io/p/javaweb/%E6%96%87%E6%A1%A3%E6%A8%A1%E5%9E%8B_hu6983915904304815664.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;文档模型&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;92&#34;
		data-flex-basis=&#34;221px&#34;
	
&gt;
DOM是W3C(万维网联盟)的标准，定义了HTML和XML的标准，有以下三种&lt;br&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有文档的标准模型&lt;br&gt;
Document:整个文档对象&lt;br&gt;
Element:元素对象&lt;br&gt;
Attribute:属性对象&lt;br&gt;
Text:文本对象&lt;br&gt;
Comment:注释对象&lt;br&gt;&lt;/li&gt;
&lt;li&gt;XML DOM-XML文档的标准模型&lt;br&gt;&lt;/li&gt;
&lt;li&gt;HTML DOM-HTML文档的标准模型&lt;br&gt;
image:&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;br&gt;
Button:&lt;code&gt;&amp;lt;input type=&#39;button&#39;&amp;gt;&lt;/code&gt;&lt;br&gt;
Document对象提供了以下获取Element元素的函数&lt;br&gt;&lt;/li&gt;
&lt;li&gt;根据id属性值获取，返回单个Element对象&lt;br&gt;
var h1 = document.getElementById(&amp;rsquo;..&amp;rsquo;);&lt;br&gt;&lt;/li&gt;
&lt;li&gt;根据标签名称获取，返回Element对象数组&lt;br&gt;
var h2 = document.getElementByTagName(&amp;rsquo;..&amp;rsquo;);&lt;br&gt;&lt;/li&gt;
&lt;li&gt;根据name属性值获取，返回Element对象数组&lt;br&gt;
var h3 = document.getElementByName(&amp;rsquo;..&amp;rsquo;);&lt;br&gt;&lt;/li&gt;
&lt;li&gt;根据class属性值获取，返回Element对象数组&lt;br&gt;
var h4 = document.getElementByClassName(&amp;rsquo;..&amp;rsquo;);&lt;br&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体操作步骤:先获取元素对象赋值-&amp;gt;然后调用方法去改变内容-&amp;gt;刷新页面&lt;br&gt;
具体参考官方文档&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事件监听&lt;/strong&gt;&lt;br&gt;
事件:发生在HTML元素上的事件&lt;br&gt;
绑定方式1:通过HTML标签中的事件进行绑定&lt;br&gt;
绑定方式2:通过DOM元素属性绑定&lt;br&gt;
常见事件&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;onclick&amp;mdash;鼠标单击事件&lt;br&gt;&lt;/li&gt;
&lt;li&gt;onblur&amp;mdash;元素失去焦点&lt;br&gt;&lt;/li&gt;
&lt;li&gt;onfocus&amp;mdash;元素获得焦点&lt;br&gt;&lt;/li&gt;
&lt;li&gt;onload&amp;mdash;某个页面或图像加载完毕&lt;br&gt;&lt;/li&gt;
&lt;li&gt;onsubmit&amp;mdash;表单提交事件&lt;br&gt;&lt;/li&gt;
&lt;li&gt;onkeydown&amp;mdash;键盘摁键事件&lt;br&gt;&lt;/li&gt;
&lt;li&gt;onmouseover&amp;mdash;鼠标移动到元素上&lt;br&gt;&lt;/li&gt;
&lt;li&gt;onmouseout&amp;mdash;鼠标从元素上移开&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;插值表达式&lt;br&gt;
形式: {{表达式}}&lt;br&gt;
表达式内容可以是变量，三元运算符，函数调用，算术运算&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;vuebr&#34;&gt;Vue&lt;br&gt;
&lt;/h2&gt;&lt;p&gt;Vue是一套前端框架，免除原生JavaScript中的DOM操作，简化书写.&lt;br&gt;
基于MVVM思想，实现数据的双向绑定&lt;br&gt;
官网:Vue.js - 渐进式 JavaScript 框架 | Vue.js (vuejs.org)&lt;br&gt;
框架:是一个半成品，是一套可重复的，通用的软件基础代码模型，基于框架开发，更加高效，更快捷&lt;br&gt;
补充: 在Vue中以v-打头的叫做指令&lt;br&gt;
常用指令&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;v-bind:让HTML标签绑定属性值从静态变成动态，如设置href，css样式等&lt;br&gt;&lt;/li&gt;
&lt;li&gt;v-model:为表单元素上创建双向数据绑定&lt;br&gt;&lt;/li&gt;
&lt;li&gt;v-on:为HTML标签绑定事件(事件在methods:{..}中写)&lt;br&gt;&lt;/li&gt;
&lt;li&gt;v-if/v-else-if/v-else:判断条件&lt;br&gt;&lt;/li&gt;
&lt;li&gt;v-show:根据条件展示某元素，区别在于切换的是display属性的值&lt;br&gt;&lt;/li&gt;
&lt;li&gt;v-for:列表渲染，遍历元素或对象的属性&lt;br&gt;
display属性:表示元素是显示还是隐藏&lt;br&gt;
创建Vue里面的方法 el&amp;ndash;定义vue接管区域 data&amp;ndash;定义用到的数据模型 mounted&amp;ndash;挂载完成 methods&amp;ndash;定义用到的事件&lt;br&gt;
生命周期&lt;br&gt;
生命周期的八个阶段:每触发一个生命周期事件，会自动执行一个生命周期法子(钩子)&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;li&gt;beforeCreate&amp;mdash;-创建前&lt;br&gt;&lt;/li&gt;
&lt;li&gt;created&amp;mdash;-创建后&lt;br&gt;&lt;/li&gt;
&lt;li&gt;beforeMount&amp;mdash;-挂载前&lt;br&gt;&lt;/li&gt;
&lt;li&gt;mounted&amp;mdash;-挂载完成&lt;br&gt;&lt;/li&gt;
&lt;li&gt;beforeUpdate&amp;mdash;-更新前&lt;br&gt;&lt;/li&gt;
&lt;li&gt;updated&amp;mdash;-更新后&lt;br&gt;&lt;/li&gt;
&lt;li&gt;beforeDestroy&amp;mdash;-销毁前&lt;br&gt;&lt;/li&gt;
&lt;li&gt;destroyed&amp;mdash;-销毁后&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ajaxbr&#34;&gt;Ajax&lt;br&gt;
&lt;/h2&gt;&lt;p&gt;Ajax是异步的JS和XML&lt;br&gt;
作用&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据交换:通过Ajax可以给服务器发送请求，并获取服务器响应的数据&lt;br&gt;&lt;/li&gt;
&lt;li&gt;异步交互:可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术&lt;br&gt;
原生Ajax&lt;br&gt;
1.创建XMLHttpRequest对象:用于和服务器交换数据&lt;br&gt;
var xmlHttpRequest = new XMLHttpRequest();&lt;br&gt;
2.向服务器发送请求&lt;br&gt;
xmlHttpRequest.open(&amp;lsquo;get/post&amp;rsquo;，&amp;lsquo;url地址&amp;rsquo;);&lt;br&gt;
xmlHttpRequest.send();发送请求&lt;br&gt;
3.获取服务器响应数据&lt;br&gt;
先判断，如果响应成功就把数据赋值给一个变量&lt;br&gt;
因为比较繁琐，所有已经弃用了&lt;br&gt;
Axios&lt;br&gt;
介绍:Axios对原生的Ajax进行了封装，简化书写&lt;br&gt;
官网:Axios中文文档 | Axios中文网 (axios-http.cn)&lt;br&gt;
一般写在mounted(){&amp;hellip;}中，页面加载时完成函数回调，获取数据&lt;br&gt;
请求方式别名&amp;ndash;[表示可以省略]&lt;br&gt;&lt;/li&gt;
&lt;li&gt;axios.get(URL[，config])&lt;br&gt;&lt;/li&gt;
&lt;li&gt;axios.delete(URL[，config])&lt;br&gt;&lt;/li&gt;
&lt;li&gt;axios.post(URL[，data[，config]])&lt;br&gt;&lt;/li&gt;
&lt;li&gt;axios.put(URL[，data[，config]])&lt;br&gt;
.then(result =&amp;gt; {console.log(result.data);})回调函数&lt;br&gt;
回调函数里面也可以改成this.aaa=result.data，将数据直接返回给数据模型里面的数据&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;前端开发br&#34;&gt;前端开发&lt;br&gt;
&lt;/h2&gt;&lt;p&gt;前后端分离开发&lt;br&gt;
前端和后端分开开发，就需要遵守一个共同的规则，这个规则就是接口文档&lt;br&gt;
接口文档根据原型和需求来组成的&lt;br&gt;
步骤:需求分析-&amp;gt;接口定义(API接口文档)-&amp;gt;前后端并行开发-&amp;gt;测试-&amp;gt;前后端联调测试&lt;br&gt;
YApi&lt;br&gt;
介绍:YApi是高效，易用，功能强大的api管理平台，旨在为开发，产品，测试人员提高更优雅的接口管理服务&lt;br&gt;
地址: &lt;a class=&#34;link&#34; href=&#34;http://yapi.smart-xwork.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://yapi.smart-xwork.cn/&lt;/a&gt;&lt;br&gt;
添加项目-&amp;gt;添加分类-&amp;gt;添加接口-&amp;gt;然后就可以去mock地址查看生成的简略数据&lt;br&gt;
前端开发工程化&lt;br&gt;
介绍:是指在企业级的前端项目开发中，把前端开发所需要的工具，技术，流程，经验等进行规范化，标准化&lt;br&gt;
环境准备  vue-cli&lt;br&gt;
介绍: vue-cli是Vue官方提高的一个脚手架，用于快速生成一个Vue的项目模板&lt;br&gt;
Vue-cli提高了以下功能&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;统一的目录结构&lt;br&gt;&lt;/li&gt;
&lt;li&gt;本地调试&lt;br&gt;&lt;/li&gt;
&lt;li&gt;热部署&lt;br&gt;&lt;/li&gt;
&lt;li&gt;单元测试&lt;br&gt;&lt;/li&gt;
&lt;li&gt;继承打包上线&lt;br&gt;
依赖环境: NodeJS&lt;br&gt;
下载好node后配置好npm下载地址，然后更换好下载源，然后用npm命令下载vue-cli脚手架就配置好环境了&lt;br&gt;
Vue项目-创建&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;li&gt;第一种命令行: cmd里面输入vue create vue-project01&lt;br&gt;&lt;/li&gt;
&lt;li&gt;第二种图形化界面: cnd里面输入vue ui&lt;br&gt;
Vue项目-启动&lt;br&gt;
第一种:在目录栏最小面找npm脚本，然后在server那点按钮&lt;br&gt;
第二种:在cmd页面运行npm run serve&lt;br&gt;
然后就可以去浏览器查看vue界面了&lt;br&gt;
补充:如何修改端口号&lt;br&gt;
在vue.config.js中在最后面加上devServer: {port: 8080，}&lt;br&gt;
Vue项目开发流程&lt;br&gt;
import:引用模块   &amp;lt;==&amp;gt;  export:导出为模块&lt;br&gt;
Vue的组成文件以.vue结尾，每个组件由三个部分组成:&lt;template&gt;，&lt;script&gt;，&lt;style&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;template&gt;:模板部分，由这个生成HTML代码&lt;br&gt;&lt;/li&gt;
&lt;li&gt;
&lt;script&gt;:控制模板的数据来源和行为&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;style&gt;:css样式部分&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vue组件库Element&lt;br&gt;
Element:是饿了么团队研发的，一套为开发者，设计师和产品经理准备的基于Vue2.0的桌面组件库&lt;br&gt;
组件:组成网页的部件，例如 超链接，按钮，图片，表格，表单等&lt;br&gt;
官网:Element官网地址&lt;br&gt;
运行提示的插件&lt;br&gt;
&lt;br&gt;
常见组件&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Table表格(去官方文档)&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Pagination分页(添加事件去官方文档查看)&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Dialog对话框(依靠visible.sync来控制显示的)&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Form表单(具体看官方文档)&lt;br&gt;
补充标签插槽: &lt;template slot-scope=&#34;scope&#34;&gt;&lt;br&gt;
{{ scope.row.gender==1 ? &amp;lsquo;男&amp;rsquo;:&amp;lsquo;女&amp;rsquo; }}&lt;br&gt;
&lt;/template&gt;&lt;br&gt;
Vue的路由&lt;br&gt;
前端路由:URL中的hash(#号后的内容)与组件之间的对应关系&lt;br&gt;
就是切换显示的页面&lt;br&gt;
Vue Router插件&lt;br&gt;
介绍:Vue Router市Vue的官方路由&lt;br&gt;
组成: &lt;br&gt;&lt;/li&gt;
&lt;li&gt;VueRouter:路由器类，根据路由请求在在路由视图中动态渲染选中的组件(路由表)&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;router-link&gt;:请求链接组件，浏览器会解析成&lt;a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;router-view&gt;:动态视图组件，用来渲染和展示与路由路径对应的组件&lt;br&gt;
步骤:&lt;br&gt;
先安装:npm install &lt;a class=&#34;link&#34; href=&#34;mailto:vue-router@3.5.1&#34; &gt;vue-router@3.5.1&lt;/a&gt;&lt;br&gt;
然后定义路由:在router/index.js文件中&lt;br&gt;
两种定义方法:一种是提前用import引用;一种是component:()=&amp;gt;import(&amp;rsquo;&amp;hellip;.&amp;rsquo;)直接引用&lt;br&gt;
然后就可以使用&lt;router-link to=&#39;/..&#39;&gt;定义跳转内容&lt;br&gt;
然后在App.vue中注释掉引用的vue页面改成&lt;router-view&gt;动态视图&lt;br&gt;
补充:path:&amp;rsquo;/&amp;rsquo;， (回车)redirect: &amp;lsquo;/emp&amp;rsquo; &amp;mdash; 表示如果访问的是/就交给/emp处理&lt;br&gt;
打包部署&lt;br&gt;
先要打包:在终端运行npm run build然后会产生一个dist文件夹&lt;br&gt;
然后用nginx部署Nginx官网&lt;br&gt;
介绍nginx:conf&amp;ndash;配置文件目录  html&amp;ndash;静态资源文件目录  logs&amp;ndash;日志文件目录  temp&amp;ndash;临时文件目录&lt;br&gt;
nginx默认占用80端口&lt;br&gt;
netstat -ano | findStr 80 &amp;ndash; 查看端口号    也可以去conf/nginx.conf中改端口号&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mavenbr&#34;&gt;Maven&lt;br&gt;
&lt;/h2&gt;&lt;p&gt;Maven的作用&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;依赖管理:只需要在maven工程的pom.xml文件中根据格式写需要什么包maven会自动联网下载&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;li&gt;统一项目结构:统一的项目结构&lt;br&gt;&lt;/li&gt;
&lt;li&gt;项目构建:标准化的项目构建流程&lt;br&gt;
Maven是一款管理和构建java项目的工具Maven官网&lt;br&gt;
&lt;br&gt;
仓库:用于存储资源，管理各种jar包&lt;br&gt;&lt;/li&gt;
&lt;li&gt;本地仓库:自己计算机上的目录&lt;br&gt;&lt;/li&gt;
&lt;li&gt;中央仓库:由Maven团队维护的全球唯一的.仓库地址: maven中央仓库&lt;br&gt;&lt;/li&gt;
&lt;li&gt;远程仓库(私服):一般由公司团队搭建的私有仓库&lt;br&gt;
安装&lt;br&gt;
1.解压apache-maven-3.6.~-bin.zip&lt;br&gt;
2.配置本地仓库:修改conf/settings.xml中的&lt;localRepository&gt;&lt;br&gt;
3.配置阿里云私服:修改conf/setting.xml中的&lt;mirrors&gt;添加下面内容&lt;br&gt;
&lt;mirror&gt;&lt;br&gt;
&lt;id&gt;alimaven&lt;/id&gt;&lt;br&gt;
&lt;name&gt;aliyun maven&lt;/name&gt;&lt;br&gt;
&lt;url&gt;&lt;a class=&#34;link&#34; href=&#34;http://maven.aliyun.com/nexus/content/groups/public&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/a&gt;&lt;/url&gt;&lt;br&gt;
&lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;br&gt;
&lt;/mirror&gt;&lt;br&gt;
4.配置环境变量:MAVEN_HOME为maven的解压目录，并将其bin目录加入PATH环境变量&lt;br&gt;
配置Maven&lt;br&gt;
1.idea中配置Maven环境&lt;br&gt;
File-&amp;gt;Settings-&amp;gt;build，Execution，..-&amp;gt;Build Tools-&amp;gt;Maven&lt;br&gt;
设置idea使用本地maven，并修改配置文件及本地仓库路径&lt;br&gt;
全局配置是从close project进去Settings&lt;br&gt;
2.创建Maven项目&lt;br&gt;
创建模块，选择Maven，创建项目&lt;br&gt;
3.导入Mavenue项目&lt;br&gt;
方式一:在右侧Maven面版，点+号选择对应项目中的pom.xml文件即可&lt;br&gt;
方式二:File-&amp;gt;Project Stru&amp;hellip;-&amp;gt;Modules-&amp;gt;+-&amp;gt;import Module-&amp;gt;Module-&amp;gt;pom.xml&lt;br&gt;
Maven坐标&lt;br&gt;
Maven中的坐标是资源的唯一标识，可以用来定义项目和引入项目需要的依赖&lt;br&gt;
Maven左边组成&lt;br&gt;&lt;/li&gt;
&lt;li&gt;groupid:定义Maven项目属于什么组织&lt;br&gt;&lt;/li&gt;
&lt;li&gt;artifactld:定义Maven项目名称&lt;br&gt;&lt;/li&gt;
&lt;li&gt;version:定义当前版本号&lt;br&gt;
依赖管理&lt;br&gt;
依赖:指当前项目运行所需要的jar包，一个项目中可以引入多个依赖&lt;br&gt;
依赖配置&lt;br&gt;
1.在pom.xml中编写&lt;dependencies&gt;标签&lt;br&gt;
2.在&lt;dependencies&gt;标签中使用&lt;dependency&gt;引入坐标&lt;br&gt;
3.定义坐标的groupid，artifactid，version&lt;br&gt;
4.点刷新按钮，引入最新加入的坐标&lt;br&gt;
如果不知道依赖的坐标信息可以到 &lt;a class=&#34;link&#34; href=&#34;https://mvnrepository.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mvnrepository.com/&lt;/a&gt; 中搜索&lt;br&gt;
依赖传递&lt;br&gt;
依赖具有传递性&lt;br&gt;&lt;/li&gt;
&lt;li&gt;直接依赖:在当前项目中通过依赖配置建立的依赖关系&lt;br&gt;&lt;/li&gt;
&lt;li&gt;间接依赖:被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源&lt;br&gt;
排除依赖:主动断开依赖的资源被排除的依赖不需要指定版本，用&lt;exclusions&gt;实现&lt;br&gt;
依赖范围:默认情况下，可以在任何地方使用可以通过&lt;scope&gt;设置其使用范围&lt;br&gt;
&lt;br&gt;
生命周期&lt;br&gt;
Maven的生命周期就是为了对所有的maven项目构建过程进行抽象和统一&lt;br&gt;
Maven中有3套相互独立的生命周期&lt;br&gt;&lt;/li&gt;
&lt;li&gt;clean:清理工作&lt;br&gt;&lt;/li&gt;
&lt;li&gt;default:核心工作，如:编译，测试，打包，安装，部署等&lt;br&gt;&lt;/li&gt;
&lt;li&gt;site:生成报告，发布站点等&lt;br&gt;
每套生命周期包含一些阶段(phase)，阶段是有顺序的，后面的阶段依赖与前面的阶段    &lt;br&gt;
常见的阶段:(在Maven面版的Lifecycle中都有)&lt;br&gt;&lt;/li&gt;
&lt;li&gt;clean:移除上一次构建生成的文件&lt;br&gt;&lt;/li&gt;
&lt;li&gt;compile:编译项目源代码&lt;br&gt;&lt;/li&gt;
&lt;li&gt;test:使用合适的单元测试框架运行测试(junit)&lt;br&gt;&lt;/li&gt;
&lt;li&gt;package:将编译后的文件打包&lt;br&gt;&lt;/li&gt;
&lt;li&gt;install:安装项目到本地仓库&lt;br&gt;
注意:在同一套生命周期中，运行后面阶段，前面阶段也会运行&lt;br&gt;
运行方式:直接在面板中双击/在终端中用命令 mvn 阶段名&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;web后端开发br&#34;&gt;Web后端开发&lt;br&gt;
&lt;/h2&gt;&lt;p&gt;SpringBootWeb入门   Spring官网&lt;br&gt;
Spring发展到今天已经形成一种开发生态圈，Spring提高了若干子项目，每个项目用于完成特定功能&lt;br&gt;
Spring全家桶中Spring Framework是基础，最底层，但是配置繁琐，入门难度大，所以有了Spring Boot&lt;br&gt;
创建一个SpringBootWeb工程&lt;br&gt;
1.创建springboot工程，并勾选web开发相关依赖&lt;br&gt;
2.定义HelloController类，添加方法hello，并添加注解(请求处理类注解@Rest&amp;hellip;，然后在方法上面定一个浏览器接口@Reque&amp;hellip;)&lt;br&gt;
3.运行测试&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;http协议br&#34;&gt;HTTP协议&lt;br&gt;
&lt;/h2&gt;&lt;p&gt;概念:超文本传输协议，规定了浏览器和服务器之间数据传输的规则&lt;br&gt;
特点&lt;br&gt;
基于TCP协议:面向连接，安全&lt;br&gt;
基于请求-响应模型的:一次请求对应一次响应&lt;br&gt;
HTTP协议是无状态的协议:对于事务处理没有记忆功能.每次请求响应都是独立的&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缺点:多次请求间不能共享数据&lt;br&gt;&lt;/li&gt;
&lt;li&gt;优点:速度块&lt;br&gt;
HTTP-请求数据格式&lt;br&gt;
请求行:请求数据第一行(请求方式，资源路径，协议)&lt;br&gt;
请求头:第二行开始(key:value的格式)&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Host:请求的主机名&lt;br&gt;&lt;/li&gt;
&lt;li&gt;User-Agent:浏览器版本&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Accept:表示浏览器能接收的数据&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Accept-Language:表示浏览器偏好的语言&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Accept-Encoding:表示浏览器可以支持的压缩类型&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Content-Type:请求主体的数据类型&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Content-Length:请求主体的大小(单位:字节)&lt;br&gt;
请求体:post请求，存放请求参数，和请求头之间存在一个空行分隔&lt;br&gt;
注意:get请求没有请求体，请求参数在请求行中&lt;br&gt;
HTTP-响应数据格式&lt;br&gt;
响应行:响应数据第一行(协议，状态码，描述)&lt;br&gt;
响应头:第二行开始(格式key:value)&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Content-Type:表示响应内容类型&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Content-Length:表示响应内容长度&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Content-Encoding:表示响应压缩算法&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Cache-Control:指示客户端应如何缓存&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Set-Cookie:告诉浏览器为当前页面所在域设置cookie&lt;br&gt;
响应体:和响应头之间存在一个空行分隔，存放响应数据&lt;br&gt;
响应码:响应状态码&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tomcatbr&#34;&gt;Tomcat&lt;br&gt;
&lt;/h2&gt;&lt;p&gt;Tocat是Apache软件基金会的一个核心项目，是开源免费的轻量级web服务器，支持Servelt/JSP少量JavaEE规范&lt;br&gt;
JavaEE:Java企业版，只Java企业级开发技术总和&lt;br&gt;
Tomcat也被称为Web容器，Servlet容器，Servlet程序需要依赖Tomcat才能运行&lt;br&gt;
官网:Tomcat&lt;br&gt;
bin:可执行文件 conf:配置文件 lib:依赖包文件 logs:日志文件 temp:临时文件 webapps应用发布目录 work:工作目录&lt;br&gt;
请求响应&lt;br&gt;
DispatcherServlet:前端控制器&lt;br&gt;
把浏览器的请求信息封装到HttpServletRequest中去处理，把响应数据封装到HttpServletResponse中去响应&lt;br&gt;
原始方式获取请求参数&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Controller方法形参中声明HttpServletRequest对象&lt;br&gt;&lt;/li&gt;
&lt;li&gt;调用对象的getParameter(参数名)&lt;br&gt;
SpringBoot中接收简单参数&lt;br&gt;&lt;/li&gt;
&lt;li&gt;请求参数名与方法形参变量名相同&lt;br&gt;&lt;/li&gt;
&lt;li&gt;会自动进行类型转换&lt;br&gt;
@RequestParam注解&lt;br&gt;&lt;/li&gt;
&lt;li&gt;方法形参名称与请求参数名称不匹配，通过该注解进行映射&lt;br&gt;&lt;/li&gt;
&lt;li&gt;该注解的required属性默认是true，代表请求参数必须传递&lt;br&gt;
实体参数:简单实体对象:请求参数名与形参对象属性名要相同，定义实体类接收即可(如果是复杂实体对象，按照层次对应起来就行)&lt;br&gt;
数组集合参数&lt;br&gt;
数组参数:请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接收参数&lt;br&gt;
集合参数:请求参数名与形参集合名称相同且请求参数为多个，@RequestParam绑定参数关系&lt;br&gt;
日期参数:使用@DateTimeFormat(pattern=&amp;ldquo;日期格式&amp;rdquo;)注解完成日期参数格式转换&lt;br&gt;
Json参数:JSON数据键名与形参类对象属性名相同，定义实体类类型形参即可接收参数，需要使用@RequestBody标识&lt;br&gt;
路径参数:通过请求URL直接传递参数，使用{&amp;hellip;}来标识该路径参数，需要使用@PathVariable获取参数路径&lt;br&gt;&lt;/li&gt;
&lt;li&gt;注意例:@RequestMapping(&amp;quot;/path/{id}/{name}/&amp;hellip;&amp;rdquo;)&amp;mdash;在声明类注解时后面的URL地址不能写死&lt;br&gt;
设置响应数据&lt;br&gt;
@ResponseBody&lt;br&gt;
类型:方法注解，类注解&lt;br&gt;
位置:Controller方法上/类下&lt;br&gt;
作用:将方法返回值直接响应，如果返回值类型是实体对象/集合，将转换成Json格式响应&lt;br&gt;
说明:@RestController=@Controller+@ResponseBody;&lt;br&gt;
返回类型不一致，不便管理，难以维护&lt;br&gt;
创建一个Result(code，msg，data)实体类，code表示状态码，msg表示方法名，data表示要返回的数据，这样格式就统一了&lt;br&gt;
实验例子&lt;br&gt;
前提:引入了一个XmlParserUtils工具类解析xml文件的，和一个emp.xml文件里面是数据源，和一个静态html页面&lt;br&gt;
要求:把emp.xml文件里面的数据解析出来，然后通过处理，最后封装到Result类中返回给前端，然后渲染出来&lt;br&gt;
&lt;br&gt;
解析:file的获取使用了反射的原理&lt;br&gt;
List&lt;Emp&gt; empList = XmlParserUtils.parse(file，Emp.class)&amp;mdash;Emp.class是一个类不是实例，empList是一个实例集合&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分层解耦br&#34;&gt;分层解耦&lt;br&gt;
&lt;/h2&gt;&lt;p&gt;把数据功能分层次安放&lt;br&gt;
三层架构&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;controller:控制层，接收前端发送的请求，对请求进行处理，并响应数据&lt;br&gt;&lt;/li&gt;
&lt;li&gt;service:业务逻辑层，处理具体的业务逻辑&lt;br&gt;&lt;/li&gt;
&lt;li&gt;dao:数据访问层(持久层)，负责数据访问操作，包括数据的增，删，改，查&lt;br&gt;
便于管理，维护，和扩展&lt;br&gt;
分层解耦&lt;br&gt;&lt;/li&gt;
&lt;li&gt;内聚:软件中各个功能模块内部的功能联系&lt;br&gt;&lt;/li&gt;
&lt;li&gt;耦合:衡量软件中各个层/模块之间的依赖，关联程度 &lt;br&gt;
高内聚，低耦合&lt;br&gt;
想要解耦就需要一个容器来存放对象，就有了控制反转和依赖注入&lt;br&gt;&lt;/li&gt;
&lt;li&gt;控制反转:简称IOC，对象的创建控制权由程序自身转移到外部(容器)，这种思想叫控制反转&lt;br&gt;&lt;/li&gt;
&lt;li&gt;依赖注入:简称DI，容器为应用程序提供运行时，所依赖的资源，称为依赖注入&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Bean对象:IOC容器中创建，管理的对象称为bean&lt;br&gt;
IOC和DI入门&lt;br&gt;
1.Service层及Dao层的实现类，交给IOC容器管理&lt;br&gt;
2.为Controller及Service注入运行时，依赖的对象&lt;br&gt;
3.运行测试&lt;br&gt;
@Component 注解表示将当前类交给IOC容器管理，成为IOC容器对象(控制反转)&lt;br&gt;
@Autowired 注解表示运行时，IOC容器会提供该类型的bean对象，并赋值给该变量(依赖注入)&lt;br&gt;
IOC详解&lt;br&gt;
Bean的声明&lt;br&gt;&lt;/li&gt;
&lt;li&gt;@Component:声明bean的基础注解，不属于三类时就用这个注解，下面三个是这个的衍生注解&lt;br&gt;&lt;/li&gt;
&lt;li&gt;@Controller:标注在控制器上&lt;br&gt;&lt;/li&gt;
&lt;li&gt;@Service:标注在业务类上&lt;br&gt;&lt;/li&gt;
&lt;li&gt;@Repository:标注在数据访问类上(由于与Mybatis整合，用的少)&lt;br&gt;
注意:声明bean时，可通过value属性来声明名字，默认是类名首字母小写&lt;br&gt;
使用以上四个注解都可以声明bean，但在springboot集成web开发中，声明控制器bean只能使用@Controller&lt;br&gt;
Bean组件扫描&lt;br&gt;
前面声明bean四大注解，要想生效，需要被组件扫描注解@ComponentScan扫描&lt;br&gt;
该扫描注解没显示配置，但是包含在启动类声明注解中，默认扫描范围是启动类所在包及其子包&lt;br&gt;
如果无法移动包就可以用@ComponentScan({&amp;quot;..&amp;quot;，&amp;quot;..&amp;quot;})可以定义要扫描的包(不建议)&lt;br&gt;
DI详解&lt;br&gt;
@Autowired注解，默认是按照类型进行，如果存在多个类型的bean，会报错&lt;br&gt;
有以下解决方案&lt;br&gt;&lt;/li&gt;
&lt;li&gt;@Primary&lt;br&gt;
设置bean注入的优先级&lt;br&gt;&lt;/li&gt;
&lt;li&gt;@Qualifier&lt;br&gt;
@Qualifier(&amp;ldquo;bean别名&amp;rdquo;)指定注入的那个bean&lt;br&gt;&lt;/li&gt;
&lt;li&gt;@Resource&lt;br&gt;
不使用@Autowired直接用@Resource来指定注入哪个bean，这个是jdk里面的方法:@Resource(name=&amp;ldquo;bean别名&amp;rdquo;)&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mysql数据库br&#34;&gt;MySQL数据库&lt;br&gt;
&lt;/h2&gt;&lt;p&gt;数据库(DB)，是存储和管理数据的仓库&lt;br&gt;
数据库管理系统(DBMS)，操纵和管理数据库的大型软件&lt;br&gt;
SQL，操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准&lt;br&gt;
MySQL概述&lt;br&gt;
MySQL的按照与配置&lt;br&gt;
MySQL数据模型&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;关系型数据库:建立在关系模型基础上，由多张相互关联的二维表组成的数据库&lt;br&gt;
a.便于表存储数据，格式统一，便于维护&lt;br&gt;
b.使用SQL语言操作，标准统一，使用方便可用于复杂查询&lt;br&gt;
SQL简介&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SQL:一门操作关系型数据库的编程语言，定义操作所有关系型数据库的统一标准&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SQL语句可以多行和单行，以分号结尾&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不区分大小写，可以用空格缩进来增加可读性&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单行注释 &amp;ndash; aaa或# aaa，多行注释 /&lt;em&gt;aaa&lt;/em&gt;/&lt;br&gt;
SQL的分类&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DDL:数据定义语言(表，字段)&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DML:数据操作语言(增删改查)&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DQL:数据查询语言&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DCL:数据控制语言&lt;br&gt;
数据库设计-DDL&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;show databases;select database();&amp;ndash; 查询&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;use 数据库名;&amp;ndash; 选择操作的数据库&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;create database [if not exists] 数据库名;&amp;ndash; 创建数据库&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;drop database[if exists] 数据库名;&amp;ndash; 删除数据库&lt;br&gt;
注意:上述语法中database可以替换成schema&lt;br&gt;
创建表操作:create table 名(字段1 类型 [约束] [comment 字段1注释]，&amp;hellip;)&lt;br&gt;
约束:非空&amp;ndash;not null  唯一&amp;ndash;unique  主键&amp;ndash;primary key  默认&amp;ndash;default  外键&amp;ndash;foreign key  auto_increment&amp;ndash;自增&lt;br&gt;
数据类型:主要分三类数值类型，字符串类型，日期时间类型&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
查询表结构:desc 表名;&lt;br&gt;
查询建表语句:show create table 表名;&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;alter table 表名 add 字段名 类型 [comment 注释];&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;alter table 表名 modifty 字段名 新字段类型;&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;alter table 表名 change 旧字段名 新字段名 类型 [comment 注释];&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;alter table 表名 drop column 字段名;&amp;ndash;删除&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;rename table 表名 to 新表名;&lt;br&gt;
数据库操作-DML&lt;br&gt;
添加数据(insert)&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;insert into 表名 (字段1，&amp;hellip;) values (值1，&amp;hellip;);&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;insert into 表名 values (值1，&amp;hellip;);&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;insert into 表名 (字段1，&amp;hellip;) values (值1，&amp;hellip;)，(值2，&amp;hellip;);&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;insert into 表名 values (值1，&amp;hellip;)，(值2，&amp;hellip;);&lt;br&gt;
更新数据(update)&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;update 表名 set 字段名1 = 值1，字段名2 = 值2，&amp;hellip;[where 条件];&lt;br&gt;
删除数据(delete)&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;delete from 表名 [where 条件];&lt;br&gt;
数据查询-DQL&lt;br&gt;
语法: select [distinct&amp;ndash;去重] 字段列表 [as 别名]，&amp;hellip; from 表名列表 [group by 分组字段列表 [having 分组后条件列表]] [order by 字段1 排序方式1，&amp;hellip;] [limit     起始索引，每页数据个数];
注意:分组后一般查询字段为聚合函数和分组字段，分组后的判断条件要放到having后;排序&amp;ndash;asc升序(默认)，desc降序
比较运算符: &amp;gt;，&amp;gt;=，&amp;lt;，&amp;lt;=，=，&amp;lt;&amp;gt;/!=，between&amp;hellip;and&amp;hellip;，in(&amp;hellip;)，like _a/%a&amp;ndash;_表示一个字符%表示任意个字符，is null
逻辑运算符: and/&amp;amp;&amp;amp;，or/||，not/!
聚合函数:conunt(..)，min(..)，max(..)，avg(..)，sum(..)&amp;mdash;null值不参于所有聚合函数运行
流程控制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;if(条件表达式，true取值，false取值)&amp;mdash;类似于三元运算符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(case字段/表达式 when 值1 then 结果1 [when 值2 then 结果2 &amp;hellip;] [else 值*] end)&amp;mdash;如果是值1就展示结果1
多表设计
概述:多表结构分为三种&amp;mdash;-一对多，多对多，一对一
一对多表问题可能会造成数据的不完整，不一致问题，所有要进行外键约束，保证数据的完整和一致性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建表时关联:在语句最后加上[constraint] [外键名称] foreign key (外键字段名) references 主表 (字段名)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改表结构关联:alter table 表名 add constraint 外键名称 foreign key (外键字段名) references 主表(字段名);
上面的定义的都是物理外键，缺点是影响增删改查(需要检索外键关系)，仅适用于单节点，不适应分布式，集群，容易引发数据库死锁问题
一般开发都使用逻辑外键，概念:在业务层逻辑中，解决外键关联
一对一多用于单表拆分，一张表基础字段放在一张表中，其他字段放在另一个表，提示操作效率
实现:在任意一方加入外键，关联另一方主键，并且设置外键为唯一约束(unique)
多对多用单纯的关联比较繁琐，所有可以用一个中间表来实现
实现:建立第三个中间表，中间表至少包含两个外键，分别关联两方主键
多表查询
普通的多表查询在from后面直接加入表名，回导致笛卡尔积&amp;mdash;两个表数据个数相乘用where消除无用的笛卡尔积
分类:连接查询(内连接，外连接(左外连接，右外连接))，子查询
内连接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隐式内连接:select 字段列表 from 表1，表2 where 条件&amp;hellip;;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;显式内连接:select 字段列表 from 表1 [inner] join 表2 on 连接条件&amp;hellip;;
外连接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;左外连接:select 字段列表 from 表1 left [outer] join 表2 on 连接条件&amp;hellip;;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;右外连接:select 字段列表 from 表1 right [outer] join 表2 on 连接条件&amp;hellip;;
左外连接会完全包含左表数据同时包含交集数据，右外连接同理
子查询&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SQL中语句嵌套select语句称为嵌套查询，也称子查询&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;形式:select * from t1 where 字段名1=(select 字段名1 from t2 &amp;hellip;);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子查询外部的语句可以是insert/update/delete/select，常见的还得是select&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分类:标量子查询(返回单个值)，列子查询(返回一列)，行子查询(返回一行)，表子查询(返回多行多列)
补充条件判断方法:in，not in，(aa，bb)=(&lt;strong&gt;，&lt;/strong&gt;)，把查询结果当表使用&amp;ndash;直接写在from后如何起个别名
事务
事务是一组操作的集合，它是一个不可分隔的工作单位，事务会把所有的操作作为一个整体，一起向系统提交或撤销操作申请，即这些操作要么同时成功，要么同时失败&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;默认MySQL的事务时自动提交的，也就是说，当执行一条DML语句的时候，MySQL会立即隐式提交事务
1.开启事务:start transaction; / begin;
2.提交事务:commit;
3.回滚事务:rollback;
四大特性:原子性，一致性，隔离性，持久性
索引
索引是帮助数据库高效获取数据的数据结构
优点:提高数据库查询的效率，通过索引列对数据排序，降低CPU消耗
缺点:索引会占用磁盘空间，提高查询效率但是会降低insert，update，delete的效率
索引结构:Hash索引，B+Tree索引，Full-Text索引，一般默认索引是B+Tree索引
B+Tree(多路平衡搜索树):&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个节点，可以存储多个key(有n个key，就有n个指针)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有的数据都存储在叶子节点，非叶子节点仅用于索引数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;叶子节点形成一颗双向链表，便于数据的排序及区间范围查询
创建索引:create [unique] index 索引名 on 表名 (字段名，&amp;hellip;);
查看索引:show index from 表名;
删除索引:drop index 索引名 on 表名;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mybatis&#34;&gt;MyBatis
&lt;/h2&gt;&lt;p&gt;MyBatis是一款优秀的持久层框架，用于简化JDBC的开发，mybatis官网
在mybatis中，使用的任何功能都需要先引入依赖
1.准备工作(创建sprignboot工程，数据库表user，实体类User)
2.引入Mybatis的相关依赖，配置Mybatis
3.编写SQL语句(接口类/注解/XML)
例子: &lt;br&gt;
a.准备好user表和User实体类
b.然后去resources中配置数据库连接语句
c.然后建立一个接口实现查询语句
d.在接口类名上加上@Mapper会自动生成代理然后加入到ioc中，在方法名上加上@Select(&amp;ldquo;select * from text&amp;rdquo;)这样调用方法就会自动执行注解里面的查询语句
e.然后再测试类中加入注解@Autowired用ioc自动生成注解然后就可以在测试方法上@Test注解表示测试调用接口中的方法去查询数据库表内容
JDBC介绍
JDBC就是使用Java语言操作关系型数据库的一套API
sun公司官方定义的一套操作所有关系型数据库的规范，即接口
各个数据库厂商去实现这套接口，提供数据库驱动jar包
我们可以使用这套接口编程，真正执行代码的是驱动jar包中的实现类
JDBC直接使用太过繁琐，现在大部分都是在使用类似于mybatis的工具包来进行连接和操作数据库
数据库连接池
数据库连接池是一个容器，负责分配，连接数据库(Connection)
它允许数据库重复使用一个现有的数据库连接，而不是新建一个
释放，空闲时间超过最大空闲时间的连接，来避免因为没有释放而引起的数据库连接遗漏&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标准接口: DataSource
官方(sun)提供的数据库连接池接口，由第三方组织实现此接口
功能:获取连接 &amp;mdash; Connection getConnection() throws SQLException;
产品:C3P0(淘汰)，DBCP(淘汰)，Druid(阿里云的)，Hikari(spring boot默认)
Lombok
Lombok是一个实用的Java类库，能通过注解的形式自动生成构造器.get/set，equals等方法，并可以自动生成日志变量，简化Java开发，提高效率&lt;/li&gt;
&lt;li&gt;@Getter/@Setter &amp;ndash; 为所有的属性提高get和set方法&lt;/li&gt;
&lt;li&gt;@ToString &amp;ndash; 会给类自动生成易阅读是toString方法&lt;/li&gt;
&lt;li&gt;@EqualsAndHashCode &amp;ndash; 根据类所拥有的非静态字段自动重写equals方法和hashCode方法&lt;/li&gt;
&lt;li&gt;@Data &amp;ndash; 提高了更综合的生成代码功能(get+set+tostring+equalsandhashcode)&lt;/li&gt;
&lt;li&gt;@NoArgsConstructor &amp;ndash; 为实体类生成无参的构造器方法&lt;/li&gt;
&lt;li&gt;@AllArgsConstructor &amp;ndash; 为实体类生成除了static修饰的字段之外带有各参数的构造器方法&lt;/li&gt;
&lt;li&gt;补充:@Slf4j &amp;ndash; 引入日志框架，下面就可以直接使用日志了
注意:需要插件，一般安装idea时自动安装好了
增删改查
删除
在接口中定义一个方法，然后再方法上面加上@Delete(&amp;quot;&amp;hellip;&amp;quot;)注解，然后去测试类中用ioc自动注入调用接口中的方法执行注解中的SQL语句
新增
和删除差不多，使用@Insert(&amp;quot;&amp;hellip;&amp;quot;)，就是如果字段多了，可以用实体类封装一下
如果要获取表字段信息: @Options(keyProperty=&amp;ldquo;id&amp;rdquo;，useGeneratedKeys=true):会自动将生成的主键值返回给id属性
更新
用id来确定更新那个字段，@Update(&amp;quot;&amp;hellip;&amp;quot;)
查询
查询信息@Select(&amp;quot;&amp;hellip;&amp;quot;)，但是查询中如果属性名和字段名不一致就无法自动封装
数据封装:属性名和字段名一致mybatis会自动封装，不一致可以在查询时起别名或者开启驼峰映射或者使用@Results/@Result手动映射&lt;/li&gt;
&lt;li&gt;起别名:起一个和属性名一样的别名，就可以自动封装到实体类中&lt;/li&gt;
&lt;li&gt;驼峰映射:搜索关键字camel   &amp;hellip;camel&amp;hellip;=true&lt;/li&gt;
&lt;li&gt;@Results/@Result:网上搜索去吧，懒得写
预编译SQL:性能更高，更安全(防止SQL注入)
参数占位符 #{&amp;hellip;}&amp;ndash;执行时会变成?(预编译)   ${&amp;hellip;}&amp;ndash;执行时会拼接SQL语句存在SQL注入问题(对表名，列表动态设置时使用)
字符串拼接函数:concat(&amp;lsquo;aa&amp;rsquo;，&amp;lsquo;bb&amp;rsquo;，&amp;lsquo;cc&amp;rsquo;) = aabbcc  &amp;mdash;-  可以解决模糊查询时预编译?在&amp;rsquo; &amp;lsquo;里面的问题
XML映射文件
mybatis中文网
🌐规范:&lt;/li&gt;
&lt;li&gt;XML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在同一个位置包下(同包同名)&lt;/li&gt;
&lt;li&gt;XML映射文件中的namespace属性为Mapper接口全限定名一致&lt;/li&gt;
&lt;li&gt;XML映射文件中sql语句的id与Mapper接口中的方法名一致，并保持返回类型一致&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MybatisX是一款基于IDEA的快速开发Mybaits的插件，为效率而生
Mybatis动态SQL
随着用户的输入或外部条件的变化而变化的SQL语句，我们称为动态SQL语句&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;if&gt;:用于判断条件是否成立，使用test属性进行条件判断，如果为true，就拼接SQL&lt;/li&gt;
&lt;li&gt;&lt;where&gt;:外层包裹标签，可以自动识别里面是否有条件满足，如果没有就不会执行where语句，并且会自动去除开头多余的and&lt;/li&gt;
&lt;li&gt;&lt;set&gt;:也是包裹标签，功能是动态的在行首插入一个set关键字，且可自动去除字段后多余的逗号(一般用于update中)&lt;/li&gt;
&lt;li&gt;&lt;foreach&gt;:collection-遍历的集合;item-遍历出来的元素;separator-分隔符;open-开始前拼接的片段;close-结束后拼接的片段&lt;/li&gt;
&lt;li&gt;&lt;sql&gt;&lt;include&gt;:sql标签负责抽取xml文件中重复的SQL语句有id值，include负责引用sql标签使用refid属性引用sql的id值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;补充:开发规范-Restful-&amp;gt;REST，表述性状态转换，它是一种软件架构风格&lt;/p&gt;
&lt;h2 id=&#34;文件上传功能&#34;&gt;文件上传功能
&lt;/h2&gt;&lt;p&gt;是指将本地图片，视频，音频等文件上传到服务器，供其他用户浏览下载
文件上传在项目中应用非常广泛，我们经常发微信，朋友圈，微博都用到了文件上传功能
1.首先在前端定义有一个表单项input类型是file类型的，这样就有了选择文件的输入框
2.其次上传方式要选择post方式
3.然后在form表单中设置上传格式 enctype=&amp;ldquo;multipart/form-data&amp;rdquo;，因为默认提交方式不会提交大型数据
4.在后端定义个接口，同时接收数据用MultipartFile(MultipartFile image)格式来接收文件数据
5.如果要保存到本地中要使用，先用image.getOriginalFilename()方法来获取文件的全部名称(包括后缀名)
6.然后调用image.transferTo(new File(&amp;ldquo;D:\&amp;quot;+文件名称))来将传输上来的文件保存到本地
7.直接获取的文件名重复会覆盖文件，所以最好还是使用UUID来命名，JavaEE讲过的
8.然后用字符串截取int index = lastIndexOf(&amp;rdquo;.&amp;quot;)/filename.substring(index)，获取文件后缀名，最后拼接成最终的文件名
注意:&lt;/p&gt;
&lt;p&gt;spring.servlet.multipart.max-file-size=10MB &amp;mdash;- 设置单个文件传输最大限额为10MB
spring.servlet.multipart.max-request-size=100MB &amp;mdash;- 设置多个文件上传总共限额为100MB
在实际开发中，本地存储已经不咋使用了，因为容易磁盘饱满，而且用户也无法访问，一般都是使用云端存储
示例阿里云
阿里云是阿里巴巴旗下全球领先的云计算公司，也是国内最大的云服务提供商，阿里云存储服务OSS
使用第三方服务的通用思路:准备工作-&amp;gt;参照官方SDK编写入门程序-&amp;gt;集成使用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SDK:软件工具开发包，包括辅助软件开发依赖(jar)包，代码示例等，都可以叫做SDK
阿里云OSS使用步骤:注册账号-&amp;gt;充值-&amp;gt;开通对象存储服务-&amp;gt;创建bucket-&amp;gt;获取AccessKey(密钥)-&amp;gt;SDK入门程序-&amp;gt;案例集成OSS&lt;/li&gt;
&lt;li&gt;Bucket:存储空间是用户用于存储对象(Object，就是文件)的容器，所有对象都必须隶属于某个存储空间
阿里云idea配置
先去官方文档找pom文件的依赖，配置好
然后找文件上传实例代码复制，直接粘贴到idea的测试代码目录下
配置信息&lt;/li&gt;
&lt;li&gt;endpoint:域名地区的访问地址&lt;/li&gt;
&lt;li&gt;accessKeyId:密钥ID&lt;/li&gt;
&lt;li&gt;accessKeySecret:密钥&lt;/li&gt;
&lt;li&gt;bucketName:要上传到那个bucke中&lt;/li&gt;
&lt;li&gt;objectName:上传上去的对象叫什么&lt;/li&gt;
&lt;li&gt;filePath:上传的文件本地路径&lt;/li&gt;
&lt;li&gt;再往下就是具体的执行代码了
因为这些配置信息太多，而且一改动就很麻烦，所有将这些配置信息写道配置文件中最好
properties&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再application.properties中写好key和value配置信息后
再代码中需要用@value()来引用配置信息 具体语法: @value(&amp;quot;${配置信息中的key}&amp;quot;)
示例: @Value(&amp;quot;${aliyun.oss.endpoint}&amp;quot;)
private String endpoint;
第二种配置文件格式yml或yaml&lt;/p&gt;
&lt;p&gt;yml和yaml就是后缀名不一样，其余一样，yml现在用的最多
yml配置是按照层级配置的，数组，list，set元素前加个 -
yml基本语法
1.大小写敏感
2.数值前必须有空格，作为分隔符
3.使用缩进表示层级关系，缩进时不允许使用Tab键，只能用空格
4.缩进空格数据不重要，只要相同级的元素左对齐就行
第三种s配置文件格式xml&lt;/p&gt;
&lt;p&gt;xml配置是用标签来定义的&lt;/p&gt;
&lt;p&gt;上面书写了配置文件中定义了配置信息，然后再代码中引用配置文件中信息的方法，还是有点繁琐，需要每个元素都亲自写注解，解决方法:
首先新建个实体类定义元素，和配置文件中的元素名字要一致
然后加入@Component注解交给IOC容器
然后加上@ConfigurationProperties(perfix=&amp;quot;*&lt;strong&gt;.&lt;/strong&gt;&amp;quot;) &amp;ndash; 这个作用是写上配置文件中key值的前缀
然后就可以在代码类中加入@Autowired自动注入，就可以使用了
图例
可选操作:引入依赖，spring-boot-configuration-processor 这个依赖可以让在配置文件书写外部配置信息时idea自动提示配置信息，可以引入，也可以不引入，不影响程序执行，会把实体类中的红色警告变成灰色，没啥影响
注意:@ConfigurationProperties和@Value都是注入外部配置信息的，配置信息少可以用value，批量配置信息可以用另一个&lt;/p&gt;
&lt;h2 id=&#34;登录校验&#34;&gt;登录校验
&lt;/h2&gt;&lt;p&gt;会话技术
传统的技术，用户登录成功后，每次请求都会获取到一个登录标记
会话:用户打开浏览器，访问web服务器，会建立一个会话，直到一方断开连接，会话结束，一次会话包括多次请求和响应
会话跟踪:一种维护浏览器状态的方法，服务器需要识别多次请求是否来自同一浏览器，以便在同一会话的多次请求间共享数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端会话跟踪技术:Cookie&lt;/li&gt;
&lt;li&gt;服务端会话跟踪技术:Session&lt;/li&gt;
&lt;li&gt;令牌技术(现在主流)
方案一:Cookie
优点:HTTP协议中支持的技术(Cookie请求头和Set-Cookie响应头)
请求:(Cookie:name=value)/响应(Set-Cookie:name=value)
缺点:1.移动端无法使用2.不安全，而且用户可以手动禁用Cookie3.Cookie不能跨域
方案二:Session
是通过Cookie服务来获取和传输Session的
优点:存储在服务端，安全
缺点:1.服务器集群下无法直接使用Session2.有Cookie的缺点
方案三:令牌技术
现在的主流技术
优点:1.支持PC端，移动端2.解决集群下的认证问题3.减轻服务器端存储压力
缺点:需要自己实现
JWT令牌
全程:JSON Wen Token JWT官网
定义了一种简洁的，自包含的格式，用于在通信双方以json数据格式安全的传输信息.由于数字签名的存在，这些信息是可靠的
令牌是通过Base64编码的
Base64:是一种基于64个可打印字符(A-Z，a-z，0-9，+，/)来表示二进制的编码方式=表示补位
组成&lt;/li&gt;
&lt;li&gt;第一部分:Header头，记录令牌类型，前面算法等.&lt;/li&gt;
&lt;li&gt;第二部分:Payload(有效载荷)，携带一些自定义信息，默认信息等.&lt;/li&gt;
&lt;li&gt;第三部分:Signature(签名)，防止Token被篡改，确保安全性.将第一，第二，并加入指定密钥，通过签名算法计算而来
JWT场景:登录认证
1.登录成功后生成令牌
2.后续每个请求，都要携带JWT令牌，系统在每次请求处理之前，先校验令牌    ，通过后，再处理
准备工作导入依赖
&lt;dependency&gt;
&lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
&lt;artifactId&gt;jjwt&lt;/artifactId&gt;
&lt;version&gt;0.9.1&lt;/version&gt;
&lt;/dependency&gt;
生成一个完成的JWT令牌:
public void testGenJwt(){
Map&amp;lt;String， Object&amp;gt; clicamt = new HashMap&amp;lt;&amp;gt;();
clicamt.put(&amp;ldquo;id&amp;rdquo;，1);
clicamt.put(&amp;ldquo;name&amp;rdquo;，&amp;ldquo;李&amp;rdquo;);
clicamt.put(&amp;ldquo;age&amp;rdquo;，&amp;ldquo;男&amp;rdquo;);
String jwt = Jwts.builder()
.signWith(SignatureAlgorithm.HS256， &amp;ldquo;liwenchuan&amp;rdquo;)//签名算法和密钥
.setClaims(clicamt)//载荷，一个集合，里面是自定义信息
.setExpiration(new Date(System.currentTimeMillis() + 3600 * 100))//有效期
.compact();
System.out.println(jwt);
}
解析一个JWT令牌
public void testParseJwt(){
Claims claims = Jwts.parser()
.setSigningKey(&amp;ldquo;liwenchuan&amp;rdquo;)//生成时输入的密钥
.parseClaimsJws(&amp;ldquo;eyJhbGciOiJ.2NCwiYWd55S3In0.aspbdDVN_KI4BV&amp;rdquo;)//生成的令牌码
.getBody();//获取body部分
System.out.println(claims);
}
过滤器Filter
概念:Filter过滤器，是JavaWeb三大组件(Servlet，Filter，Listener)之一
过滤器可以把对资源的请求拦截下来，从而实现对一些特殊的功能
过滤器一般完成一些通用的操作，如:登录校验，统一编码处理，敏感字符等&lt;/li&gt;
&lt;li&gt;定义一个Filter:定义一个类，实现Filter接口，并重写所有方法&amp;mdash;其中&amp;hellip;init(){}是初始化方法，启动时调用一次，&amp;hellip;destroy(){}是销毁方法，关闭时调用一次&lt;/li&gt;
&lt;li&gt;配置Filter:Filter类上加@WebFilter注解，配置拦截资源路径.引导类上加@ServletComponentScan开启Servlet组件支持
例:init方法和destroy方法不重写也不会报错
@WebFilter(urlPatterns = &amp;ldquo;/&lt;em&gt;&amp;rdquo;)//表示拦截任何资源
public class DemoFilter implements Filter {
@Override
public void doFilter(ServletRequest Request， ServletResponse Response， FilterChain Chain) throws IOException， ServletException {
System.out.println(&amp;ldquo;拦截到了请求&amp;rdquo;);
Chain.doFilter(Request，Response);//表示放行请求
}
}
执行流程:请求-&amp;gt;放行前逻辑-&amp;gt;放行-&amp;gt;资源-&amp;gt;放行后逻辑
过滤器链:一个web可以设置多个过滤器，就形成了一个过滤器链，执行顺序是按照过滤器类名的自然排序
拦截路径:&amp;quot;/&lt;/em&gt;&amp;quot;，&amp;quot;/emp&amp;quot;，&amp;quot;/emp/&lt;em&gt;&amp;quot; &amp;ndash; 三种拦截方式
登录验证Filter流程
过滤器代码示例:
@Slf4j
@WebFilter(urlPatterns = &amp;ldquo;/&lt;/em&gt;&amp;rdquo;)
public class LoginCheckFilter implements Filter {
@Override
public void doFilter(ServletRequest servletRequest， ServletResponse servletResponse， FilterChain filterChain) throws IOException， ServletException {
HttpServletRequest req = (HttpServletRequest) servletRequest;
HttpServletResponse resp = (HttpServletResponse) servletResponse;
//获取请求头url
String url = req.getRequestURI().toString();
log.info(&amp;ldquo;获取的url为:{}&amp;quot;，url);
//判断是否是登录请求
if (url.contains(&amp;ldquo;login&amp;rdquo;)){
log.info(&amp;ldquo;登录请求，放行&amp;hellip;.&amp;rdquo;);
filterChain.doFilter(servletRequest，servletResponse);
return;}
//不是登录请求.获取JWT令牌，这个令牌是直接从请求头传过来的
String jwt = req.getHeader(&amp;ldquo;token&amp;rdquo;);
//注意这个的感叹号
if (!StringUtils.hasLength(jwt)){
log.info(&amp;ldquo;请求头token为空返回未登录信息&amp;rdquo;);
Result error = Result.error(&amp;ldquo;NOT_LOGIN&amp;rdquo;);
//手动转换成json格式数据返回回去 &amp;mdash;&amp;mdash;-&amp;gt; 使用阿里巴巴的fastJSON工具包
//这里返回规定的错误信息，前端接收后会强转跳转到登录页面
String jsonString = JSONObject.toJSONString(error);
resp.getWriter().write(jsonString);
return;}
//令牌报错的解决方案
try {
//之前导入的令牌分析代码，就是一个工具类
JwtUtils.parseJWT(jwt);
} catch (Exception e) {
e.printStackTrace();
log.info(&amp;ldquo;令牌解析失败，未返回登录信息&amp;rdquo;);
P22~P27}
//令牌通过，放行
log.info(&amp;ldquo;令牌解析成功，返回正确的登录信息&amp;rdquo;);
filterChain.doFilter(servletRequest，servletResponse)}};
拦截器Interceptor&lt;/li&gt;
&lt;li&gt;概念:是一种动态拦截方法调用的机制，类似于过滤器.Spring框架中提供的，用来动态拦截控制器方法的执行&lt;/li&gt;
&lt;li&gt;作用:拦截请求，在指定的方法调用前后，根据业务需要，执行预先定义的代码&lt;/li&gt;
&lt;li&gt;定义拦截器:实现HandlerInterceptor接口，并重写其方法(三个方法都有默认实现，可以根据需要选择实现哪个方法)
建立一个类实现HandlerInterceptor接口并且在类名上面加上注解@Component交给IOC管理
注册拦截器然后实现其方法
1.preHandle方法是入口，资源方法执行前执行，返回true表示放行，否则就是不放行，🎃
2.postHandle方法是目标资源执行后执行
3.afterCompletion方法是视图渲染完毕后执行，最后执行
然后新建个类配置拦截器信息类名上加上注解@Configuration表示是配置类
接着用@Autowired注解来自动注入拦截器类
然后实现WebMvcConfigurer接口并且实现其addInterceptors方法，然后在方法里面去注册拦截器并且规定拦截路径
拦截路径
拦截器流程
拦截器和过滤器区别:接口规范不同，过滤器会拦截所有资源，拦截器只会拦截Spring环境中的资源&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;异常处理&#34;&gt;异常处理
&lt;/h2&gt;&lt;p&gt;出现异常如何处理
方案一:在Controller中进行try&amp;hellip;catch处理 &amp;mdash; 代码臃肿，不推荐
方案二:全局处理异常 &amp;mdash; 简洁，优雅，推荐
定义全局处理异常流程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新建一个类如何类上加注解@RestControllerAdvice表明这个类是异常处理类&lt;/li&gt;
&lt;li&gt;如何定义一个方法方法上加上注解@ExceptionHandler(&amp;hellip;.class)表示处理什么类型的异常
处理任何异常的示例代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;辅助学习系统实例总结&#34;&gt;辅助学习系统实例总结
&lt;/h2&gt;&lt;p&gt;目录格式的正确书写
浏览器访问路径的注解RequestMapping(value=&amp;quot;/aaa&amp;rdquo;，method=&amp;ldquo;get&amp;rdquo;) &amp;mdash; 可以简略为@GetMapper(&amp;quot;/aaa&amp;quot;) post，put delete 都是同理
注意:一个完整的请求路径，应该是类上的@RequestMapping的value属性加上方法上的@RequestMapping的value属性，所以如果有公共请求路径，可以抽取到类上的注解中，方法自己的个有路径
流程:前端请求-&amp;gt;controller-&amp;gt;service-&amp;gt;mapper-&amp;gt;数据库
删除数据使用的是路径接口的形式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@DeleteMapping(&amp;quot;/depts/{id}&amp;quot;)&lt;/li&gt;
&lt;li&gt;public Result delete(@PathVariable Integer id){&amp;hellip;}
修改是先根据id查询信息后，返回对应的实体类，然后修改接口接收这个实体类，然后去修改
如果查询的结果是复合型的数据，就可以再定义个实体类封装这个数据
一个接口实现类可以调用mapper里的两个方法，然后封装进去实体类，返回实体类
@RequestParam的属性defaultvalue可以来设置默认值
分页插件:PageHelper
头像使用的是文件上传功能，上传图片直接调用上传文件接口，然后存储到云服务器，返回一个url地址，然后用标签渲染出来，实现回显功能
修改要先实现根据ID查询，然后把信息返回给一个实体类，修改接口用这个实体类对象来接收数据，实现回显，然后再动态SQL语句实现修改单个或者全部字段数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;事务管理&#34;&gt;事务管理
&lt;/h2&gt;&lt;p&gt;事务回顾:事务就是一组命令，其中一个执行失败，全部回滚到初始状态
Spring事务管理
注解: @Transactional
位置: 业务(service)层的方法上，类上，接口上
作用: 将当前方法交给Spring事务管理，方法执行前，开启事务，执行完毕后提交事务，出现异常回滚事务.
事务属性: rollbackFor
默认情况下只有出现RuntimeException(运行时异常)才会回滚.rollbackFor属性用于控制出现何种异常，事务回滚
示例:@Transactional(rollbackFor = Exception.class) &amp;mdash; 表示所有异常都回滚
事务属性: propagation
事务传播行为:是指当一个事务被另一个事务方法调用时，这个事务方法改如何进行事务控制
事务传播属性值
示例:@Transactional(propagation = Propagation.REQUIRED)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;REQUIRED:大部分情况下用该事务传播&lt;/li&gt;
&lt;li&gt;REQUIRED_NEW:当我们不希望事务互相影响时可以使用该事务，比如日志操作保存，不论是否成功都要有保存&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;aop&#34;&gt;AOP
&lt;/h2&gt;&lt;p&gt;AOP:面向切面编程，面向方面编程，其实就是面向特定方法编程
场景:案例部分功能运行较慢，定位执行耗时较长的业务方法，此时需要统计每一个业务方法的执行耗时
实现:动态代理就是面向切面编程最主流的实现，而SpringAOP是Spring框架的高级技术，旨在管理bean对象的过程中，主要通过底层的动态代理机制，对特定的方法进行编程
三个步骤:
1.获取方法运行开始时间
2.运行原始方法
3.获取方法运行结束时间，计算执行耗时
AOP有哪些应用场景:记录操作日志，权限控制，事务管理，&amp;hellip;
优势:代码无入侵，减少重复代码，提高开发效率，维护方便
示例: 代码表示如果要调用mapper下面任何方法和接口都会先获取开始时间，然后再执行原始方法，最近获取结束时间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;pom文件中先导入依赖
&lt;dependency&gt;
&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
&lt;/dependency&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后AOP类中的具体代码
@Slf4j
@Component //交给IOC管理
@Aspect //表示这个类是一个AOP类
public class TimeAspect {
//这个方法可以抽取重复的切入点的路径，然后可以直接引用
@Pointcut(&amp;ldquo;execution(* com.itheima.tlias.service.&lt;em&gt;.&lt;/em&gt;(..))&amp;rdquo;)
private void pt(){}
@Around(&amp;ldquo;pt()&amp;rdquo;) //表示这个AOP类去管理哪些方法，类，接口
public Object recordTime(ProceedingJoinPoint joinPoint) throws Throwable {
long begin = System.currentTimeMillis(); //获取执行开始的时间
Object proceed = joinPoint.proceed(); //调用原始方法
long end = System.currentTimeMillis(); //获取方法运行结束后的时间
log.info(joinPoint.getSignature()+&amp;ldquo;方法执行的耗时:{}ms&amp;rdquo;，end-begin); //日志输出时间差
return proceed;}} //返回运行结果
AOP核心概念&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接点:JoinPoint，可以被AOP控制的方法(暗含方法执行时的相关信息)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通知:Advice，指哪些重复的逻辑，也就是共性功能(最终体现为一个方法)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切入点:PointCut，匹配连接点的条件，通知仅会在切入点方法执行时被应用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切面:Aspect，描述通知与切入点的对应关系(通知+切入点)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目标对象:Target，通知所应用的对象
AOP进阶
通知类型:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;@Around:环绕通知，此注解标注的在目标方法执行前后都会执行👀&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;@Before:前置通知，此注解标注的在目标方法执行前执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;@After:后置通知，此注解标注的在目标方法执行后执行，无论是否有异常&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;@AfterReturning:返回后通知，此注解标注的在目标方法执行后执行，有异常就不执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;@AfterThrowing:异常后通知，此注解标注的在方法发生异常后执行
@Around环绕通知需要自己调用方法来执行原始方法，其他通知不需要考虑目标方法执行
@Around环绕通知方法的返回值，必须指定是Object，来接收原始方法的返回值
@Pointcut(&amp;quot;&amp;hellip;&amp;hellip;&amp;quot;)该注解功能是把公共切点表达式抽取出来，需要时引用该切点表达式即可
通知顺序
这里研究的是多个切面类的通知执行顺序，同一个切面的通知顺序就不研究了
1.不同切面类中，默认按照切面类的类名字母排序
2.用@Order(数字)加在切面类上来控制顺序
切入点表达式
描述切入点方法的一种表达式，主要用来决定项目中哪些方法需要加入通知
常见形式: 1.execution(&amp;hellip;&amp;hellip;) &amp;ndash; 根据方法签名来匹配  2.@annotation(&amp;hellip;&amp;hellip;) &amp;ndash; 根据注解匹配
🌐标准格式: execution(访问修饰符? 返回值 包名.类名.?方法名(方法参数) throws 异常?) &amp;ndash; 带?表示可省略
示例: @Pointcut(&amp;ldquo;execution(* com.itheima.tlias.service.&lt;em&gt;.&lt;/em&gt;(..))&amp;rdquo; || &amp;ldquo;execution(&amp;hellip;)&amp;rdquo;) &amp;ndash; *表示任意的一个参数，..表示任意的参数
注意:根据业务需要，可以用 且(&amp;amp;&amp;amp;) ， 或(||) ， 非(!) 来组合表达复杂的切入点表达式
🌐标准格式: @annotation(com.itheima.aop.MyLog)
在com.itheima.aop包下新建一个注解MyLog，然后需要哪个方法执行通知就在哪个方法上加上@MyLog注解
连接点
在Spring中JoinPoint抽象了连接点，用它可以获取方法执行时的类名，方法名，参数等
对象@Around通知获取连接点信息只能使用ProceedingJoinPoint
对于其他通知，获取连接点信息只能使用JoinPoint，它是ProceedingJoinPoint的父类型
AOP案例
准备工作:导入AOP依赖，导入数据库表，并引入对象实体类
编码:自定义注解@Log，定义切面类，完成记录操作日志的逻辑
注意:获取request对象，从请求头中获取jwt令牌，解析令牌取出当前用户id&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;web后端开发原理篇&#34;&gt;Web后端开发原理篇
&lt;/h2&gt;&lt;p&gt;配置优先级
application.properties&amp;gt;yml&amp;gt;yaml &amp;mdash; 现在企业主流的时yml配置文件
spring boot除了支持配置文件配置，还支持Java系统属性和命令行参数的方式进行属性配置
Java系统属性 -Dserver.port = 9000 设置端口号为9000
命令行参数 &amp;ndash;server.port = 10010 设置端口号为10010 (比Java系统属性优先级高)
最终优先级: 命令行参数&amp;gt;Java系统属性&amp;gt;application.properties&amp;gt;yml&amp;gt;yaml
Bean管理
1.获取bean
bean别名默认是类名名称首字母小写
根据name获取: Object getBean(String name)
根据类型获取: &lt;T&gt; T getBean(Class&lt;T&gt; requiredType)
根据name获取(带类型转换): &lt;T&gt; T getBean(String name，Class&lt;T&gt; requiredType)
对于Spring项目启动时会把bean自动创建好会受到作用域和延迟初始化的影响，这里主要针对默认的单例非延迟加载的bean而言
@Lazy &amp;ndash; 懒加载 延迟加载
2.bean的作用域
spring支持五种作用域，后三者在web中生效
singleton:容器内，同名称的bean只有一个实例 (单例) (默认)
prototype:每次使用bean时都会创建一个新的实例对象 (非单例)
request:每个请求范围内创建一个新的实例对象 (了解)
session:每个会话范围内创建一个新的实例对象 (了解)
application:每个应用范围内创建一个新的实例对象 (了解)
可以通过@Scope注解来进行配置作用域 &amp;ndash; @Scope(&amp;ldquo;prototype&amp;rdquo;)
3.第三方bean
如果要管理的bean对象来自于第三方(不是自定义)，是无法用@Component来衍生注解声明bean的，就需要用到@Bean注解
若要管理多个第三方bean对象，建议对这些bean进行集中分类配置，可以通过@Configuration注解声明一个配置类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过@Bean注解的name和value属性可以声明bean别名，默认是方法名&lt;/li&gt;
&lt;li&gt;如果第三方bean需要依赖其他bean对象，直接在bean方法中设置形参即可，容器会自动根据类型匹配
SpringBoot原理
原理大部分都是面试题
spring boot的起步依赖原理 - muven的依赖传递
spring boot的自动配置原理 -&lt;/li&gt;
&lt;li&gt;spring boot的启动类只能扫描当前包及其子包&lt;/li&gt;
&lt;li&gt;如果是依赖导入自定义包需要修改启动类扫描范围才能自动配置bean&lt;/li&gt;
&lt;li&gt;方案一:@ComponentScan({&amp;ldquo;com.aaa&amp;rdquo;，&amp;ldquo;com.bbb&amp;rdquo;}) - 指定扫描这两个包，很麻烦，需要每次去配置&lt;/li&gt;
&lt;li&gt;方案二:@Import导入，使用Import导入的类会直接被spring加载到IOC容器中，导入类型主要有以下几种&lt;/li&gt;
&lt;li&gt;导入 普通类&lt;/li&gt;
&lt;li&gt;导入 配置类&lt;/li&gt;
&lt;li&gt;导入 ImportSelector接口实现类&lt;/li&gt;
&lt;li&gt;方案三:@EnableXxxx注解，封装@Import注解 -&lt;/li&gt;
&lt;li&gt;在自定义依赖中定义一个@Enable&amp;hellip;注解&lt;/li&gt;
&lt;li&gt;在注解类上加上要注入的@Import(&amp;hellip;)进行封装&lt;/li&gt;
&lt;li&gt;然后再启动类上加上@Enable&amp;hellip;就直接把需要的bean注入了&lt;/li&gt;
&lt;li&gt;推荐这种
源码解读 &amp;ndash; P190
自动配置原理@Conditional - 按照一定的条件进行判断，满足条件后才会注册对应的bean对象到IOC容器中 (可以加在方法或类上)
@Conditional本身是一个父注解，派生了很多子注解&lt;/li&gt;
&lt;li&gt;@ConditionalOnClass - 判断环境是否有对应的字节码文件&lt;/li&gt;
&lt;li&gt;@ConditionalOnMissingBean - 判断环境中有没有对应的bean&lt;/li&gt;
&lt;li&gt;@ConditionalOnProperty - 判断配置文件中是否有对应的属性和值&lt;/li&gt;
&lt;li&gt;&amp;hellip;&amp;hellip;.省略&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;P193自定义starter依赖
web总结功能
各功能属于什么&lt;/p&gt;
&lt;h2 id=&#34;maven高级&#34;&gt;Maven高级
&lt;/h2&gt;&lt;p&gt;分模块设计
分模块设计就是把各个功能封装成一个个模块，需要的时候直接引入依赖
分模块设计方便维护，后期也方便引入使用
分模块设计是先针对模块功能进行设计，再进行编码，不会先开发完毕再拆分
继承与聚合
继承
继承描述的是两个工程之间的关系，与Java继承相似，子工程可以继承父工程的配置信息，常见多用于依赖的继承
作用:简化工程配置，统一管理依赖
实现:&lt;parent&gt;&amp;hellip;&amp;hellip;..&lt;/parent&gt;
三种打包方式
格式:&lt;packaging&gt;pom&lt;/packaging&gt;(默认是jar)
1.jar:普通模块打包，springboot基本都[[[[是jar包，内嵌tomcat运行
2.war:普通web打包，需要部署在外部的tomcat服务区中运行
3.pom:父工程或聚合工程，该模块不写代码，仅进行依赖管理
版本锁定:在maven中，可以在父工程中的pom文件中通过&lt;dependencyManagement&gt;来统一管理依赖版本
注意:版本锁定是在父工程指定&lt;version&gt;版本号，子工程引入依赖时就不用指定版本号了，版本号由父工程统一管理，如果变更依赖版本，在父工程统一变更
版本锁定的自定义属性/引用属性:
&lt;dependencyManagement&gt;与&lt;dependencies&gt;区别是什么&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dependencies&gt;是直接依赖，自工程会直接继承&lt;/li&gt;
&lt;li&gt;&lt;dependencyManagement&gt;是统一依赖版本管理，子工程使用还需要引入依赖(无需指定版本号)
聚合
聚合:将多个模块组织成一个整体，同时进行项目的构建
聚合工程:一个不具有业务功能的&amp;quot;空&amp;quot;工程(有且仅有一个pom文件)
作用:快速构建项目，(无需根据依赖关系手动构建，直接在聚合工程上构建即可)
在maven中通过&lt;modules&gt;设置当前聚合工程所包含的子模块名称&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意:聚合工程构建时会根据模块间依赖关系设置构建顺序，与聚合工程中模块的配置书写位置无关
继承与聚合
作用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;聚合用于快速构建项目&lt;/li&gt;
&lt;li&gt;继承用于简化依赖配置，统一管理依赖
相同点&lt;/li&gt;
&lt;li&gt;聚合与继承的pom文件打包方式均pom，可以将两种关系制作到同一个pom文件中&lt;/li&gt;
&lt;li&gt;聚合与继承均属于设计型模块，并无实际的模块内容
不同点&lt;/li&gt;
&lt;li&gt;聚合是在聚合工程中配置关系，聚合可以感知到参与聚合的模块有哪些&lt;/li&gt;
&lt;li&gt;继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;私服&#34;&gt;私服
&lt;/h2&gt;&lt;p&gt;私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，用来代理位于外部的中央仓库，用于解决团队内部的资源共享与资源同步问题
依赖查找范围:本地仓库&amp;gt;私服&amp;gt;中央仓库
资源的上传和下载
1.设置私服的访问用户名和密码，在settings.xml中的servers中配置
2.IDEA的maven工程的pom文件中配置上传地址
3.设置私服依赖下载的仓库组地址，在settings.xml中的mirrors，proiles中配置&lt;/p&gt;
&lt;p&gt;报错信息:Syntax&amp;ndash;语法，near&amp;ndash;附件&lt;/p&gt;
&lt;p&gt;结束&lt;/p&gt;
</description>
        </item>
        <item>
        <title>响应状态码</title>
        <link>https://hugo-add.github.io/p/%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81/</link>
        <pubDate>Thu, 19 Sep 2024 21:39:11 +0800</pubDate>
        
        <guid>https://hugo-add.github.io/p/%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81/</guid>
        <description>&lt;img src="https://hugo-add.github.io/p/%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81/a.jpg" alt="Featured image of post 响应状态码" /&gt;&lt;h2 id=&#34;一状态码大类&#34;&gt;一、状态码大类
&lt;/h2&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;状态码分类&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;1xx&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;响应中&lt;/strong&gt;——临时状态码，表示请求已经接受，告诉客户端应该继续请求或者如果它已经完成则忽略它&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;2xx&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;成功&lt;/strong&gt;——表示请求已经被成功接收，处理已完成&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;3xx&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;重定向&lt;/strong&gt;——重定向到其它地方：它让客户端再发起一个请求以完成整个处理。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;4xx&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;客户端错误&lt;/strong&gt;——处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;5xx&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;服务器端错误&lt;/strong&gt;——处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;二常见的响应状态码&#34;&gt;二、常见的响应状态码
&lt;/h2&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;状态码&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;英文描述&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;解释&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;==200==&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;&lt;code&gt;OK&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;客户端请求成功，即&lt;strong&gt;处理成功&lt;/strong&gt;，这是我们最想看到的状态码&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;302&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;&lt;code&gt;Found&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;指示所请求的资源已移动到由&lt;code&gt;Location&lt;/code&gt;响应头给定的 URL，浏览器会自动重新访问到这个页面&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;304&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;&lt;code&gt;Not Modified&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧。隐式重定向&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;400&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;&lt;code&gt;Bad Request&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;客户端请求有&lt;strong&gt;语法错误&lt;/strong&gt;，不能被服务器所理解&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;403&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;&lt;code&gt;Forbidden&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;服务器收到请求，但是&lt;strong&gt;拒绝提供服务&lt;/strong&gt;，比如：没有权限访问相关资源&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;==404==&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;&lt;code&gt;Not Found&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;请求资源不存在&lt;/strong&gt;，一般是URL输入有误，或者网站资源被删除了&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;405&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;&lt;code&gt;Method Not Allowed&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;请求方式有误，比如应该用GET请求方式的资源，用了POST&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;428&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;&lt;code&gt;Precondition Required&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;服务器要求有条件的请求&lt;/strong&gt;，告诉客户端要想访问该资源，必须携带特定的请求头&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;429&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;&lt;code&gt;Too Many Requests&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;指示用户在给定时间内发送了&lt;strong&gt;太多请求&lt;/strong&gt;（“限速”），配合 Retry-After(多长时间后可以请求)响应头一起使用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;431&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;&lt;code&gt; Request Header Fields Too Large&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;请求头太大&lt;/strong&gt;，服务器不愿意处理请求，因为它的头部字段太大。请求可以在减少请求头域的大小后重新提交。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;==500==&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;&lt;code&gt;Internal Server Error&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;服务器发生不可预期的错误&lt;/strong&gt;。服务器出异常了，赶紧看日志去吧&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;503&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;&lt;code&gt;Service Unavailable&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;服务器尚未准备好处理请求&lt;/strong&gt;，服务器刚刚启动，还未初始化好&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;状态码大全：&lt;a class=&#34;link&#34; href=&#34;https://cloud.tencent.com/developer/chapter/13553&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cloud.tencent.com/developer/chapter/13553&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
